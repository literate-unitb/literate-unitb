{-# LANGUAGE OverloadedStrings #-}
module Document.Tests.LockFreeDeque 
    -- ( test_case, test, path4, result4 )
where

    -- Modules
import Document.Tests.Suite as S

import Logic.Proof

import UnitB.Expr
import UnitB.QuasiQuote

    -- Libraries
import Control.Lens hiding (indices)
import Control.Precondition ((!))

import Data.Graph.Bipartite
import Data.List as L
import Data.Map.Class as M
import Data.Set  as S

import Test.UnitTest

import Utilities.Table

test_case :: TestCase
test_case = test

test :: TestCase
test = test_cases
            "Specification and refinement of a lock-free algorithm"
            [ (poCase "test 0, verification, specification with intervals" 
                (verify path0 0) result0)
            , (poCase "test 1, verification, failed proof with intervals" 
                (verify path1 0) result1)
            , (StringCase "test 2, error message name clash in guards" 
                case2 result2)
            , (poCase "test 3, verification, looking up function outside of domain" 
                (verify path3 0) result3)
            , (poCase "test 4, m1, liveness implemented with conditional behavior"
                (verify path4 1) result4)
            , (StringCase "test 5, transient, two branches, enablement of non-empty"
                (proof_obligation path4 "m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN" 1)
                result5)
            , (StringCase "test 6, transient, two branches, enablement of empty"
                (proof_obligation path4 "m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN" 1)
                result6)
            , (StringCase "test 7, transient, two branches, negation of empty"
                (proof_obligation path4 "m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG" 1)
                result7)
            , (StringCase "test 8, transient, two branches, negation of non-empty"
                (proof_obligation path4 "m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG" 1)
                result8)
            , (StringCase "test 9, transient, two branches, follow and disjunction"
                (proof_obligation path4 "m1/LIVE/m1:prog3/ensure/TR/leadsto" 1)
                result9)
            , (StringCase "test 10, duplicate refinement of liveness properties"
                (find_errors path10)
                result10)
            , StringCase "test 11, missing witness"
                (find_errors path11)
                result11
            , poCase "test 12, carrier sets without using sets"
                case12 result12
            , poCase "test 13, event splitting"
                case13 result13
            , Case "test 14, event splitting, event sets"
                case14 result14                
            , Case "test 15, event splitting, expression sets"
                case15 result15
            , Case "test 16, event splitting, index decl"
                case16 result16
            , StringCase "test 17, empty parameter list"
                case17 result17
            , StringCase "test 18, empty list in VarScope"
                case18 result18
            , StringCase "test 19, splitting POs"
                case19 result19
            , poCase "test 20, Lamport proofs"
                case20 result20
            , Case "test 21, new index witness"
                case21 result21
            , Case "test 22, new index proof obligation part a"
                case22 result22
            , Case "test 23, new index proof obligation part b"
                case23 result23
            , poCase "test 24, scoping in index witness feasibility"
                case24 result24
            , poCase "test 25, parameter promotion and inheritance"
                case25 result25
            , poCase "test 26, scoping problem in sequents"
                case26 result26
            -- , POCase "test 27, problem: failure in WD-checking"
            --     case27 result27
            , StringCase "test 28, large WD-condition"
                case28 result28
            ]            

result0 :: String
result0 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/emp@prime"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/FIS/res@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/INV/m0:inv1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act3"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act4"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , "  o  m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:left/WWD"
    , "  o  m0/m0:pop:right/FIS/emp@prime"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/FIS/res@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/INV/m0:inv1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act3"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act4"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:pop:right/WWD"
    , "  o  m0/m0:push:left/FIS/emp@prime"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , "  o  m0/m0:push:left/FIS/res@prime"
    , "  o  m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/INV/m0:inv1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:left/WWD"
    , "  o  m0/m0:push:right/FIS/emp@prime"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , "  o  m0/m0:push:right/FIS/res@prime"
    , "  o  m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/INV/m0:inv1"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , "  o  m0/m0:push:right/WD/GRD"
    , "  o  m0/m0:push:right/WWD"
    , "passed 64 / 64"
    ]

path0 :: FilePath
path0 = "Tests/lock-free deque/main.tex"

path1 :: FilePath
path1 = "Tests/lock-free deque/main2.tex"

result1 :: String
result1 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , "  o  m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:left/WWD"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:pop:right/WWD"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , " xxx m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act2"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:left/WWD"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , " xxx m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act1"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , "  o  m0/m0:push:right/WD/GRD"
    , "  o  m0/m0:push:right/WWD"
    , "passed 51 / 53"
    ]

path2 :: String
path2 = "Tests/lock-free deque/main3.tex"

case2 :: IO String
case2 = find_errors path2


result2 :: String
result2 = unlines
    [ "Multiple expressions with the label m0:inv0"
    , "error 42:1:"
    , "\tinvariant"
    , ""
    , "error 44:4:"
    , "\tinvariant"
    , ""
    , ""
    , "Multiple expressions with the label m0:grd0"
    , "error 86:4:"
    , "\tguard (event 'm0:pop:right')"
    , ""
    , "error 87:4:"
    , "\tguard (event 'm0:pop:right')"
    , ""
    , ""
    ]

path3 :: String
path3 = "Tests/lock-free deque/main4.tex"

result3 :: String
result3 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/INV/m0:inv1"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/SCH/x"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , " xxx m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:left/WWD"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/INV/m0:inv1"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/SCH/x"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:pop:right/WWD"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , "  o  m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/INV/m0:inv1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act2"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:left/WWD"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , "  o  m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/INV/m0:inv1"
    , "  o  m0/m0:push:right/SCH/x"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act1"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , " xxx m0/m0:push:right/WD/GRD"
    , "  o  m0/m0:push:right/WWD"
    , "passed 59 / 61"
    ]

path4 :: FilePath
path4 = "Tests/lock-free deque/main6.tex"

result4 :: String
result4 = unlines
    [ "  o  m1/INIT/FIS/p"
    , "  o  m1/INIT/FIS/q"
    , "  o  m1/INIT/FIS/qe"
    , "  o  m1/INIT/FIS/resL"
    , "  o  m1/INIT/FIS/resR"
    , "  o  m1/INIT/INV/m1:inv0"
    , "  o  m1/INIT/INV/m1:inv1"
    , "  o  m1/INIT/WD"
    , "  o  m1/INIT/WWD"
    , "  o  m1/INV/WD"
    , "  o  m1/LIVE/m1:prog0/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/m1:prog0/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/WD"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/WD/witness/r"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/m0:push:left/EN"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/m0:push:left/NEG"
    , "  o  m1/LIVE/m1:prog1/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/m1:prog1/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/WD"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/WD/witness/r"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/m0:push:right/EN"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/m0:push:right/NEG"
    , "  o  m1/LIVE/m1:prog2/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/m1:prog2/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/WD"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/WD/witness/r"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/leadsto"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:empty/EN"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:empty/NEG"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:non:empty/EN"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:non:empty/NEG"
    , "  o  m1/LIVE/m1:prog3/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/m1:prog3/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/WD"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/WD/witness/r"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/leadsto"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG"
    , "  o  m1/m0:pop:left:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:left:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:left:empty/FIS/p@prime"
    , "  o  m1/m0:pop:left:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:left:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:left:empty/FIS/q@prime"
    , "  o  m1/m0:pop:left:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:left:empty/FIS/res@prime"
    , "  o  m1/m0:pop:left:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:left:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:left:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:left:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:left:empty/IWWD/m0:pop:left:empty"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:left:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:left:empty/WD/ACT/m1:a4"
    , "  o  m1/m0:pop:left:empty/WD/C_SCH"
    , "  o  m1/m0:pop:left:empty/WD/F_SCH"
    , "  o  m1/m0:pop:left:empty/WD/GRD"
    , "  o  m1/m0:pop:left:empty/WWD"
    , "  o  m1/m0:pop:left:non:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:left:non:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/p@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/q@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/res@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:left:non:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:left:non:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:left:non:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:left:non:empty/IWWD/m0:pop:left:non:empty"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:left:non:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:left:non:empty/SCH/m1:grd0"
    , "  o  m1/m0:pop:left:non:empty/WD/ACT/m1:a4"
    , "  o  m1/m0:pop:left:non:empty/WD/ACT/m1:a5"
    , "  o  m1/m0:pop:left:non:empty/WD/C_SCH"
    , "  o  m1/m0:pop:left:non:empty/WD/F_SCH"
    , "  o  m1/m0:pop:left:non:empty/WD/GRD"
    , "  o  m1/m0:pop:left:non:empty/WWD"
    , "  o  m1/m0:pop:right:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:right:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:right:empty/FIS/p@prime"
    , "  o  m1/m0:pop:right:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:right:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:right:empty/FIS/q@prime"
    , "  o  m1/m0:pop:right:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:right:empty/FIS/res@prime"
    , "  o  m1/m0:pop:right:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:right:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:right:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:right:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:right:empty/IWWD/m0:pop:right:empty"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:right:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:right:empty/WD/ACT/m1:a2"
    , "  o  m1/m0:pop:right:empty/WD/C_SCH"
    , "  o  m1/m0:pop:right:empty/WD/F_SCH"
    , "  o  m1/m0:pop:right:empty/WD/GRD"
    , "  o  m1/m0:pop:right:empty/WWD"
    , "  o  m1/m0:pop:right:non:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:right:non:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/p@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/q@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/res@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:right:non:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:right:non:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:right:non:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:right:non:empty/IWWD/m0:pop:right:non:empty"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:right:non:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:right:non:empty/SCH/m1:grd0"
    , "  o  m1/m0:pop:right:non:empty/WD/ACT/m1:a2"
    , "  o  m1/m0:pop:right:non:empty/WD/ACT/m1:a3"
    , "  o  m1/m0:pop:right:non:empty/WD/C_SCH"
    , "  o  m1/m0:pop:right:non:empty/WD/F_SCH"
    , "  o  m1/m0:pop:right:non:empty/WD/GRD"
    , "  o  m1/m0:pop:right:non:empty/WWD"
    , "  o  m1/m0:push:left/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:push:left/FIS/emp@prime"
    , "  o  m1/m0:push:left/FIS/p@prime"
    , "  o  m1/m0:push:left/FIS/popL@prime"
    , "  o  m1/m0:push:left/FIS/popR@prime"
    , "  o  m1/m0:push:left/FIS/pshL@prime"
    , "  o  m1/m0:push:left/FIS/pshR@prime"
    , "  o  m1/m0:push:left/FIS/q@prime"
    , "  o  m1/m0:push:left/FIS/qe@prime"
    , "  o  m1/m0:push:left/FIS/res@prime"
    , "  o  m1/m0:push:left/FIS/resL@prime"
    , "  o  m1/m0:push:left/FIS/resR@prime"
    , "  o  m1/m0:push:left/INV/m1:inv0"
    , "  o  m1/m0:push:left/INV/m1:inv1"
    , "  o  m1/m0:push:left/IWWD/m0:push:left"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:push:left/SCH"
    , "  o  m1/m0:push:left/SCH/x"
    , "  o  m1/m0:push:left/WD/ACT/m1:a0"
    , "  o  m1/m0:push:left/WD/C_SCH"
    , "  o  m1/m0:push:left/WD/F_SCH"
    , "  o  m1/m0:push:left/WD/GRD"
    , "  o  m1/m0:push:left/WWD"
    , "  o  m1/m0:push:right/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:push:right/FIS/emp@prime"
    , "  o  m1/m0:push:right/FIS/p@prime"
    , "  o  m1/m0:push:right/FIS/popL@prime"
    , "  o  m1/m0:push:right/FIS/popR@prime"
    , "  o  m1/m0:push:right/FIS/pshL@prime"
    , "  o  m1/m0:push:right/FIS/pshR@prime"
    , "  o  m1/m0:push:right/FIS/q@prime"
    , "  o  m1/m0:push:right/FIS/qe@prime"
    , "  o  m1/m0:push:right/FIS/res@prime"
    , "  o  m1/m0:push:right/FIS/resL@prime"
    , "  o  m1/m0:push:right/FIS/resR@prime"
    , "  o  m1/m0:push:right/INV/m1:inv0"
    , "  o  m1/m0:push:right/INV/m1:inv1"
    , "  o  m1/m0:push:right/IWWD/m0:push:right"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:push:right/SCH"
    , "  o  m1/m0:push:right/SCH/x"
    , "  o  m1/m0:push:right/WD/ACT/m1:a0"
    , "  o  m1/m0:push:right/WD/C_SCH"
    , "  o  m1/m0:push:right/WD/F_SCH"
    , "  o  m1/m0:push:right/WD/GRD"
    , "  o  m1/m0:push:right/WWD"
    , "  o  m1/m1:prog0/PROG/WD/lhs"
    , "  o  m1/m1:prog0/PROG/WD/rhs"
    , "  o  m1/m1:prog1/PROG/WD/lhs"
    , "  o  m1/m1:prog1/PROG/WD/rhs"
    , "  o  m1/m1:prog2/PROG/WD/lhs"
    , "  o  m1/m1:prog2/PROG/WD/rhs"
    , "  o  m1/m1:prog3/PROG/WD/lhs"
    , "  o  m1/m1:prog3/PROG/WD/rhs"
    , "passed 212 / 212"
    ]

    -- enablement non-empty
result5 :: String
result5 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const pshL (pfun sl$REQ sl$G))"
    , "(declare-const pshL@prime (pfun sl$REQ sl$G))"
    , "(declare-const pshR (pfun sl$REQ sl$G))"
    , "(declare-const pshR@prime (pfun sl$REQ sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$REQ)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-const resL (pfun sl$REQ sl$G))"
    , "(declare-const resL@prime (pfun sl$REQ sl$G))"
    , "(declare-const resR (pfun sl$REQ sl$G))"
    , "(declare-const resR@prime (pfun sl$REQ sl$G))"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun ovl@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun r@param () sl$REQ)"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl$G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$G s2) (finite@@sl$G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G s2)"
    , "                     (finite@@sl$G s1) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$REQ s2) (finite@@sl$REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ s2)"
    , "                     (finite@@sl$REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)"
    , "           empty-set@@sl$REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)"
    , "           empty-set@@sl$REQ))"
    , "(assert (not (=> (and (elem@@sl$REQ r popL) (elem@@sl$REQ r popL))"
    , "                 (elem@@sl$REQ r@param popL))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN"
    ]

result6 :: String
result6 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const pshL (pfun sl$REQ sl$G))"
    , "(declare-const pshL@prime (pfun sl$REQ sl$G))"
    , "(declare-const pshR (pfun sl$REQ sl$G))"
    , "(declare-const pshR@prime (pfun sl$REQ sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$REQ)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-const resL (pfun sl$REQ sl$G))"
    , "(declare-const resL@prime (pfun sl$REQ sl$G))"
    , "(declare-const resR (pfun sl$REQ sl$G))"
    , "(declare-const resR@prime (pfun sl$REQ sl$G))"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun ovl@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun r@param () sl$REQ)"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl$G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$G s2) (finite@@sl$G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G s2)"
    , "                     (finite@@sl$G s1) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$REQ s2) (finite@@sl$REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ s2)"
    , "                     (finite@@sl$REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)"
    , "           empty-set@@sl$REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)"
    , "           empty-set@@sl$REQ))"
    , "(assert (not (=> (and (elem@@sl$REQ r popL) (elem@@sl$REQ r popL))"
    , "                 (elem@@sl$REQ r@param popL))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN"
    ]

result7 :: String
result7 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const pshL (pfun sl$REQ sl$G))"
    , "(declare-const pshL@prime (pfun sl$REQ sl$G))"
    , "(declare-const pshR (pfun sl$REQ sl$G))"
    , "(declare-const pshR@prime (pfun sl$REQ sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$REQ)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-const resL (pfun sl$REQ sl$G))"
    , "(declare-const resL@prime (pfun sl$REQ sl$G))"
    , "(declare-const resR (pfun sl$REQ sl$G))"
    , "(declare-const resR@prime (pfun sl$REQ sl$G))"
    , "(declare-fun apply@@Int@@sl$G ( (pfun Int sl$G) Int ) sl$G)"
    , "(declare-fun apply@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               sl$REQ )"
    , "             sl$G)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl$G (Int sl$G) (pfun Int sl$G))"
    , "(declare-fun mk-fun@@sl$REQ@@sl$G"
    , "             (sl$REQ sl$G)"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$G (sl$G) (set sl$G))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun ovl@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun r@param () sl$REQ)"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$G"
    , "            ( (x sl$G)"
    , "              (s1 (set sl$G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$G) )"
    , "                (! (= (card@@sl$G (mk-set@@sl$G x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$G (mk-set@@sl$G x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 1)"
    , "                      (exists ( (x sl$G) ) (and true (= r (mk-set@@sl$G x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (dom@@Int@@sl$G (mk-fun@@Int@@sl$G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (mk-fun@@Int@@sl$G x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y))"
    , "                      (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$G f2))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x)"
    , "                          (apply@@Int@@sl$G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f2))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$G f2))))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f2))))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@Int@@sl$G (mk-fun@@Int@@sl$G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (mk-fun@@Int@@sl$G x y) x) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$G f1)))"
    , "                       (= (apply@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x s1)"
    , "                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1)))"
    , "                       (= (apply@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                       (= (apply@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (= (apply@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                           (= (apply@@Int@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                     (apply@@Int@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                           (= (apply@@Int@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                     (apply@@Int@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                           (= (apply@@sl$REQ@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                     (apply@@sl$REQ@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                           (= (apply@@sl$REQ@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                     (apply@@sl$REQ@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x2)"
    , "                          (apply@@Int@@sl$G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (x2 sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                               x2)"
    , "                          (apply@@sl$REQ@@sl$G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G y (ran@@Int@@sl$G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                                        (= (apply@@Int@@sl$G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G y (ran@@Int@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G y (ran@@sl$REQ@@sl$G f1))"
    , "                      (exists ( (x sl$REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                                        (= (apply@@sl$REQ@@sl$G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G y (ran@@sl$REQ@@sl$G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (ran@@Int@@sl$G (mk-fun@@Int@@sl$G x y))"
    , "                      (mk-set@@sl$G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (mk-fun@@Int@@sl$G x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (ran@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y))"
    , "                      (mk-set@@sl$G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (injective@@Int@@sl$G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$G f1)))"
    , "                                  (=> (= (apply@@Int@@sl$G f1 x) (apply@@Int@@sl$G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (injective@@sl$REQ@@sl$G f1)"
    , "                      (forall ( (x sl$REQ)"
    , "                                (x2 sl$REQ) )"
    , "                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$G f1)))"
    , "                                  (=> (= (apply@@sl$REQ@@sl$G f1 x)"
    , "                                         (apply@@sl$REQ@@sl$G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$REQ@@sl$G f1) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x) (ran@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x) (ran@@Int@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x) (ran@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x) (ran@@sl$REQ@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                   (ran@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                 (ran@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                   (ran@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                 (ran@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                   (ran@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                 (ran@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                   (ran@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                 (ran@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                            (injective@@Int@@sl$G f1))"
    , "                       (= (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)))"
    , "                          (union (set-diff@@sl$G (ran@@Int@@sl$G f1)"
    , "                                                 (mk-set@@sl$G (apply@@Int@@sl$G f1 x)))"
    , "                                 (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                            (injective@@sl$REQ@@sl$G f1))"
    , "                       (= (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y)))"
    , "                          (union (set-diff@@sl$G (ran@@sl$REQ@@sl$G f1)"
    , "                                                 (mk-set@@sl$G (apply@@sl$REQ@@sl$G f1 x)))"
    , "                                 (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$G f1)))"
    , "                       (= (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)))"
    , "                          (union (ran@@Int@@sl$G f1) (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1)))"
    , "                       (= (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y)))"
    , "                          (union (ran@@sl$REQ@@sl$G f1) (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$G)"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G x (mk-set@@sl$G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G x (mk-set@@sl$G y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$G) )"
    , "                (! (finite@@sl$G (mk-set@@sl$G x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (mk-set@@sl$G x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl$G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$G s2) (finite@@sl$G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G s2)"
    , "                     (finite@@sl$G s1) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$REQ s2) (finite@@sl$REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ s2)"
    , "                     (finite@@sl$REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; SKIP:p"
    , "(assert (= p@prime p))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:qe"
    , "(assert (= qe@prime qe))"
    , "; SKIP:res"
    , "(assert (= res@prime res))"
    , "; SKIP:resL"
    , "(assert (= resL@prime resL))"
    , "; SKIP:resR"
    , "(assert (= resR@prime resR))"
    , "; m0:act4"
    , "(assert (= emp@prime true))"
    , "; m0:grd0"
    , "(assert (= p q))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:a4"
    , "(assert (= popL@prime"
    , "           (set-diff@@sl$REQ popL (mk-set@@sl$REQ r@param))))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)"
    , "           empty-set@@sl$REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)"
    , "           empty-set@@sl$REQ))"
    , "; m1:sch0"
    , "(assert (elem@@sl$REQ r@param popL))"
    , "; m1:sch1"
    , "(assert (= p q))"
    , "(assert (not (=> (and (elem@@sl$REQ r popL) (elem@@sl$REQ r popL))"
    , "                 (not (and (elem@@sl$REQ r popL@prime)"
    , "                           (elem@@sl$REQ r popL@prime))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG"
    ]

result8 :: String
result8 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const pshL (pfun sl$REQ sl$G))"
    , "(declare-const pshL@prime (pfun sl$REQ sl$G))"
    , "(declare-const pshR (pfun sl$REQ sl$G))"
    , "(declare-const pshR@prime (pfun sl$REQ sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$REQ)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-const resL (pfun sl$REQ sl$G))"
    , "(declare-const resL@prime (pfun sl$REQ sl$G))"
    , "(declare-const resR (pfun sl$REQ sl$G))"
    , "(declare-const resR@prime (pfun sl$REQ sl$G))"
    , "(declare-fun apply@@Int@@sl$G ( (pfun Int sl$G) Int ) sl$G)"
    , "(declare-fun apply@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               sl$REQ )"
    , "             sl$G)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl$G (Int sl$G) (pfun Int sl$G))"
    , "(declare-fun mk-fun@@sl$REQ@@sl$G"
    , "             (sl$REQ sl$G)"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$G (sl$G) (set sl$G))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun ovl@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun r@param () sl$REQ)"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$G"
    , "            ( (x sl$G)"
    , "              (s1 (set sl$G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$G) )"
    , "                (! (= (card@@sl$G (mk-set@@sl$G x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$G (mk-set@@sl$G x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 1)"
    , "                      (exists ( (x sl$G) ) (and true (= r (mk-set@@sl$G x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (dom@@Int@@sl$G (mk-fun@@Int@@sl$G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (mk-fun@@Int@@sl$G x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y))"
    , "                      (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$G f2))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x)"
    , "                          (apply@@Int@@sl$G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f2))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$G f2))))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f2))))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@Int@@sl$G (mk-fun@@Int@@sl$G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (mk-fun@@Int@@sl$G x y) x) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$G f1)))"
    , "                       (= (apply@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x s1)"
    , "                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1)))"
    , "                       (= (apply@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                       (= (apply@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1) x)"
    , "                          (apply@@Int@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (= (apply@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1) x) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                           (= (apply@@Int@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                     (apply@@Int@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                           (= (apply@@Int@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                     (apply@@Int@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                           (= (apply@@sl$REQ@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                     (apply@@sl$REQ@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                           (= (apply@@sl$REQ@@sl$G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                     (apply@@sl$REQ@@sl$G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x2)"
    , "                          (apply@@Int@@sl$G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (x2 sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                               x2)"
    , "                          (apply@@sl$REQ@@sl$G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G y (ran@@Int@@sl$G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                                        (= (apply@@Int@@sl$G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G y (ran@@Int@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G y (ran@@sl$REQ@@sl$G f1))"
    , "                      (exists ( (x sl$REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                                        (= (apply@@sl$REQ@@sl$G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G y (ran@@sl$REQ@@sl$G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$G) )"
    , "                (! (= (ran@@Int@@sl$G (mk-fun@@Int@@sl$G x y))"
    , "                      (mk-set@@sl$G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (mk-fun@@Int@@sl$G x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (= (ran@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y))"
    , "                      (mk-set@@sl$G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (mk-fun@@sl$REQ@@sl$G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (injective@@Int@@sl$G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$G f1)))"
    , "                                  (=> (= (apply@@Int@@sl$G f1 x) (apply@@Int@@sl$G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (injective@@sl$REQ@@sl$G f1)"
    , "                      (forall ( (x sl$REQ)"
    , "                                (x2 sl$REQ) )"
    , "                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$G f1)))"
    , "                                  (=> (= (apply@@sl$REQ@@sl$G f1 x)"
    , "                                         (apply@@sl$REQ@@sl$G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$REQ@@sl$G f1) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x) (ran@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x) (ran@@Int@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x) (ran@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x) (ran@@sl$REQ@@sl$G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                   (ran@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                 (ran@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                   (ran@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                 (ran@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                   (ran@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@Int@@sl$G f1 x)"
    , "                                 (ran@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$G f1) s1))"
    , "                       (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                   (ran@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G (apply@@sl$REQ@@sl$G f1 x)"
    , "                                 (ran@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$G f1))"
    , "                            (injective@@Int@@sl$G f1))"
    , "                       (= (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)))"
    , "                          (union (set-diff@@sl$G (ran@@Int@@sl$G f1)"
    , "                                                 (mk-set@@sl$G (apply@@Int@@sl$G f1 x)))"
    , "                                 (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1))"
    , "                            (injective@@sl$REQ@@sl$G f1))"
    , "                       (= (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y)))"
    , "                          (union (set-diff@@sl$G (ran@@sl$REQ@@sl$G f1)"
    , "                                                 (mk-set@@sl$G (apply@@sl$REQ@@sl$G f1 x)))"
    , "                                 (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (x Int)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$G f1)))"
    , "                       (= (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y)))"
    , "                          (union (ran@@Int@@sl$G f1) (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$G (ovl@@Int@@sl$G f1 (mk-fun@@Int@@sl$G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (x sl$REQ)"
    , "                  (y sl$G) )"
    , "                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$G f1)))"
    , "                       (= (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y)))"
    , "                          (union (ran@@sl$REQ@@sl$G f1) (mk-set@@sl$G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 (mk-fun@@sl$REQ@@sl$G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$G)"
    , "                  (y sl$G) )"
    , "                (! (= (elem@@sl$G x (mk-set@@sl$G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$G x (mk-set@@sl$G y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$G) )"
    , "                (! (finite@@sl$G (mk-set@@sl$G x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (mk-set@@sl$G x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl$G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$G s2) (finite@@sl$G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G s2)"
    , "                     (finite@@sl$G s1) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$REQ s2) (finite@@sl$REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ s2)"
    , "                     (finite@@sl$REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:resR"
    , "(assert (= resR@prime resR))"
    , "; m0:act0"
    , "(assert (= qe@prime (dom-subt@@Int@@sl$G (mk-set@@Int p) qe)))"
    , "; m0:act1"
    , "(assert (= p@prime (+ p 1)))"
    , "; m0:act3"
    , "(assert (= res@prime (apply@@Int@@sl$G qe p)))"
    , "; m0:act4"
    , "(assert (= emp@prime false))"
    , "; m0:grd0"
    , "(assert (< p q))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:a4"
    , "(assert (= popL@prime"
    , "           (set-diff@@sl$REQ popL (mk-set@@sl$REQ r@param))))"
    , "; m1:a5"
    , "(assert (= resL@prime"
    , "           (ovl@@sl$REQ@@sl$G resL"
    , "                              (mk-fun@@sl$REQ@@sl$G r@param (apply@@Int@@sl$G qe p)))))"
    , "; m1:grd0"
    , "(assert (elem@@sl$REQ r@param popL))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)"
    , "           empty-set@@sl$REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)"
    , "           empty-set@@sl$REQ))"
    , "; m1:sch0"
    , "(assert (elem@@sl$REQ r@param popL))"
    , "; m1:sch1"
    , "(assert (< p q))"
    , "(assert (not (=> (and (elem@@sl$REQ r popL) (elem@@sl$REQ r popL))"
    , "                 (not (and (elem@@sl$REQ r popL@prime)"
    , "                           (elem@@sl$REQ r popL@prime))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG"
    ]

result9 :: String
result9 = unlines
    [ "; m1/LIVE/m1:prog3/ensure/TR/leadsto"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popL@prime (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const popR@prime (set sl$REQ))"
    , "(declare-const pshL (pfun sl$REQ sl$G))"
    , "(declare-const pshL@prime (pfun sl$REQ sl$G))"
    , "(declare-const pshR (pfun sl$REQ sl$G))"
    , "(declare-const pshR@prime (pfun sl$REQ sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$REQ)"
    , "(declare-const r@m0-pop-left-empty sl$REQ)"
    , "(declare-const r@m0-pop-left-non-empty sl$REQ)"
    , "(declare-const r0 sl$REQ)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-const resL (pfun sl$REQ sl$G))"
    , "(declare-const resL@prime (pfun sl$REQ sl$G))"
    , "(declare-const resR (pfun sl$REQ sl$G))"
    , "(declare-const resR@prime (pfun sl$REQ sl$G))"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$G"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$G () (pfun sl$REQ sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun ovl@@sl$REQ@@sl$G"
    , "             ( (pfun sl$REQ sl$G)"
    , "               (pfun sl$REQ sl$G) )"
    , "             (pfun sl$REQ sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun ran@@sl$REQ@@sl$G ( (pfun sl$REQ sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G f1 empty-fun@@sl$REQ@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G f1) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (f2 (pfun sl$REQ sl$G)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$G f1) (dom@@sl$REQ@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (ovl@@sl$REQ@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-rest@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$G))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$G (dom-subt@@sl$REQ@@sl$G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (= (ran@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (injective@@sl$REQ@@sl$G empty-fun@@sl$REQ@@sl$G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl$G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$G s2) (finite@@sl$G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G s2)"
    , "                     (finite@@sl$G s1) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$REQ s2) (finite@@sl$REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ s2)"
    , "                     (finite@@sl$REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (not (forall ( (r sl$REQ)"
    , "                       (r@m0-pop-left-empty sl$REQ)"
    , "                       (r@m0-pop-left-non-empty sl$REQ) )"
    , "                     (=> (and (elem@@sl$REQ r popL)"
    , "                              (elem@@sl$REQ r popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "(assert (not (forall ( (r@m0-pop-left-empty sl$REQ)"
    , "                       (r@m0-pop-left-non-empty sl$REQ) )"
    , "                     (=> (and (elem@@sl$REQ r0 popL)"
    , "                              (elem@@sl$REQ r0 popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "(assert (not (forall ( (r@m0-pop-left-non-empty sl$REQ) )"
    , "                     (=> (and (elem@@sl$REQ r0 popL)"
    , "                              (elem@@sl$REQ r0 popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl$REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resR) popR)"
    , "           empty-set@@sl$REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl$REQ@@sl$G resL) popL)"
    , "           empty-set@@sl$REQ))"
    , "(assert (not (=> (and (elem@@sl$REQ r0 popL)"
    , "                      (elem@@sl$REQ r0 popL)"
    , "                      (elem@@sl$REQ r@m0-pop-left-empty popL)"
    , "                      (elem@@sl$REQ r@m0-pop-left-non-empty popL))"
    , "                 (or (= p q) (< p q)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/leadsto"
    ]

path10 :: FilePath 
path10 = "Tests/lock-free deque/main6-err0.tex"

result10 :: String
result10 = unlines
    [ "Multiple refinement of progress property m1:prog3"
    , "error 223:5:"
    , "\tm1:prog3"
    , ""
    , "error 255:1:"
    , "\tm1:prog3"
    , ""
    , ""
    ]

path11 :: FilePath 
path11 = "Tests/lock-free deque/main6-err1.tex"

result11 :: String
result11 = unlines
    [ "error 223:5:"
    , "    A witness is needed for r in event 'm0:pop:left:empty'"
    , "error 223:5:"
    , "    A witness is needed for r in event 'm0:pop:left:non:empty'"
    ]

path12 :: FilePath
path12 = "Tests/lock-free deque/main7-err0.tex"

case12 :: IO (String, Table Label Sequent)
case12 = verify path12 0

result12 :: String
result12 = unlines
    [ "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "passed 3 / 3"
    ]

path13 :: FilePath
path13 = "Tests/lock-free deque/main7.tex"

case13 :: IO (String, Table Label Sequent)
case13 = verify path13 0

result13 :: String
result13 = unlines
    [ "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/v@prime"
    , "  o  m0/evt/WD/ACT/act0"
    , "  o  m0/evt/WD/C_SCH"
    , "  o  m0/evt/WD/F_SCH"
    , "  o  m0/evt/WD/GRD"
    , "  o  m0/evt/WWD"
    , "passed 9 / 9"
    ]

case14 :: IO (Either String ([SkipOrEvent],[SkipOrEvent],[SkipOrEvent]))
case14 = runEitherT $ do
    ms <- view' machines <$> get_system path13
    let m0 = ms ! "m0"
        m1 = ms ! "m1"
        m2 = ms ! "m2"
    return $ (m0,m1,m2) & each %~ (M.keys . rightMap . view' events)

result14 :: Either String ([SkipOrEvent],[SkipOrEvent],[SkipOrEvent])
result14 = Right $ ([Left SkipEvent,"evt"],[Left SkipEvent,"evt0","evt1","evt2"],[Left SkipEvent,"evt0","evt1","evt2"])

type ExprSet = [(SkipOrEvent,[Label])]

case15 :: IO (Either String (ExprSet,ExprSet,ExprSet))
case15 = runEitherT $ do
    ms <- view' machines <$> get_system path13
    let m0 = ms ! "m0"
        m1 = ms ! "m1"
        m2 = ms ! "m2"
        exprs e = S.toList $ keysSet (view actions e) `S.union` keysSet (view guards e)
    return $ (m0,m1,m2) & each %~ (M.toAscList . M.map exprs . rightMap . view' events)

result15 :: Either String (ExprSet,ExprSet,ExprSet)
result15 = Right   ( [(Left SkipEvent,[]),("evt",["act0"])]
                   , [(Left SkipEvent,[]),("evt0",["act0"]),("evt1",["act0","grd0"]),("evt2",["act0"])]
                   , [(Left SkipEvent,[]),("evt0",["act0"]),("evt1",["act0","grd0"]),("evt2",["act0"])])

case16 :: IO (Either String (ExprSet,ExprSet,ExprSet))
case16 = runEitherT $ do
    ms <- view' machines <$> get_system path13
    let m0 = ms ! "m0"
        m1 = ms ! "m1"
        m2 = ms ! "m2"
        decls e = L.map as_label $ M.ascKeys (view indices e)
    return $ (m0,m1,m2) & each %~ (M.toAscList . M.map decls . rightMap . view' events)

result16 :: Either String (ExprSet,ExprSet,ExprSet)
result16 = Right   ( [(Left SkipEvent,[]),("evt",["p"])]
                   , [(Left SkipEvent,[]),("evt0",["p"]),("evt1",["p"]),("evt2",["p","q"])]
                   , [(Left SkipEvent,[]),("evt0",["p"]),("evt1",["p"]),("evt2",["p","q"])])

path17 :: FilePath
path17 = "Tests/lock-free deque/main8-err0.tex"

case17 :: IO String
case17 = find_errors path17

result17 :: String
result17 = unlines
    [ "error 60:12:"
    , "    expecting more arguments"
    ]

path18 :: FilePath
path18 = "Tests/lock-free deque/main8-err1.tex"

case18 :: IO String
case18 = find_errors path18

result18 :: String
result18 = concat
    [ "no errors"
    ]

path19 :: FilePath
path19 = "Tests/lock-free deque/main8.tex"

case19 :: IO String
case19 = proof_obligation path19 "m1/resp:pop:left/F_SCH/replace/eqv" 1

result19 :: String
result19 = unlines
    [ "; m1/resp:pop:left/F_SCH/replace/eqv"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl$G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(declare-sort sl$Req 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const ppL (set sl$Req))"
    , "(declare-const ppL@prime (set sl$Req))"
    , "(declare-const ppR (set sl$Req))"
    , "(declare-const ppR@prime (set sl$Req))"
    , "(declare-const psL (pfun sl$Req sl$G))"
    , "(declare-const psL@prime (pfun sl$Req sl$G))"
    , "(declare-const psR (pfun sl$Req sl$G))"
    , "(declare-const psR@prime (pfun sl$Req sl$G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl$G))"
    , "(declare-const qe@prime (pfun Int sl$G))"
    , "(declare-const r sl$Req)"
    , "(declare-const res sl$G)"
    , "(declare-const res@prime sl$G)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$G ( (set sl$G) ) Int)"
    , "(declare-fun card@@sl$Req ( (set sl$Req) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$G ( (pfun Int sl$G) ) (set Int))"
    , "(declare-fun dom-rest@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun dom-subt@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun empty-fun@@Int@@sl$G () (pfun Int sl$G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$G ( (set sl$G) ) Bool)"
    , "(declare-fun finite@@sl$Req ( (set sl$Req) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (set (pfun Int sl$G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$G ( (pfun Int sl$G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$Req (sl$Req) (set sl$Req))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$G@Close"
    , "             ( (pfun Int sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ovl@@Int@@sl$G"
    , "             ( (pfun Int sl$G)"
    , "               (pfun Int sl$G) )"
    , "             (pfun Int sl$G))"
    , "(declare-fun pfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(declare-fun ran@@Int@@sl$G ( (pfun Int sl$G) ) (set sl$G))"
    , "(declare-fun tfun@@Int@@sl$G"
    , "             ( (set Int)"
    , "               (set sl$G) )"
    , "             (set (pfun Int sl$G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              true ))"
    , "(define-fun all@@sl$Req"
    , "            ()"
    , "            (set sl$Req)"
    , "            ( (as const (set sl$Req))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$G"
    , "            ( (s1 (set sl$G)) )"
    , "            (set sl$G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Req"
    , "            ( (s1 (set sl$Req)) )"
    , "            (set sl$Req)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$Req"
    , "            ( (x sl$Req)"
    , "              (s1 (set sl$Req)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (x (pfun Int sl$G))"
    , "              (s1 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$G"
    , "            ()"
    , "            (set sl$G)"
    , "            ( (as const (set sl$G))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Req"
    , "            ()"
    , "            (set sl$Req)"
    , "            ( (as const (set sl$Req))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$G@Close"
    , "            ()"
    , "            (set (pfun Int sl$G))"
    , "            ( (as const (set (pfun Int sl$G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            (set sl$G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Req"
    , "            ( (s1 (set sl$Req))"
    , "              (s2 (set sl$Req)) )"
    , "            (set sl$Req)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            (set (pfun Int sl$G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$G"
    , "            ( (s1 (set sl$G))"
    , "              (s2 (set sl$G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Req"
    , "            ( (s1 (set sl$Req))"
    , "              (s2 (set sl$Req)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$G@Close"
    , "            ( (s1 (set (pfun Int sl$G)))"
    , "              (s2 (set (pfun Int sl$G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$G () (set sl$G) ( (as const (set sl$G)) true ))"
    , "(define-fun sl$Req"
    , "            ()"
    , "            (set sl$Req)"
    , "            ( (as const (set sl$Req))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$G@Close r)) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (=> (finite@@sl$G r) (<= 0 (card@@sl$G r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$G r)) ))))"
    , "(assert (forall ( (r (set sl$Req)) )"
    , "                (! (=> (finite@@sl$Req r) (<= 0 (card@@sl$Req r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Req r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$G)) )"
    , "                (! (= (= (card@@sl$G r) 0) (= r empty-set@@sl$G))"
    , "                   :pattern"
    , "                   ( (card@@sl$G r) ))))"
    , "(assert (forall ( (r (set sl$Req)) )"
    , "                (! (= (= (card@@sl$Req r) 0) (= r empty-set@@sl$Req))"
    , "                   :pattern"
    , "                   ( (card@@sl$Req r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$Req) )"
    , "                (! (= (card@@sl$Req (mk-set@@sl$Req x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Req (mk-set@@sl$Req x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$G@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$G)) )"
    , "                              (and true (= r (mk-set@Open@@pfun@@Int@@sl$G@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close r) ))))"
    , "(assert (forall ( (r (set sl$Req)) )"
    , "                (! (= (= (card@@sl$Req r) 1)"
    , "                      (exists ( (x sl$Req) ) (and true (= r (mk-set@@sl$Req x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Req r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$G)))"
    , "                  (r0 (set (pfun Int sl$G))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$G@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$G@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$G@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$G@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$G@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$G))"
    , "                  (r0 (set sl$G)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$G)"
    , "                       (= (card@@sl$G (union r r0))"
    , "                          (+ (card@@sl$G r) (card@@sl$G r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$G (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Req))"
    , "                  (r0 (set sl$Req)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Req)"
    , "                       (= (card@@sl$Req (union r r0))"
    , "                          (+ (card@@sl$Req r) (card@@sl$Req r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Req (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@Int))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G f1 empty-fun@@Int@@sl$G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G)) )"
    , "                (! (= (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$G empty-fun@@Int@@sl$G f1) ))))"
    , "(assert (forall ( (s2 (set sl$G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                     (tfun@@Int@@sl$G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close empty-fun@@Int@@sl$G"
    , "                                                       (tfun@@Int@@sl$G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (f2 (pfun Int sl$G)) )"
    , "                (! (= (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2))"
    , "                      (union (dom@@Int@@sl$G f1) (dom@@Int@@sl$G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (ovl@@Int@@sl$G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-rest@@Int@@sl$G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$G (dom-subt@@Int@@sl$G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl$G empty-fun@@Int@@sl$G)"
    , "           empty-set@@sl$G))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$G f1))"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (tfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$G f1) s1)"
    , "                           (subset (ran@@Int@@sl$G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close f1 (pfun@@Int@@sl$G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl$G empty-fun@@Int@@sl$G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G))"
    , "                  (y (pfun Int sl$G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$G@Close x (mk-set@Open@@pfun@@Int@@sl$G@Close y)) ))))"
    , "(assert (forall ( (x sl$Req)"
    , "                  (y sl$Req) )"
    , "                (! (= (elem@@sl$Req x (mk-set@@sl$Req y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Req x (mk-set@@sl$Req y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (set-diff@Open@@pfun@@Int@@sl$G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (finite@@sl$G s1)"
    , "                       (finite@@sl$G (set-diff@@sl$G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (set-diff@@sl$G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Req))"
    , "                  (s2 (set sl$Req)) )"
    , "                (! (=> (finite@@sl$Req s1)"
    , "                       (finite@@sl$Req (set-diff@@sl$Req s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Req (set-diff@@sl$Req s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (and (finite@@sl$G s1) (finite@@sl$G s2))"
    , "                       (finite@@sl$G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Req))"
    , "                  (s2 (set sl$Req)) )"
    , "                (! (=> (and (finite@@sl$Req s1) (finite@@sl$Req s2))"
    , "                       (finite@@sl$Req (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Req (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close (mk-set@Open@@pfun@@Int@@sl$G@Close x)) ))))"
    , "(assert (forall ( (x sl$Req) )"
    , "                (! (finite@@sl$Req (mk-set@@sl$Req x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Req (mk-set@@sl$Req x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$G@Close empty-set@Open@@pfun@@Int@@sl$G@Close))"
    , "(assert (finite@@sl$G empty-set@@sl$G))"
    , "(assert (finite@@sl$Req empty-set@@sl$Req))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$G)))"
    , "                  (s2 (set (pfun Int sl$G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl$G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl$G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl$G))"
    , "                  (s2 (set sl$G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$G s2) (finite@@sl$G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$G s2)"
    , "                     (finite@@sl$G s1) ))))"
    , "(assert (forall ( (s1 (set sl$Req))"
    , "                  (s2 (set sl$Req)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$Req s2) (finite@@sl$Req s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Req s2)"
    , "                     (finite@@sl$Req s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (elem@@sl$Req r ppL))"
    , "; m0:sch0"
    , "(assert (elem@@sl$Req r ppL))"
    , "; m1:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$G@Close qe (tfun@@Int@@sl$G (intervalR p q) sl$G)))"
    , "; m1:inv1"
    , "(assert (<= p q))"
    , "(assert (not (= (or (= p q) (not (= p q))) true)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/resp:pop:left/F_SCH/replace/eqv"
    ]

path20 :: FilePath
path20 = "Tests/lock-free deque/main9.tex"

result20 :: String
result20 = unlines
    [ "  o  m0/INIT/FIS/req"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/LIVE/prog0/ensure/SAF/WD/lhs"
    , "  o  m0/LIVE/prog0/ensure/SAF/WD/rhs"
    , "  o  m0/LIVE/prog0/ensure/TR/WD"
    , "  o  m0/LIVE/prog0/ensure/TR/handle/EN"
    , "  o  m0/LIVE/prog0/ensure/TR/handle/NEG"
    , "  o  m0/LIVE/prog1/ensure/SAF/WD/lhs"
    , "  o  m0/LIVE/prog1/ensure/SAF/WD/rhs"
    , "  o  m0/LIVE/prog1/ensure/TR/WD"
    , "  o  m0/LIVE/prog1/ensure/TR/handle/EN"
    , "  o  m0/LIVE/prog1/ensure/TR/handle/NEG"
    , "  o  m0/SKIP/CO/co0"
    , "  o  m0/co0/CO/WD"
    , "  o  m0/handle/CO/co0"
    , "  o  m0/handle/FIS/req@prime"
    , "  o  m0/handle/FIS/req_0@prime"
    , "  o  m0/handle/SAF/LIVE/prog0/ensure"
    , "  o  m0/handle/SAF/LIVE/prog1/ensure"
    , "  o  m0/handle/SCH"
    , "  o  m0/handle/SCH/r"
    , "  o  m0/handle/WD/ACT/act0"
    , "  o  m0/handle/WD/ACT/act1"
    , "  o  m0/handle/WD/C_SCH"
    , "  o  m0/handle/WD/F_SCH"
    , "  o  m0/handle/WD/GRD"
    , "  o  m0/handle/WWD"
    , "  o  m0/prog0/PROG/WD/lhs"
    , "  o  m0/prog0/PROG/WD/rhs"
    , "  o  m0/prog1/PROG/WD/lhs"
    , "  o  m0/prog1/PROG/WD/rhs"
    , "  o  m0/req/CO/co0"
    , "  o  m0/req/FIS/req@prime"
    , "  o  m0/req/FIS/req_0@prime"
    , "  o  m0/req/SAF/LIVE/prog0/ensure"
    , "  o  m0/req/SAF/LIVE/prog1/ensure"
    , "  o  m0/req/SCH/r"
    , "  o  m0/req/WD/ACT/act0"
    , "  o  m0/req/WD/ACT/act1"
    , "  o  m0/req/WD/C_SCH"
    , "  o  m0/req/WD/F_SCH"
    , "  o  m0/req/WD/GRD"
    , "  o  m0/req/WWD"
    , "passed 45 / 45"
    ]

case20 :: IO POResult
case20 = verify path20 0

result21 :: Either [Error] (Table Name Witness)
result21 = Right $ symbol_table' witVar [(WitSuch b $ c [expr| b = ch |])]
    where
        b = z3Var "b" bool
        c = ctx $ do
            [var| b,ch : \Bool |]

case21 :: IO (Either [Error] (Table Name Witness))
case21 = runEitherT $ do
    m <- parse_machine' path20 1
    view ind_witness <$> S.lookup "handle" (m!.events.to leftMap)

result23 :: String
result23 = unlines
    [ "; m1/handle/C_SCH/delay/0/prog/m1:prog1/lhs"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const ch Bool)"
    , "(declare-const ch@prime Bool)"
    , "(declare-const req (set sl$REQ))"
    , "(declare-const req@prime (set sl$REQ))"
    , "(declare-const req_0 (set sl$REQ))"
    , "(declare-const req_0@prime (set sl$REQ))"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$REQ s2) (finite@@sl$REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ s2)"
    , "                     (finite@@sl$REQ s1) ))))"
    , "; b"
    , "(assert (= b ch))"
    , "; m0:sch0"
    , "(assert (not (= req empty-set@@sl$REQ)))"
    , "(assert (not (= b ch)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/handle/C_SCH/delay/0/prog/m1:prog1/lhs"
    ]

case23 :: IO String
case23 = proof_obligation path20 "m1/handle/C_SCH/delay/0/prog/m1:prog1/lhs" 1

result22 :: String
result22 = unlines
    [ "; m1/handle/C_SCH/delay/0/prog/m1:prog1/rhs/m1:sch0"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const ch Bool)"
    , "(declare-const ch@prime Bool)"
    , "(declare-const req (set sl$REQ))"
    , "(declare-const req@prime (set sl$REQ))"
    , "(declare-const req_0 (set sl$REQ))"
    , "(declare-const req_0@prime (set sl$REQ))"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$REQ s2) (finite@@sl$REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ s2)"
    , "                     (finite@@sl$REQ s1) ))))"
    , "(assert (not (=> (= b ch) (= b ch))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/handle/C_SCH/delay/0/prog/m1:prog1/rhs/m1:sch0"
    ]

case22 :: IO String
case22 = proof_obligation path20 "m1/handle/C_SCH/delay/0/prog/m1:prog1/rhs/m1:sch0" 1

path24 :: FilePath
path24 = "Tests/lock-free deque/main10.tex"

case24 :: IO POResult
case24 = verify path24 1

result24 :: String
result24 = unlines
    [ "  o  m1/INIT/WD"
    , "  o  m1/INIT/WWD"
    , "  o  m1/INV/WD"
    , "  o  m1/add/FIS/req@prime"
    , "  o  m1/add/FIS/ver@prime"
    , "  o  m1/add/IWWD/add"
    , "  o  m1/add/WD/C_SCH"
    , "  o  m1/add/WD/F_SCH"
    , "  o  m1/add/WD/GRD"
    , "  o  m1/add/WWD"
    , "  o  m1/handle/C_SCH/weaken/m1:sch0"
    , " xxx m1/handle/C_SCH/weaken/m1:sch1"
    , "  o  m1/handle/FIS/req@prime"
    , "  o  m1/handle/FIS/ver@prime"
    , "  o  m1/handle/GRD/str/m0:grd0"
    , "  o  m1/handle/GRD/str/m0:sch0"
    , "  o  m1/handle/IWFIS/r"
    , " xxx m1/handle/IWFIS/v"
    , " xxx m1/handle/IWWD/handle"
    , "  o  m1/handle/WD/C_SCH"
    , "  o  m1/handle/WD/F_SCH"
    , "  o  m1/handle/WD/GRD"
    , "  o  m1/handle/WWD"
    , "passed 20 / 23"
    ]

path25 :: FilePath
path25 = "Tests/lock-free deque/main11.tex"

case25 :: IO POResult
case25 = verify path25 2

result25 :: String
result25 = unlines
    [ "  o  m2/INIT/FIS/req"
    , "  o  m2/INIT/FIS/ver"
    , "  o  m2/INIT/WD"
    , "  o  m2/INIT/WWD"
    , "  o  m2/INV/WD"
    , "  o  m2/add/FIS/req@prime"
    , "  o  m2/add/FIS/ver@prime"
    , "  o  m2/add/IWWD/add"
    , "  o  m2/add/WD/C_SCH"
    , "  o  m2/add/WD/F_SCH"
    , "  o  m2/add/WD/GRD"
    , "  o  m2/add/WWD"
    , "  o  m2/handle/FIS/req@prime"
    , "  o  m2/handle/FIS/ver@prime"
    , "  o  m2/handle/IWWD/handle"
    , "  o  m2/handle/WD/C_SCH"
    , "  o  m2/handle/WD/F_SCH"
    , "  o  m2/handle/WD/GRD"
    , "  o  m2/handle/WWD"
    , "passed 19 / 19"
    ]

path26 :: FilePath
path26 = "Tests/lock-free deque/main12.tex"

case26 :: IO POResult
case26 = verify path26 3

result26 :: String
result26 = unlines
    [ "  o  m3/INIT/FIS/p"
    , "  o  m3/INIT/FIS/popL"
    , "  o  m3/INIT/FIS/popR"
    , "  o  m3/INIT/FIS/ppd"
    , "  o  m3/INIT/FIS/pshL"
    , "  o  m3/INIT/FIS/pshR"
    , "  o  m3/INIT/FIS/q"
    , "  o  m3/INIT/FIS/qe"
    , "  o  m3/INIT/FIS/res"
    , "  o  m3/INIT/FIS/ver"
    , "  o  m3/INIT/INV/m3:inv0"
    , "  o  m3/INIT/INV/m3:inv1"
    , "  o  m3/INIT/INV/m3:inv2"
    , "  o  m3/INIT/WD"
    , "  o  m3/INIT/WWD"
    , "  o  m3/INV/WD"
    , "  o  m3/add:popL/FIS/emp@prime"
    , "  o  m3/add:popL/FIS/p@prime"
    , "  o  m3/add:popL/FIS/popL@prime"
    , "  o  m3/add:popL/FIS/popR@prime"
    , "  o  m3/add:popL/FIS/ppd@prime"
    , "  o  m3/add:popL/FIS/pshL@prime"
    , "  o  m3/add:popL/FIS/pshR@prime"
    , "  o  m3/add:popL/FIS/q@prime"
    , "  o  m3/add:popL/FIS/qe@prime"
    , "  o  m3/add:popL/FIS/res@prime"
    , "  o  m3/add:popL/FIS/result@prime"
    , "  o  m3/add:popL/FIS/ver@prime"
    , "  o  m3/add:popL/INV/m3:inv0"
    , "  o  m3/add:popL/INV/m3:inv1"
    , "  o  m3/add:popL/INV/m3:inv2"
    , "  o  m3/add:popL/IWWD/add:popL"
    , "  o  m3/add:popL/WD/C_SCH"
    , "  o  m3/add:popL/WD/F_SCH"
    , "  o  m3/add:popL/WD/GRD"
    , "  o  m3/add:popL/WWD"
    , "  o  m3/add:popR/FIS/emp@prime"
    , "  o  m3/add:popR/FIS/p@prime"
    , "  o  m3/add:popR/FIS/popL@prime"
    , "  o  m3/add:popR/FIS/popR@prime"
    , "  o  m3/add:popR/FIS/ppd@prime"
    , "  o  m3/add:popR/FIS/pshL@prime"
    , "  o  m3/add:popR/FIS/pshR@prime"
    , "  o  m3/add:popR/FIS/q@prime"
    , "  o  m3/add:popR/FIS/qe@prime"
    , "  o  m3/add:popR/FIS/res@prime"
    , "  o  m3/add:popR/FIS/result@prime"
    , "  o  m3/add:popR/FIS/ver@prime"
    , "  o  m3/add:popR/INV/m3:inv0"
    , "  o  m3/add:popR/INV/m3:inv1"
    , "  o  m3/add:popR/INV/m3:inv2"
    , "  o  m3/add:popR/IWWD/add:popR"
    , "  o  m3/add:popR/WD/C_SCH"
    , "  o  m3/add:popR/WD/F_SCH"
    , "  o  m3/add:popR/WD/GRD"
    , "  o  m3/add:popR/WWD"
    , "  o  m3/add:pushL/FIS/emp@prime"
    , "  o  m3/add:pushL/FIS/p@prime"
    , "  o  m3/add:pushL/FIS/popL@prime"
    , "  o  m3/add:pushL/FIS/popR@prime"
    , "  o  m3/add:pushL/FIS/ppd@prime"
    , "  o  m3/add:pushL/FIS/pshL@prime"
    , "  o  m3/add:pushL/FIS/pshR@prime"
    , "  o  m3/add:pushL/FIS/q@prime"
    , "  o  m3/add:pushL/FIS/qe@prime"
    , "  o  m3/add:pushL/FIS/res@prime"
    , "  o  m3/add:pushL/FIS/result@prime"
    , "  o  m3/add:pushL/FIS/ver@prime"
    , "  o  m3/add:pushL/INV/m3:inv0"
    , "  o  m3/add:pushL/INV/m3:inv1"
    , "  o  m3/add:pushL/INV/m3:inv2"
    , "  o  m3/add:pushL/IWWD/add:pushL"
    , "  o  m3/add:pushL/WD/C_SCH"
    , "  o  m3/add:pushL/WD/F_SCH"
    , "  o  m3/add:pushL/WD/GRD"
    , "  o  m3/add:pushL/WWD"
    , "  o  m3/add:pushR/FIS/emp@prime"
    , "  o  m3/add:pushR/FIS/p@prime"
    , "  o  m3/add:pushR/FIS/popL@prime"
    , "  o  m3/add:pushR/FIS/popR@prime"
    , "  o  m3/add:pushR/FIS/ppd@prime"
    , "  o  m3/add:pushR/FIS/pshL@prime"
    , "  o  m3/add:pushR/FIS/pshR@prime"
    , "  o  m3/add:pushR/FIS/q@prime"
    , "  o  m3/add:pushR/FIS/qe@prime"
    , "  o  m3/add:pushR/FIS/res@prime"
    , "  o  m3/add:pushR/FIS/result@prime"
    , "  o  m3/add:pushR/FIS/ver@prime"
    , "  o  m3/add:pushR/INV/m3:inv0"
    , "  o  m3/add:pushR/INV/m3:inv1"
    , "  o  m3/add:pushR/INV/m3:inv2"
    , "  o  m3/add:pushR/IWWD/add:pushR"
    , "  o  m3/add:pushR/WD/C_SCH"
    , "  o  m3/add:pushR/WD/F_SCH"
    , "  o  m3/add:pushR/WD/GRD"
    , "  o  m3/add:pushR/WWD"
    , "  o  m3/handle:popL/C_SCH/delay/0/prog/m3:prog0/lhs"
    , "  o  m3/handle:popL/C_SCH/delay/0/prog/m3:prog0/rhs/split"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:popL/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:popL/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:popR/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:popR/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:pushL/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:pushL/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:pushR/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/add:pushR/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popL:empty/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popL:empty/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popL:non:empty/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popL:non:empty/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popR:empty/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popR:empty/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popR:non:empty/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:popR:non:empty/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:pushL/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:pushL/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:pushR/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/handle:pushR/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/return/SAF/handle:popL:empty"
    , "  o  m3/handle:popL/C_SCH/delay/0/saf/return/SAF/handle:popL:non:empty"
    , "  o  m3/handle:popL/C_SCH/weaken"
    , "  o  m3/handle:popL/F_SCH/replace/eqv"
    , "  o  m3/handle:popL/IWWD/handle:popL:empty"
    , "  o  m3/handle:popL/IWWD/handle:popL:non:empty"
    , "  o  m3/handle:popL:empty/FIS/emp@prime"
    , "  o  m3/handle:popL:empty/FIS/p@prime"
    , "  o  m3/handle:popL:empty/FIS/popL@prime"
    , "  o  m3/handle:popL:empty/FIS/popR@prime"
    , "  o  m3/handle:popL:empty/FIS/ppd@prime"
    , "  o  m3/handle:popL:empty/FIS/pshL@prime"
    , "  o  m3/handle:popL:empty/FIS/pshR@prime"
    , "  o  m3/handle:popL:empty/FIS/q@prime"
    , "  o  m3/handle:popL:empty/FIS/qe@prime"
    , "  o  m3/handle:popL:empty/FIS/res@prime"
    , "  o  m3/handle:popL:empty/FIS/result@prime"
    , "  o  m3/handle:popL:empty/FIS/ver@prime"
    , "  o  m3/handle:popL:empty/INV/m3:inv0"
    , "  o  m3/handle:popL:empty/INV/m3:inv1"
    , "  o  m3/handle:popL:empty/INV/m3:inv2"
    , "  o  m3/handle:popL:empty/WD/C_SCH"
    , "  o  m3/handle:popL:empty/WD/F_SCH"
    , "  o  m3/handle:popL:empty/WD/GRD"
    , "  o  m3/handle:popL:empty/WWD"
    , "  o  m3/handle:popL:non:empty/FIS/emp@prime"
    , "  o  m3/handle:popL:non:empty/FIS/p@prime"
    , "  o  m3/handle:popL:non:empty/FIS/popL@prime"
    , "  o  m3/handle:popL:non:empty/FIS/popR@prime"
    , "  o  m3/handle:popL:non:empty/FIS/ppd@prime"
    , "  o  m3/handle:popL:non:empty/FIS/pshL@prime"
    , "  o  m3/handle:popL:non:empty/FIS/pshR@prime"
    , "  o  m3/handle:popL:non:empty/FIS/q@prime"
    , "  o  m3/handle:popL:non:empty/FIS/qe@prime"
    , "  o  m3/handle:popL:non:empty/FIS/res@prime"
    , "  o  m3/handle:popL:non:empty/FIS/result@prime"
    , "  o  m3/handle:popL:non:empty/FIS/ver@prime"
    , "  o  m3/handle:popL:non:empty/INV/m3:inv0"
    , "  o  m3/handle:popL:non:empty/INV/m3:inv1"
    , "  o  m3/handle:popL:non:empty/INV/m3:inv2"
    , "  o  m3/handle:popL:non:empty/WD/ACT/m3:act0"
    , "  o  m3/handle:popL:non:empty/WD/ACT/m3:act1"
    , "  o  m3/handle:popL:non:empty/WD/ACT/m3:act2"
    , "  o  m3/handle:popL:non:empty/WD/C_SCH"
    , "  o  m3/handle:popL:non:empty/WD/F_SCH"
    , "  o  m3/handle:popL:non:empty/WD/GRD"
    , "  o  m3/handle:popL:non:empty/WWD"
    , "  o  m3/handle:popR/C_SCH/delay/0/prog/m3:prog0/lhs"
    , "  o  m3/handle:popR/C_SCH/delay/0/prog/m3:prog0/rhs/split"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:popL/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:popL/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:popR/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:popR/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:pushL/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:pushL/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:pushR/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/add:pushR/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popL:empty/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popL:empty/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popL:non:empty/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popL:non:empty/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popR:empty/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popR:empty/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popR:non:empty/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:popR:non:empty/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:pushL/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:pushL/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:pushR/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/handle:pushR/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/return/SAF/handle:popR:empty"
    , "  o  m3/handle:popR/C_SCH/delay/0/saf/return/SAF/handle:popR:non:empty"
    , "  o  m3/handle:popR/C_SCH/weaken"
    , "  o  m3/handle:popR/F_SCH/replace/eqv"
    , "  o  m3/handle:popR/IWWD/handle:popR:empty"
    , "  o  m3/handle:popR/IWWD/handle:popR:non:empty"
    , "  o  m3/handle:popR:empty/FIS/emp@prime"
    , "  o  m3/handle:popR:empty/FIS/p@prime"
    , "  o  m3/handle:popR:empty/FIS/popL@prime"
    , "  o  m3/handle:popR:empty/FIS/popR@prime"
    , "  o  m3/handle:popR:empty/FIS/ppd@prime"
    , "  o  m3/handle:popR:empty/FIS/pshL@prime"
    , "  o  m3/handle:popR:empty/FIS/pshR@prime"
    , "  o  m3/handle:popR:empty/FIS/q@prime"
    , "  o  m3/handle:popR:empty/FIS/qe@prime"
    , "  o  m3/handle:popR:empty/FIS/res@prime"
    , "  o  m3/handle:popR:empty/FIS/result@prime"
    , "  o  m3/handle:popR:empty/FIS/ver@prime"
    , "  o  m3/handle:popR:empty/INV/m3:inv0"
    , "  o  m3/handle:popR:empty/INV/m3:inv1"
    , "  o  m3/handle:popR:empty/INV/m3:inv2"
    , "  o  m3/handle:popR:empty/WD/C_SCH"
    , "  o  m3/handle:popR:empty/WD/F_SCH"
    , "  o  m3/handle:popR:empty/WD/GRD"
    , "  o  m3/handle:popR:empty/WWD"
    , "  o  m3/handle:popR:non:empty/FIS/emp@prime"
    , "  o  m3/handle:popR:non:empty/FIS/p@prime"
    , "  o  m3/handle:popR:non:empty/FIS/popL@prime"
    , "  o  m3/handle:popR:non:empty/FIS/popR@prime"
    , "  o  m3/handle:popR:non:empty/FIS/ppd@prime"
    , "  o  m3/handle:popR:non:empty/FIS/pshL@prime"
    , "  o  m3/handle:popR:non:empty/FIS/pshR@prime"
    , "  o  m3/handle:popR:non:empty/FIS/q@prime"
    , "  o  m3/handle:popR:non:empty/FIS/qe@prime"
    , "  o  m3/handle:popR:non:empty/FIS/res@prime"
    , "  o  m3/handle:popR:non:empty/FIS/result@prime"
    , "  o  m3/handle:popR:non:empty/FIS/ver@prime"
    , "  o  m3/handle:popR:non:empty/INV/m3:inv0"
    , "  o  m3/handle:popR:non:empty/INV/m3:inv1"
    , "  o  m3/handle:popR:non:empty/INV/m3:inv2"
    , "  o  m3/handle:popR:non:empty/WD/ACT/m3:act0"
    , "  o  m3/handle:popR:non:empty/WD/ACT/m3:act1"
    , "  o  m3/handle:popR:non:empty/WD/ACT/m3:act2"
    , "  o  m3/handle:popR:non:empty/WD/C_SCH"
    , "  o  m3/handle:popR:non:empty/WD/F_SCH"
    , "  o  m3/handle:popR:non:empty/WD/GRD"
    , "  o  m3/handle:popR:non:empty/WWD"
    , "  o  m3/handle:pushL/FIS/emp@prime"
    , "  o  m3/handle:pushL/FIS/p@prime"
    , "  o  m3/handle:pushL/FIS/popL@prime"
    , "  o  m3/handle:pushL/FIS/popR@prime"
    , "  o  m3/handle:pushL/FIS/ppd@prime"
    , "  o  m3/handle:pushL/FIS/pshL@prime"
    , "  o  m3/handle:pushL/FIS/pshR@prime"
    , "  o  m3/handle:pushL/FIS/q@prime"
    , "  o  m3/handle:pushL/FIS/qe@prime"
    , "  o  m3/handle:pushL/FIS/res@prime"
    , "  o  m3/handle:pushL/FIS/result@prime"
    , "  o  m3/handle:pushL/FIS/ver@prime"
    , "  o  m3/handle:pushL/INV/m3:inv0"
    , "  o  m3/handle:pushL/INV/m3:inv1"
    , "  o  m3/handle:pushL/INV/m3:inv2"
    , "  o  m3/handle:pushL/IWWD/handle:pushL"
    , "  o  m3/handle:pushL/WD/ACT/m3:act0"
    , "  o  m3/handle:pushL/WD/ACT/m3:act1"
    , "  o  m3/handle:pushL/WD/C_SCH"
    , "  o  m3/handle:pushL/WD/F_SCH"
    , "  o  m3/handle:pushL/WD/GRD"
    , "  o  m3/handle:pushL/WWD"
    , "  o  m3/handle:pushR/FIS/emp@prime"
    , "  o  m3/handle:pushR/FIS/p@prime"
    , "  o  m3/handle:pushR/FIS/popL@prime"
    , "  o  m3/handle:pushR/FIS/popR@prime"
    , "  o  m3/handle:pushR/FIS/ppd@prime"
    , "  o  m3/handle:pushR/FIS/pshL@prime"
    , "  o  m3/handle:pushR/FIS/pshR@prime"
    , "  o  m3/handle:pushR/FIS/q@prime"
    , "  o  m3/handle:pushR/FIS/qe@prime"
    , "  o  m3/handle:pushR/FIS/res@prime"
    , "  o  m3/handle:pushR/FIS/result@prime"
    , "  o  m3/handle:pushR/FIS/ver@prime"
    , "  o  m3/handle:pushR/INV/m3:inv0"
    , "  o  m3/handle:pushR/INV/m3:inv1"
    , "  o  m3/handle:pushR/INV/m3:inv2"
    , "  o  m3/handle:pushR/IWWD/handle:pushR"
    , "  o  m3/handle:pushR/WD/ACT/m3:act0"
    , "  o  m3/handle:pushR/WD/ACT/m3:act1"
    , "  o  m3/handle:pushR/WD/C_SCH"
    , "  o  m3/handle:pushR/WD/F_SCH"
    , "  o  m3/handle:pushR/WD/GRD"
    , "  o  m3/handle:pushR/WWD"
    , "  o  m3/m3:prog0/LIVE/implication"
    , "  o  m3/m3:prog0/PROG/WD/lhs"
    , "  o  m3/m3:prog0/PROG/WD/rhs"
    , "  o  m3/return/FIS/emp@prime"
    , "  o  m3/return/FIS/p@prime"
    , "  o  m3/return/FIS/popL@prime"
    , "  o  m3/return/FIS/popR@prime"
    , "  o  m3/return/FIS/ppd@prime"
    , "  o  m3/return/FIS/pshL@prime"
    , "  o  m3/return/FIS/pshR@prime"
    , "  o  m3/return/FIS/q@prime"
    , "  o  m3/return/FIS/qe@prime"
    , "  o  m3/return/FIS/res@prime"
    , "  o  m3/return/FIS/result@prime"
    , "  o  m3/return/FIS/ver@prime"
    , "  o  m3/return/INV/m3:inv0"
    , "  o  m3/return/INV/m3:inv1"
    , "  o  m3/return/INV/m3:inv2"
    , "  o  m3/return/IWWD/return"
    , "  o  m3/return/WD/ACT/m3:act0"
    , "  o  m3/return/WD/ACT/m3:act1"
    , "  o  m3/return/WD/ACT/m3:act2"
    , "  o  m3/return/WD/C_SCH"
    , "  o  m3/return/WD/F_SCH"
    , "  o  m3/return/WD/GRD"
    , "  o  m3/return/WWD"
    , "passed 304 / 304"
    ]

path27 :: FilePath
path27 = "Tests/lock-free deque/main13.tex"

case27 :: IO POResult
case27 = verifyWith (timeout .= 5000 >> resource .= 2) path27 5

result27 :: String
result27 = unlines
    [ "  o  m5/INIT/FIS/LH"
    , "  o  m5/INIT/FIS/RH"
    , "  o  m5/INIT/FIS/insL"
    , "  o  m5/INIT/FIS/insR"
    , "  o  m5/INIT/FIS/item"
    , "  o  m5/INIT/FIS/left"
    , "  o  m5/INIT/FIS/nL"
    , "  o  m5/INIT/FIS/nR"
    , "  o  m5/INIT/FIS/node"
    , "  o  m5/INIT/FIS/p"
    , "  o  m5/INIT/FIS/popL"
    , "  o  m5/INIT/FIS/popR"
    , "  o  m5/INIT/FIS/ppd"
    , "  o  m5/INIT/FIS/pshL"
    , "  o  m5/INIT/FIS/pshR"
    , "  o  m5/INIT/FIS/q"
    , "  o  m5/INIT/FIS/qe"
    , "  o  m5/INIT/FIS/rep"
    , "  o  m5/INIT/FIS/res"
    , "  o  m5/INIT/FIS/right"
    , "  o  m5/INIT/FIS/ver"
    , "  o  m5/INIT/INV/m5:inv0"
    , "  o  m5/INIT/INV/m5:inv1"
    , "  o  m5/INIT/INV/m5:inv2"
    , "  o  m5/INIT/INV/m5:inv3"
    , "  o  m5/INIT/INV/m5:inv4"
    , "  o  m5/INIT/INV/m5:inv5"
    , "  o  m5/INIT/INV/m5:inv6"
    , "  o  m5/INIT/INV/m5:inv7"
    , "  o  m5/INIT/INV/m5:inv8"
    , "  o  m5/INIT/INV/m5:inv9"
    , "  o  m5/INIT/WD"
    , "  o  m5/INIT/WWD"
    , "  o  m5/INV/WD"
    , "  o  m5/add:popL/FIS/LH@prime"
    , "  o  m5/add:popL/FIS/RH@prime"
    , "  o  m5/add:popL/FIS/emp@prime"
    , "  o  m5/add:popL/FIS/insL@prime"
    , "  o  m5/add:popL/FIS/insR@prime"
    , "  o  m5/add:popL/FIS/item@prime"
    , "  o  m5/add:popL/FIS/left@prime"
    , "  o  m5/add:popL/FIS/nL@prime"
    , "  o  m5/add:popL/FIS/nR@prime"
    , "  o  m5/add:popL/FIS/new@prime"
    , "  o  m5/add:popL/FIS/node@prime"
    , "  o  m5/add:popL/FIS/p@prime"
    , "  o  m5/add:popL/FIS/popL@prime"
    , "  o  m5/add:popL/FIS/popR@prime"
    , "  o  m5/add:popL/FIS/ppd@prime"
    , "  o  m5/add:popL/FIS/pshL@prime"
    , "  o  m5/add:popL/FIS/pshR@prime"
    , "  o  m5/add:popL/FIS/q@prime"
    , "  o  m5/add:popL/FIS/qe@prime"
    , "  o  m5/add:popL/FIS/rep@prime"
    , "  o  m5/add:popL/FIS/res@prime"
    , "  o  m5/add:popL/FIS/result@prime"
    , "  o  m5/add:popL/FIS/right@prime"
    , "  o  m5/add:popL/FIS/ver@prime"
    , "  o  m5/add:popL/INV/m5:inv0"
    , "  o  m5/add:popL/INV/m5:inv1"
    , "  o  m5/add:popL/INV/m5:inv2"
    , "  o  m5/add:popL/INV/m5:inv3"
    , "  o  m5/add:popL/INV/m5:inv4"
    , "  o  m5/add:popL/INV/m5:inv5"
    , "  o  m5/add:popL/INV/m5:inv6"
    , "  o  m5/add:popL/INV/m5:inv7"
    , "  o  m5/add:popL/INV/m5:inv8"
    , "  o  m5/add:popL/INV/m5:inv9"
    , "  o  m5/add:popL/IWWD/add:popL"
    , "  o  m5/add:popL/WD/C_SCH"
    , "  o  m5/add:popL/WD/F_SCH"
    , "  o  m5/add:popL/WD/GRD"
    , "  o  m5/add:popL/WWD"
    , "  o  m5/add:popR/FIS/LH@prime"
    , "  o  m5/add:popR/FIS/RH@prime"
    , "  o  m5/add:popR/FIS/emp@prime"
    , "  o  m5/add:popR/FIS/insL@prime"
    , "  o  m5/add:popR/FIS/insR@prime"
    , "  o  m5/add:popR/FIS/item@prime"
    , "  o  m5/add:popR/FIS/left@prime"
    , "  o  m5/add:popR/FIS/nL@prime"
    , "  o  m5/add:popR/FIS/nR@prime"
    , "  o  m5/add:popR/FIS/new@prime"
    , "  o  m5/add:popR/FIS/node@prime"
    , "  o  m5/add:popR/FIS/p@prime"
    , "  o  m5/add:popR/FIS/popL@prime"
    , "  o  m5/add:popR/FIS/popR@prime"
    , "  o  m5/add:popR/FIS/ppd@prime"
    , "  o  m5/add:popR/FIS/pshL@prime"
    , "  o  m5/add:popR/FIS/pshR@prime"
    , "  o  m5/add:popR/FIS/q@prime"
    , "  o  m5/add:popR/FIS/qe@prime"
    , "  o  m5/add:popR/FIS/rep@prime"
    , "  o  m5/add:popR/FIS/res@prime"
    , "  o  m5/add:popR/FIS/result@prime"
    , "  o  m5/add:popR/FIS/right@prime"
    , "  o  m5/add:popR/FIS/ver@prime"
    , "  o  m5/add:popR/INV/m5:inv0"
    , "  o  m5/add:popR/INV/m5:inv1"
    , "  o  m5/add:popR/INV/m5:inv2"
    , "  o  m5/add:popR/INV/m5:inv3"
    , "  o  m5/add:popR/INV/m5:inv4"
    , "  o  m5/add:popR/INV/m5:inv5"
    , "  o  m5/add:popR/INV/m5:inv6"
    , "  o  m5/add:popR/INV/m5:inv7"
    , "  o  m5/add:popR/INV/m5:inv8"
    , "  o  m5/add:popR/INV/m5:inv9"
    , "  o  m5/add:popR/IWWD/add:popR"
    , "  o  m5/add:popR/WD/C_SCH"
    , "  o  m5/add:popR/WD/F_SCH"
    , "  o  m5/add:popR/WD/GRD"
    , "  o  m5/add:popR/WWD"
    , "  o  m5/add:pushL/FIS/LH@prime"
    , "  o  m5/add:pushL/FIS/RH@prime"
    , "  o  m5/add:pushL/FIS/emp@prime"
    , "  o  m5/add:pushL/FIS/insL@prime"
    , "  o  m5/add:pushL/FIS/insR@prime"
    , "  o  m5/add:pushL/FIS/item@prime"
    , "  o  m5/add:pushL/FIS/left@prime"
    , "  o  m5/add:pushL/FIS/nL@prime"
    , "  o  m5/add:pushL/FIS/nR@prime"
    , "  o  m5/add:pushL/FIS/new@prime"
    , "  o  m5/add:pushL/FIS/node@prime"
    , "  o  m5/add:pushL/FIS/p@prime"
    , "  o  m5/add:pushL/FIS/popL@prime"
    , "  o  m5/add:pushL/FIS/popR@prime"
    , "  o  m5/add:pushL/FIS/ppd@prime"
    , "  o  m5/add:pushL/FIS/pshL@prime"
    , "  o  m5/add:pushL/FIS/pshR@prime"
    , "  o  m5/add:pushL/FIS/q@prime"
    , "  o  m5/add:pushL/FIS/qe@prime"
    , "  o  m5/add:pushL/FIS/rep@prime"
    , "  o  m5/add:pushL/FIS/res@prime"
    , "  o  m5/add:pushL/FIS/result@prime"
    , "  o  m5/add:pushL/FIS/right@prime"
    , "  o  m5/add:pushL/FIS/ver@prime"
    , "  o  m5/add:pushL/INV/m5:inv0"
    , "  o  m5/add:pushL/INV/m5:inv1"
    , "  o  m5/add:pushL/INV/m5:inv2"
    , "  o  m5/add:pushL/INV/m5:inv3"
    , "  o  m5/add:pushL/INV/m5:inv4"
    , "  o  m5/add:pushL/INV/m5:inv5"
    , "  o  m5/add:pushL/INV/m5:inv6"
    , "  o  m5/add:pushL/INV/m5:inv7"
    , "  o  m5/add:pushL/INV/m5:inv8"
    , "  o  m5/add:pushL/INV/m5:inv9"
    , "  o  m5/add:pushL/IWWD/add:pushL"
    , "  o  m5/add:pushL/WD/C_SCH"
    , "  o  m5/add:pushL/WD/F_SCH"
    , "  o  m5/add:pushL/WD/GRD"
    , "  o  m5/add:pushL/WWD"
    , "  o  m5/add:pushR/FIS/LH@prime"
    , "  o  m5/add:pushR/FIS/RH@prime"
    , "  o  m5/add:pushR/FIS/emp@prime"
    , "  o  m5/add:pushR/FIS/insL@prime"
    , "  o  m5/add:pushR/FIS/insR@prime"
    , "  o  m5/add:pushR/FIS/item@prime"
    , "  o  m5/add:pushR/FIS/left@prime"
    , "  o  m5/add:pushR/FIS/nL@prime"
    , "  o  m5/add:pushR/FIS/nR@prime"
    , "  o  m5/add:pushR/FIS/new@prime"
    , "  o  m5/add:pushR/FIS/node@prime"
    , "  o  m5/add:pushR/FIS/p@prime"
    , "  o  m5/add:pushR/FIS/popL@prime"
    , "  o  m5/add:pushR/FIS/popR@prime"
    , "  o  m5/add:pushR/FIS/ppd@prime"
    , "  o  m5/add:pushR/FIS/pshL@prime"
    , "  o  m5/add:pushR/FIS/pshR@prime"
    , "  o  m5/add:pushR/FIS/q@prime"
    , "  o  m5/add:pushR/FIS/qe@prime"
    , "  o  m5/add:pushR/FIS/rep@prime"
    , "  o  m5/add:pushR/FIS/res@prime"
    , "  o  m5/add:pushR/FIS/result@prime"
    , "  o  m5/add:pushR/FIS/right@prime"
    , "  o  m5/add:pushR/FIS/ver@prime"
    , "  o  m5/add:pushR/INV/m5:inv0"
    , "  o  m5/add:pushR/INV/m5:inv1"
    , "  o  m5/add:pushR/INV/m5:inv2"
    , "  o  m5/add:pushR/INV/m5:inv3"
    , "  o  m5/add:pushR/INV/m5:inv4"
    , "  o  m5/add:pushR/INV/m5:inv5"
    , "  o  m5/add:pushR/INV/m5:inv6"
    , "  o  m5/add:pushR/INV/m5:inv7"
    , "  o  m5/add:pushR/INV/m5:inv8"
    , "  o  m5/add:pushR/INV/m5:inv9"
    , "  o  m5/add:pushR/IWWD/add:pushR"
    , "  o  m5/add:pushR/WD/C_SCH"
    , "  o  m5/add:pushR/WD/F_SCH"
    , "  o  m5/add:pushR/WD/GRD"
    , "  o  m5/add:pushR/WWD"
    , "  o  m5/allocateL/FIS/LH@prime"
    , "  o  m5/allocateL/FIS/RH@prime"
    , "  o  m5/allocateL/FIS/emp@prime"
    , "  o  m5/allocateL/FIS/insL@prime"
    , "  o  m5/allocateL/FIS/insR@prime"
    , "  o  m5/allocateL/FIS/item@prime"
    , "  o  m5/allocateL/FIS/left@prime"
    , "  o  m5/allocateL/FIS/nL@prime"
    , "  o  m5/allocateL/FIS/nR@prime"
    , "  o  m5/allocateL/FIS/new@prime"
    , "  o  m5/allocateL/FIS/node@prime"
    , "  o  m5/allocateL/FIS/p@prime"
    , "  o  m5/allocateL/FIS/popL@prime"
    , "  o  m5/allocateL/FIS/popR@prime"
    , "  o  m5/allocateL/FIS/ppd@prime"
    , "  o  m5/allocateL/FIS/pshL@prime"
    , "  o  m5/allocateL/FIS/pshR@prime"
    , "  o  m5/allocateL/FIS/q@prime"
    , "  o  m5/allocateL/FIS/qe@prime"
    , "  o  m5/allocateL/FIS/rep@prime"
    , "  o  m5/allocateL/FIS/res@prime"
    , "  o  m5/allocateL/FIS/result@prime"
    , "  o  m5/allocateL/FIS/right@prime"
    , "  o  m5/allocateL/FIS/ver@prime"
    , " xxx m5/allocateL/INV/m5:inv0"
    , " xxx m5/allocateL/INV/m5:inv1"
    , "  o  m5/allocateL/INV/m5:inv2"
    , "  o  m5/allocateL/INV/m5:inv3"
    , "  o  m5/allocateL/INV/m5:inv4"
    , "  o  m5/allocateL/INV/m5:inv5"
    , "  o  m5/allocateL/INV/m5:inv6"
    , "  o  m5/allocateL/INV/m5:inv7"
    , "  o  m5/allocateL/INV/m5:inv8"
    , "  o  m5/allocateL/INV/m5:inv9"
    , "  o  m5/allocateL/IWWD/allocateL"
    , "  o  m5/allocateL/WD/C_SCH"
    , "  o  m5/allocateL/WD/F_SCH"
    , "  o  m5/allocateL/WD/GRD"
    , "  o  m5/allocateL/WWD"
    , "  o  m5/allocateR/FIS/LH@prime"
    , "  o  m5/allocateR/FIS/RH@prime"
    , "  o  m5/allocateR/FIS/emp@prime"
    , "  o  m5/allocateR/FIS/insL@prime"
    , "  o  m5/allocateR/FIS/insR@prime"
    , "  o  m5/allocateR/FIS/item@prime"
    , "  o  m5/allocateR/FIS/left@prime"
    , "  o  m5/allocateR/FIS/nL@prime"
    , "  o  m5/allocateR/FIS/nR@prime"
    , "  o  m5/allocateR/FIS/new@prime"
    , "  o  m5/allocateR/FIS/node@prime"
    , "  o  m5/allocateR/FIS/p@prime"
    , "  o  m5/allocateR/FIS/popL@prime"
    , "  o  m5/allocateR/FIS/popR@prime"
    , "  o  m5/allocateR/FIS/ppd@prime"
    , "  o  m5/allocateR/FIS/pshL@prime"
    , "  o  m5/allocateR/FIS/pshR@prime"
    , "  o  m5/allocateR/FIS/q@prime"
    , "  o  m5/allocateR/FIS/qe@prime"
    , "  o  m5/allocateR/FIS/rep@prime"
    , "  o  m5/allocateR/FIS/res@prime"
    , "  o  m5/allocateR/FIS/result@prime"
    , "  o  m5/allocateR/FIS/right@prime"
    , "  o  m5/allocateR/FIS/ver@prime"
    , " xxx m5/allocateR/INV/m5:inv0"
    , " xxx m5/allocateR/INV/m5:inv1"
    , "  o  m5/allocateR/INV/m5:inv2"
    , "  o  m5/allocateR/INV/m5:inv3"
    , "  o  m5/allocateR/INV/m5:inv4"
    , "  o  m5/allocateR/INV/m5:inv5"
    , "  o  m5/allocateR/INV/m5:inv6"
    , "  o  m5/allocateR/INV/m5:inv7"
    , "  o  m5/allocateR/INV/m5:inv8"
    , "  o  m5/allocateR/INV/m5:inv9"
    , "  o  m5/allocateR/IWWD/allocateR"
    , "  o  m5/allocateR/WD/C_SCH"
    , "  o  m5/allocateR/WD/F_SCH"
    , "  o  m5/allocateR/WD/GRD"
    , "  o  m5/allocateR/WWD"
    , "  o  m5/handle:popL:empty/FIS/LH@prime"
    , "  o  m5/handle:popL:empty/FIS/RH@prime"
    , "  o  m5/handle:popL:empty/FIS/emp@prime"
    , "  o  m5/handle:popL:empty/FIS/insL@prime"
    , "  o  m5/handle:popL:empty/FIS/insR@prime"
    , "  o  m5/handle:popL:empty/FIS/item@prime"
    , "  o  m5/handle:popL:empty/FIS/left@prime"
    , "  o  m5/handle:popL:empty/FIS/nL@prime"
    , "  o  m5/handle:popL:empty/FIS/nR@prime"
    , "  o  m5/handle:popL:empty/FIS/new@prime"
    , "  o  m5/handle:popL:empty/FIS/node@prime"
    , "  o  m5/handle:popL:empty/FIS/p@prime"
    , "  o  m5/handle:popL:empty/FIS/popL@prime"
    , "  o  m5/handle:popL:empty/FIS/popR@prime"
    , "  o  m5/handle:popL:empty/FIS/ppd@prime"
    , "  o  m5/handle:popL:empty/FIS/pshL@prime"
    , "  o  m5/handle:popL:empty/FIS/pshR@prime"
    , "  o  m5/handle:popL:empty/FIS/q@prime"
    , "  o  m5/handle:popL:empty/FIS/qe@prime"
    , "  o  m5/handle:popL:empty/FIS/rep@prime"
    , "  o  m5/handle:popL:empty/FIS/res@prime"
    , "  o  m5/handle:popL:empty/FIS/result@prime"
    , "  o  m5/handle:popL:empty/FIS/right@prime"
    , "  o  m5/handle:popL:empty/FIS/ver@prime"
    , "  o  m5/handle:popL:empty/INV/m5:inv0"
    , "  o  m5/handle:popL:empty/INV/m5:inv1"
    , "  o  m5/handle:popL:empty/INV/m5:inv2"
    , "  o  m5/handle:popL:empty/INV/m5:inv3"
    , "  o  m5/handle:popL:empty/INV/m5:inv4"
    , "  o  m5/handle:popL:empty/INV/m5:inv5"
    , "  o  m5/handle:popL:empty/INV/m5:inv6"
    , "  o  m5/handle:popL:empty/INV/m5:inv7"
    , "  o  m5/handle:popL:empty/INV/m5:inv8"
    , "  o  m5/handle:popL:empty/INV/m5:inv9"
    , "  o  m5/handle:popL:empty/IWWD/handle:popL:empty"
    , "  o  m5/handle:popL:empty/WD/C_SCH"
    , "  o  m5/handle:popL:empty/WD/F_SCH"
    , "  o  m5/handle:popL:empty/WD/GRD"
    , "  o  m5/handle:popL:empty/WWD"
    , "  o  m5/handle:popL:non:empty/FIS/LH@prime"
    , "  o  m5/handle:popL:non:empty/FIS/RH@prime"
    , "  o  m5/handle:popL:non:empty/FIS/emp@prime"
    , "  o  m5/handle:popL:non:empty/FIS/insL@prime"
    , "  o  m5/handle:popL:non:empty/FIS/insR@prime"
    , "  o  m5/handle:popL:non:empty/FIS/item@prime"
    , "  o  m5/handle:popL:non:empty/FIS/left@prime"
    , "  o  m5/handle:popL:non:empty/FIS/nL@prime"
    , "  o  m5/handle:popL:non:empty/FIS/nR@prime"
    , "  o  m5/handle:popL:non:empty/FIS/new@prime"
    , "  o  m5/handle:popL:non:empty/FIS/node@prime"
    , "  o  m5/handle:popL:non:empty/FIS/p@prime"
    , "  o  m5/handle:popL:non:empty/FIS/popL@prime"
    , "  o  m5/handle:popL:non:empty/FIS/popR@prime"
    , "  o  m5/handle:popL:non:empty/FIS/ppd@prime"
    , "  o  m5/handle:popL:non:empty/FIS/pshL@prime"
    , "  o  m5/handle:popL:non:empty/FIS/pshR@prime"
    , "  o  m5/handle:popL:non:empty/FIS/q@prime"
    , "  o  m5/handle:popL:non:empty/FIS/qe@prime"
    , "  o  m5/handle:popL:non:empty/FIS/rep@prime"
    , "  o  m5/handle:popL:non:empty/FIS/res@prime"
    , "  o  m5/handle:popL:non:empty/FIS/result@prime"
    , "  o  m5/handle:popL:non:empty/FIS/right@prime"
    , "  o  m5/handle:popL:non:empty/FIS/ver@prime"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv0"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv1"
    , " xxx m5/handle:popL:non:empty/INV/m5:inv2"
    , " xxx m5/handle:popL:non:empty/INV/m5:inv3"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv4"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv5"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv6"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv7"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv8"
    , "  o  m5/handle:popL:non:empty/INV/m5:inv9"
    , "  o  m5/handle:popL:non:empty/IWWD/handle:popL:non:empty"
    , "  o  m5/handle:popL:non:empty/WD/C_SCH"
    , "  o  m5/handle:popL:non:empty/WD/F_SCH"
    , "  o  m5/handle:popL:non:empty/WD/GRD"
    , "  o  m5/handle:popL:non:empty/WWD"
    , "  o  m5/handle:popR:empty/FIS/LH@prime"
    , "  o  m5/handle:popR:empty/FIS/RH@prime"
    , "  o  m5/handle:popR:empty/FIS/emp@prime"
    , "  o  m5/handle:popR:empty/FIS/insL@prime"
    , "  o  m5/handle:popR:empty/FIS/insR@prime"
    , "  o  m5/handle:popR:empty/FIS/item@prime"
    , "  o  m5/handle:popR:empty/FIS/left@prime"
    , "  o  m5/handle:popR:empty/FIS/nL@prime"
    , "  o  m5/handle:popR:empty/FIS/nR@prime"
    , "  o  m5/handle:popR:empty/FIS/new@prime"
    , "  o  m5/handle:popR:empty/FIS/node@prime"
    , "  o  m5/handle:popR:empty/FIS/p@prime"
    , "  o  m5/handle:popR:empty/FIS/popL@prime"
    , "  o  m5/handle:popR:empty/FIS/popR@prime"
    , "  o  m5/handle:popR:empty/FIS/ppd@prime"
    , "  o  m5/handle:popR:empty/FIS/pshL@prime"
    , "  o  m5/handle:popR:empty/FIS/pshR@prime"
    , "  o  m5/handle:popR:empty/FIS/q@prime"
    , "  o  m5/handle:popR:empty/FIS/qe@prime"
    , "  o  m5/handle:popR:empty/FIS/rep@prime"
    , "  o  m5/handle:popR:empty/FIS/res@prime"
    , "  o  m5/handle:popR:empty/FIS/result@prime"
    , "  o  m5/handle:popR:empty/FIS/right@prime"
    , "  o  m5/handle:popR:empty/FIS/ver@prime"
    , "  o  m5/handle:popR:empty/INV/m5:inv0"
    , "  o  m5/handle:popR:empty/INV/m5:inv1"
    , "  o  m5/handle:popR:empty/INV/m5:inv2"
    , "  o  m5/handle:popR:empty/INV/m5:inv3"
    , "  o  m5/handle:popR:empty/INV/m5:inv4"
    , "  o  m5/handle:popR:empty/INV/m5:inv5"
    , "  o  m5/handle:popR:empty/INV/m5:inv6"
    , "  o  m5/handle:popR:empty/INV/m5:inv7"
    , "  o  m5/handle:popR:empty/INV/m5:inv8"
    , "  o  m5/handle:popR:empty/INV/m5:inv9"
    , "  o  m5/handle:popR:empty/IWWD/handle:popR:empty"
    , "  o  m5/handle:popR:empty/WD/C_SCH"
    , "  o  m5/handle:popR:empty/WD/F_SCH"
    , "  o  m5/handle:popR:empty/WD/GRD"
    , "  o  m5/handle:popR:empty/WWD"
    , "  o  m5/handle:popR:non:empty/FIS/LH@prime"
    , "  o  m5/handle:popR:non:empty/FIS/RH@prime"
    , "  o  m5/handle:popR:non:empty/FIS/emp@prime"
    , "  o  m5/handle:popR:non:empty/FIS/insL@prime"
    , "  o  m5/handle:popR:non:empty/FIS/insR@prime"
    , "  o  m5/handle:popR:non:empty/FIS/item@prime"
    , "  o  m5/handle:popR:non:empty/FIS/left@prime"
    , "  o  m5/handle:popR:non:empty/FIS/nL@prime"
    , "  o  m5/handle:popR:non:empty/FIS/nR@prime"
    , "  o  m5/handle:popR:non:empty/FIS/new@prime"
    , "  o  m5/handle:popR:non:empty/FIS/node@prime"
    , "  o  m5/handle:popR:non:empty/FIS/p@prime"
    , "  o  m5/handle:popR:non:empty/FIS/popL@prime"
    , "  o  m5/handle:popR:non:empty/FIS/popR@prime"
    , "  o  m5/handle:popR:non:empty/FIS/ppd@prime"
    , "  o  m5/handle:popR:non:empty/FIS/pshL@prime"
    , "  o  m5/handle:popR:non:empty/FIS/pshR@prime"
    , "  o  m5/handle:popR:non:empty/FIS/q@prime"
    , "  o  m5/handle:popR:non:empty/FIS/qe@prime"
    , "  o  m5/handle:popR:non:empty/FIS/rep@prime"
    , "  o  m5/handle:popR:non:empty/FIS/res@prime"
    , "  o  m5/handle:popR:non:empty/FIS/result@prime"
    , "  o  m5/handle:popR:non:empty/FIS/right@prime"
    , "  o  m5/handle:popR:non:empty/FIS/ver@prime"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv0"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv1"
    , " xxx m5/handle:popR:non:empty/INV/m5:inv2"
    , " xxx m5/handle:popR:non:empty/INV/m5:inv3"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv4"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv5"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv6"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv7"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv8"
    , "  o  m5/handle:popR:non:empty/INV/m5:inv9"
    , "  o  m5/handle:popR:non:empty/IWWD/handle:popR:non:empty"
    , "  o  m5/handle:popR:non:empty/WD/C_SCH"
    , "  o  m5/handle:popR:non:empty/WD/F_SCH"
    , "  o  m5/handle:popR:non:empty/WD/GRD"
    , "  o  m5/handle:popR:non:empty/WWD"
    , "  o  m5/handle:pushL/FIS/LH@prime"
    , "  o  m5/handle:pushL/FIS/RH@prime"
    , "  o  m5/handle:pushL/FIS/emp@prime"
    , "  o  m5/handle:pushL/FIS/insL@prime"
    , "  o  m5/handle:pushL/FIS/insR@prime"
    , "  o  m5/handle:pushL/FIS/item@prime"
    , "  o  m5/handle:pushL/FIS/left@prime"
    , "  o  m5/handle:pushL/FIS/nL@prime"
    , "  o  m5/handle:pushL/FIS/nR@prime"
    , "  o  m5/handle:pushL/FIS/new@prime"
    , "  o  m5/handle:pushL/FIS/node@prime"
    , "  o  m5/handle:pushL/FIS/p@prime"
    , "  o  m5/handle:pushL/FIS/popL@prime"
    , "  o  m5/handle:pushL/FIS/popR@prime"
    , "  o  m5/handle:pushL/FIS/ppd@prime"
    , "  o  m5/handle:pushL/FIS/pshL@prime"
    , "  o  m5/handle:pushL/FIS/pshR@prime"
    , "  o  m5/handle:pushL/FIS/q@prime"
    , "  o  m5/handle:pushL/FIS/qe@prime"
    , "  o  m5/handle:pushL/FIS/rep@prime"
    , "  o  m5/handle:pushL/FIS/res@prime"
    , "  o  m5/handle:pushL/FIS/result@prime"
    , "  o  m5/handle:pushL/FIS/right@prime"
    , "  o  m5/handle:pushL/FIS/ver@prime"
    , "  o  m5/handle:pushL/INV/m5:inv0"
    , "  o  m5/handle:pushL/INV/m5:inv1"
    , " xxx m5/handle:pushL/INV/m5:inv2"
    , "  o  m5/handle:pushL/INV/m5:inv3"
    , "  o  m5/handle:pushL/INV/m5:inv4"
    , "  o  m5/handle:pushL/INV/m5:inv5"
    , " xxx m5/handle:pushL/INV/m5:inv6"
    , " xxx m5/handle:pushL/INV/m5:inv7"
    , "  o  m5/handle:pushL/INV/m5:inv8"
    , "  o  m5/handle:pushL/INV/m5:inv9"
    , "  o  m5/handle:pushL/IWWD/handle:pushL"
    , "  o  m5/handle:pushL/WD/C_SCH"
    , "  o  m5/handle:pushL/WD/F_SCH"
    , "  o  m5/handle:pushL/WD/GRD"
    , "  o  m5/handle:pushL/WWD"
    , "  o  m5/handle:pushR/FIS/LH@prime"
    , "  o  m5/handle:pushR/FIS/RH@prime"
    , "  o  m5/handle:pushR/FIS/emp@prime"
    , "  o  m5/handle:pushR/FIS/insL@prime"
    , "  o  m5/handle:pushR/FIS/insR@prime"
    , "  o  m5/handle:pushR/FIS/item@prime"
    , "  o  m5/handle:pushR/FIS/left@prime"
    , "  o  m5/handle:pushR/FIS/nL@prime"
    , "  o  m5/handle:pushR/FIS/nR@prime"
    , "  o  m5/handle:pushR/FIS/new@prime"
    , "  o  m5/handle:pushR/FIS/node@prime"
    , "  o  m5/handle:pushR/FIS/p@prime"
    , "  o  m5/handle:pushR/FIS/popL@prime"
    , "  o  m5/handle:pushR/FIS/popR@prime"
    , "  o  m5/handle:pushR/FIS/ppd@prime"
    , "  o  m5/handle:pushR/FIS/pshL@prime"
    , "  o  m5/handle:pushR/FIS/pshR@prime"
    , "  o  m5/handle:pushR/FIS/q@prime"
    , "  o  m5/handle:pushR/FIS/qe@prime"
    , "  o  m5/handle:pushR/FIS/rep@prime"
    , "  o  m5/handle:pushR/FIS/res@prime"
    , "  o  m5/handle:pushR/FIS/result@prime"
    , "  o  m5/handle:pushR/FIS/right@prime"
    , "  o  m5/handle:pushR/FIS/ver@prime"
    , "  o  m5/handle:pushR/INV/m5:inv0"
    , "  o  m5/handle:pushR/INV/m5:inv1"
    , " xxx m5/handle:pushR/INV/m5:inv2"
    , "  o  m5/handle:pushR/INV/m5:inv3"
    , "  o  m5/handle:pushR/INV/m5:inv4"
    , "  o  m5/handle:pushR/INV/m5:inv5"
    , " xxx m5/handle:pushR/INV/m5:inv6"
    , " xxx m5/handle:pushR/INV/m5:inv7"
    , "  o  m5/handle:pushR/INV/m5:inv8"
    , "  o  m5/handle:pushR/INV/m5:inv9"
    , "  o  m5/handle:pushR/IWWD/handle:pushR"
    , "  o  m5/handle:pushR/WD/C_SCH"
    , "  o  m5/handle:pushR/WD/F_SCH"
    , "  o  m5/handle:pushR/WD/GRD"
    , "  o  m5/handle:pushR/WWD"
    , "  o  m5/return/FIS/LH@prime"
    , "  o  m5/return/FIS/RH@prime"
    , "  o  m5/return/FIS/emp@prime"
    , "  o  m5/return/FIS/insL@prime"
    , "  o  m5/return/FIS/insR@prime"
    , "  o  m5/return/FIS/item@prime"
    , "  o  m5/return/FIS/left@prime"
    , "  o  m5/return/FIS/nL@prime"
    , "  o  m5/return/FIS/nR@prime"
    , "  o  m5/return/FIS/new@prime"
    , "  o  m5/return/FIS/node@prime"
    , "  o  m5/return/FIS/p@prime"
    , "  o  m5/return/FIS/popL@prime"
    , "  o  m5/return/FIS/popR@prime"
    , "  o  m5/return/FIS/ppd@prime"
    , "  o  m5/return/FIS/pshL@prime"
    , "  o  m5/return/FIS/pshR@prime"
    , "  o  m5/return/FIS/q@prime"
    , "  o  m5/return/FIS/qe@prime"
    , "  o  m5/return/FIS/rep@prime"
    , "  o  m5/return/FIS/res@prime"
    , "  o  m5/return/FIS/result@prime"
    , "  o  m5/return/FIS/right@prime"
    , "  o  m5/return/FIS/ver@prime"
    , "  o  m5/return/INV/m5:inv0"
    , "  o  m5/return/INV/m5:inv1"
    , "  o  m5/return/INV/m5:inv2"
    , "  o  m5/return/INV/m5:inv3"
    , "  o  m5/return/INV/m5:inv4"
    , "  o  m5/return/INV/m5:inv5"
    , "  o  m5/return/INV/m5:inv6"
    , "  o  m5/return/INV/m5:inv7"
    , "  o  m5/return/INV/m5:inv8"
    , "  o  m5/return/INV/m5:inv9"
    , "  o  m5/return/IWWD/return"
    , "  o  m5/return/WD/C_SCH"
    , "  o  m5/return/WD/F_SCH"
    , "  o  m5/return/WD/GRD"
    , "  o  m5/return/WWD"
    , "passed 527 / 541"
    ]

case28 :: IO String
case28 = proof_obligation path27 "m5/INV/WD" 5

result28 :: String
result28 = unlines
    [ "; m5/INV/WD"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl$Node 0)"
    , "(declare-sort sl$OBJ 0)"
    , "(declare-sort sl$REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const LH sl$Node)"
    , "(declare-const RH sl$Node)"
    , "(declare-const dummy sl$Node)"
    , "(declare-const emp Bool)"
    , "(declare-const insL (pfun sl$REQ sl$OBJ))"
    , "(declare-const insR (pfun sl$REQ sl$OBJ))"
    , "(declare-const item (pfun sl$Node sl$OBJ))"
    , "(declare-const left (pfun sl$Node sl$Node))"
    , "(declare-const nL (pfun sl$REQ sl$Node))"
    , "(declare-const nR (pfun sl$REQ sl$Node))"
    , "(declare-const new (set sl$Node))"
    , "(declare-const node (set sl$Node))"
    , "(declare-const p Int)"
    , "(declare-const popL (set sl$REQ))"
    , "(declare-const popR (set sl$REQ))"
    , "(declare-const ppd (set sl$REQ))"
    , "(declare-const pshL (set sl$REQ))"
    , "(declare-const pshR (set sl$REQ))"
    , "(declare-const q Int)"
    , "(declare-const qe (pfun Int sl$OBJ))"
    , "(declare-const rep (pfun Int sl$Node))"
    , "(declare-const req (set sl$REQ))"
    , "(declare-const res (pfun sl$REQ sl$OBJ))"
    , "(declare-const result sl$OBJ)"
    , "(declare-const right (pfun sl$Node sl$Node))"
    , "(declare-const ver Int)"
    , "(declare-fun apply@@Int@@sl$Node"
    , "             ( (pfun Int sl$Node)"
    , "               Int )"
    , "             sl$Node)"
    , "(declare-fun apply@@Int@@sl$OBJ ( (pfun Int sl$OBJ) Int ) sl$OBJ)"
    , "(declare-fun apply@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node)"
    , "               sl$Node )"
    , "             sl$Node)"
    , "(declare-fun apply@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ)"
    , "               sl$Node )"
    , "             sl$OBJ)"
    , "(declare-fun apply@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node)"
    , "               sl$REQ )"
    , "             sl$Node)"
    , "(declare-fun apply@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ)"
    , "               sl$REQ )"
    , "             sl$OBJ)"
    , "(declare-fun between (Int Int Int) Bool)"
    , "(declare-fun betweenL (Int Int Int) Bool)"
    , "(declare-fun betweenLR (Int Int Int) Bool)"
    , "(declare-fun betweenR (Int Int Int) Bool)"
    , "(declare-fun card@@Int ( (set Int) ) Int)"
    , "(declare-fun card@@sl$Node ( (set sl$Node) ) Int)"
    , "(declare-fun card@@sl$OBJ ( (set sl$OBJ) ) Int)"
    , "(declare-fun card@@sl$REQ ( (set sl$REQ) ) Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$Node@Close"
    , "             ( (set (pfun Int sl$Node)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (set (pfun Int sl$OBJ)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "             ( (set (pfun sl$Node sl$Node)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "             ( (set (pfun sl$Node sl$OBJ)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "             ( (set (pfun sl$REQ sl$Node)) )"
    , "             Int)"
    , "(declare-fun card@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (set (pfun sl$REQ sl$OBJ)) )"
    , "             Int)"
    , "(declare-fun dom@@Int@@sl$Node ( (pfun Int sl$Node) ) (set Int))"
    , "(declare-fun dom@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set Int))"
    , "(declare-fun dom@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun dom@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             (set sl$Node))"
    , "(declare-fun dom@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set sl$REQ))"
    , "(declare-fun dom-rest@@Int@@sl$Node"
    , "             ( (set Int)"
    , "               (pfun Int sl$Node) )"
    , "             (pfun Int sl$Node))"
    , "(declare-fun dom-rest@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun dom-rest@@sl$Node@@sl$Node"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$Node) )"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun dom-rest@@sl$Node@@sl$OBJ"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$OBJ) )"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$Node"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$Node) )"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun dom-rest@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun dom-subt@@Int@@sl$Node"
    , "             ( (set Int)"
    , "               (pfun Int sl$Node) )"
    , "             (pfun Int sl$Node))"
    , "(declare-fun dom-subt@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun dom-subt@@sl$Node@@sl$Node"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$Node) )"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun dom-subt@@sl$Node@@sl$OBJ"
    , "             ( (set sl$Node)"
    , "               (pfun sl$Node sl$OBJ) )"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$Node"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$Node) )"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun dom-subt@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun empty-fun@@Int@@sl$Node () (pfun Int sl$Node))"
    , "(declare-fun empty-fun@@Int@@sl$OBJ () (pfun Int sl$OBJ))"
    , "(declare-fun empty-fun@@sl$Node@@sl$Node"
    , "             ()"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun empty-fun@@sl$Node@@sl$OBJ"
    , "             ()"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$Node"
    , "             ()"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun empty-fun@@sl$REQ@@sl$OBJ () (pfun sl$REQ sl$OBJ))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl$Node ( (set sl$Node) ) Bool)"
    , "(declare-fun finite@@sl$OBJ ( (set sl$OBJ) ) Bool)"
    , "(declare-fun finite@@sl$REQ ( (set sl$REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$Node@Close"
    , "             ( (set (pfun Int sl$Node)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (set (pfun Int sl$OBJ)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "             ( (set (pfun sl$Node sl$Node)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "             ( (set (pfun sl$Node sl$OBJ)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "             ( (set (pfun sl$REQ sl$Node)) )"
    , "             Bool)"
    , "(declare-fun finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (set (pfun sl$REQ sl$OBJ)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl$Node ( (pfun Int sl$Node) ) Bool)"
    , "(declare-fun injective@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) Bool)"
    , "(declare-fun injective@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             Bool)"
    , "(declare-fun injective@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl$Node"
    , "             (Int sl$Node)"
    , "             (pfun Int sl$Node))"
    , "(declare-fun mk-fun@@Int@@sl$OBJ"
    , "             (Int sl$OBJ)"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun mk-fun@@sl$Node@@sl$Node"
    , "             (sl$Node sl$Node)"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun mk-fun@@sl$Node@@sl$OBJ"
    , "             (sl$Node sl$OBJ)"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun mk-fun@@sl$REQ@@sl$Node"
    , "             (sl$REQ sl$Node)"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun mk-fun@@sl$REQ@@sl$OBJ"
    , "             (sl$REQ sl$OBJ)"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl$Node (sl$Node) (set sl$Node))"
    , "(declare-fun mk-set@@sl$OBJ (sl$OBJ) (set sl$OBJ))"
    , "(declare-fun mk-set@@sl$REQ (sl$REQ) (set sl$REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$Node@Close"
    , "             ( (pfun Int sl$Node) )"
    , "             (set (pfun Int sl$Node)))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl$OBJ@Close"
    , "             ( (pfun Int sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun mk-set@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             (set (pfun sl$Node sl$Node)))"
    , "(declare-fun mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             (set (pfun sl$Node sl$OBJ)))"
    , "(declare-fun mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             (set (pfun sl$REQ sl$Node)))"
    , "(declare-fun mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(declare-fun ovl@@Int@@sl$Node"
    , "             ( (pfun Int sl$Node)"
    , "               (pfun Int sl$Node) )"
    , "             (pfun Int sl$Node))"
    , "(declare-fun ovl@@Int@@sl$OBJ"
    , "             ( (pfun Int sl$OBJ)"
    , "               (pfun Int sl$OBJ) )"
    , "             (pfun Int sl$OBJ))"
    , "(declare-fun ovl@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node)"
    , "               (pfun sl$Node sl$Node) )"
    , "             (pfun sl$Node sl$Node))"
    , "(declare-fun ovl@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ)"
    , "               (pfun sl$Node sl$OBJ) )"
    , "             (pfun sl$Node sl$OBJ))"
    , "(declare-fun ovl@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node)"
    , "               (pfun sl$REQ sl$Node) )"
    , "             (pfun sl$REQ sl$Node))"
    , "(declare-fun ovl@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ)"
    , "               (pfun sl$REQ sl$OBJ) )"
    , "             (pfun sl$REQ sl$OBJ))"
    , "(declare-fun pfun@@Int@@sl$Node"
    , "             ( (set Int)"
    , "               (set sl$Node) )"
    , "             (set (pfun Int sl$Node)))"
    , "(declare-fun pfun@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun pfun@@sl$Node@@sl$Node"
    , "             ( (set sl$Node)"
    , "               (set sl$Node) )"
    , "             (set (pfun sl$Node sl$Node)))"
    , "(declare-fun pfun@@sl$Node@@sl$OBJ"
    , "             ( (set sl$Node)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$Node sl$OBJ)))"
    , "(declare-fun pfun@@sl$REQ@@sl$Node"
    , "             ( (set sl$REQ)"
    , "               (set sl$Node) )"
    , "             (set (pfun sl$REQ sl$Node)))"
    , "(declare-fun pfun@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(declare-fun ran@@Int@@sl$Node"
    , "             ( (pfun Int sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun ran@@Int@@sl$OBJ ( (pfun Int sl$OBJ) ) (set sl$OBJ))"
    , "(declare-fun ran@@sl$Node@@sl$Node"
    , "             ( (pfun sl$Node sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun ran@@sl$Node@@sl$OBJ"
    , "             ( (pfun sl$Node sl$OBJ) )"
    , "             (set sl$OBJ))"
    , "(declare-fun ran@@sl$REQ@@sl$Node"
    , "             ( (pfun sl$REQ sl$Node) )"
    , "             (set sl$Node))"
    , "(declare-fun ran@@sl$REQ@@sl$OBJ"
    , "             ( (pfun sl$REQ sl$OBJ) )"
    , "             (set sl$OBJ))"
    , "(declare-fun tfun@@Int@@sl$Node"
    , "             ( (set Int)"
    , "               (set sl$Node) )"
    , "             (set (pfun Int sl$Node)))"
    , "(declare-fun tfun@@Int@@sl$OBJ"
    , "             ( (set Int)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun Int sl$OBJ)))"
    , "(declare-fun tfun@@sl$Node@@sl$Node"
    , "             ( (set sl$Node)"
    , "               (set sl$Node) )"
    , "             (set (pfun sl$Node sl$Node)))"
    , "(declare-fun tfun@@sl$Node@@sl$OBJ"
    , "             ( (set sl$Node)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$Node sl$OBJ)))"
    , "(declare-fun tfun@@sl$REQ@@sl$Node"
    , "             ( (set sl$REQ)"
    , "               (set sl$Node) )"
    , "             (set (pfun sl$REQ sl$Node)))"
    , "(declare-fun tfun@@sl$REQ@@sl$OBJ"
    , "             ( (set sl$REQ)"
    , "               (set sl$OBJ) )"
    , "             (set (pfun sl$REQ sl$OBJ)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl$Node"
    , "            ()"
    , "            (set sl$Node)"
    , "            ( (as const (set sl$Node))"
    , "              true ))"
    , "(define-fun all@@sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              true ))"
    , "(define-fun all@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun Int sl$Node))"
    , "            ( (as const (set (pfun Int sl$Node)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (as const (set (pfun Int sl$OBJ)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun sl$Node sl$Node))"
    , "            ( (as const (set (pfun sl$Node sl$Node)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$Node sl$OBJ))"
    , "            ( (as const (set (pfun sl$Node sl$OBJ)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$Node))"
    , "            ( (as const (set (pfun sl$REQ sl$Node)))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (as const (set (pfun sl$REQ sl$OBJ)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$Node"
    , "            ( (s1 (set sl$Node)) )"
    , "            (set sl$Node)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ)) )"
    , "            (set sl$OBJ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl$REQ"
    , "            ( (s1 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$Node@Close"
    , "            ( (s1 (set (pfun Int sl$Node))) )"
    , "            (set (pfun Int sl$Node))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ))) )"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$Node sl$Node))) )"
    , "            (set (pfun sl$Node sl$Node))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$Node sl$OBJ))) )"
    , "            (set (pfun sl$Node sl$OBJ))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$Node))) )"
    , "            (set (pfun sl$REQ sl$Node))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ))) )"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$Node"
    , "            ( (x sl$Node)"
    , "              (s1 (set sl$Node)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$OBJ"
    , "            ( (x sl$OBJ)"
    , "              (s1 (set sl$OBJ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl$REQ"
    , "            ( (x sl$REQ)"
    , "              (s1 (set sl$REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$Node@Close"
    , "            ( (x (pfun Int sl$Node))"
    , "              (s1 (set (pfun Int sl$Node))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (x (pfun Int sl$OBJ))"
    , "              (s1 (set (pfun Int sl$OBJ))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ( (x (pfun sl$Node sl$Node))"
    , "              (s1 (set (pfun sl$Node sl$Node))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ( (x (pfun sl$Node sl$OBJ))"
    , "              (s1 (set (pfun sl$Node sl$OBJ))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ( (x (pfun sl$REQ sl$Node))"
    , "              (s1 (set (pfun sl$REQ sl$Node))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (x (pfun sl$REQ sl$OBJ))"
    , "              (s1 (set (pfun sl$REQ sl$OBJ))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl$Node"
    , "            ()"
    , "            (set sl$Node)"
    , "            ( (as const (set sl$Node))"
    , "              false ))"
    , "(define-fun empty-set@@sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              false ))"
    , "(define-fun empty-set@@sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun Int sl$Node))"
    , "            ( (as const (set (pfun Int sl$Node)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun Int sl$OBJ))"
    , "            ( (as const (set (pfun Int sl$OBJ)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun sl$Node sl$Node))"
    , "            ( (as const (set (pfun sl$Node sl$Node)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$Node sl$OBJ))"
    , "            ( (as const (set (pfun sl$Node sl$OBJ)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$Node))"
    , "            ( (as const (set (pfun sl$REQ sl$Node)))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ()"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            ( (as const (set (pfun sl$REQ sl$OBJ)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$Node"
    , "            ( (s1 (set sl$Node))"
    , "              (s2 (set sl$Node)) )"
    , "            (set sl$Node)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ))"
    , "              (s2 (set sl$OBJ)) )"
    , "            (set sl$OBJ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            (set sl$REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$Node@Close"
    , "            ( (s1 (set (pfun Int sl$Node)))"
    , "              (s2 (set (pfun Int sl$Node))) )"
    , "            (set (pfun Int sl$Node))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ)))"
    , "              (s2 (set (pfun Int sl$OBJ))) )"
    , "            (set (pfun Int sl$OBJ))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$Node sl$Node)))"
    , "              (s2 (set (pfun sl$Node sl$Node))) )"
    , "            (set (pfun sl$Node sl$Node))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$Node sl$OBJ)))"
    , "              (s2 (set (pfun sl$Node sl$OBJ))) )"
    , "            (set (pfun sl$Node sl$OBJ))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$Node)))"
    , "              (s2 (set (pfun sl$REQ sl$Node))) )"
    , "            (set (pfun sl$REQ sl$Node))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "              (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "            (set (pfun sl$REQ sl$OBJ))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$Node"
    , "            ( (s1 (set sl$Node))"
    , "              (s2 (set sl$Node)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$OBJ"
    , "            ( (s1 (set sl$OBJ))"
    , "              (s2 (set sl$OBJ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl$REQ"
    , "            ( (s1 (set sl$REQ))"
    , "              (s2 (set sl$REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$Node@Close"
    , "            ( (s1 (set (pfun Int sl$Node)))"
    , "              (s2 (set (pfun Int sl$Node))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun Int sl$OBJ)))"
    , "              (s2 (set (pfun Int sl$OBJ))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$Node@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$Node sl$Node)))"
    , "              (s2 (set (pfun sl$Node sl$Node))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$Node@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$Node sl$OBJ)))"
    , "              (s2 (set (pfun sl$Node sl$OBJ))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$REQ@@sl$Node@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$Node)))"
    , "              (s2 (set (pfun sl$REQ sl$Node))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@sl$REQ@@sl$OBJ@Close"
    , "            ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "              (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl$Node"
    , "            ()"
    , "            (set sl$Node)"
    , "            ( (as const (set sl$Node))"
    , "              true ))"
    , "(define-fun sl$OBJ"
    , "            ()"
    , "            (set sl$OBJ)"
    , "            ( (as const (set sl$OBJ))"
    , "              true ))"
    , "(define-fun sl$REQ"
    , "            ()"
    , "            (set sl$REQ)"
    , "            ( (as const (set sl$REQ))"
    , "              true ))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (=> (finite@@Int r) (<= 0 (card@@Int r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@Int r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$Node@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$Node@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$Node@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@Int@@sl$OBJ@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@Int@@sl$OBJ@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Node@@sl$Node@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@sl$Node@@sl$Node@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@sl$Node@@sl$Node@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$Node@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@sl$REQ@@sl$Node@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@sl$REQ@@sl$Node@Close r)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)"
    , "                       (<= 0 (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)) ))))"
    , "(assert (forall ( (r (set sl$Node)) )"
    , "                (! (=> (finite@@sl$Node r) (<= 0 (card@@sl$Node r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$Node r)) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (=> (finite@@sl$OBJ r) (<= 0 (card@@sl$OBJ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$OBJ r)) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ r) (<= 0 (card@@sl$REQ r)))"
    , "                   :pattern"
    , "                   ( (<= 0 (card@@sl$REQ r)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 0) (= r empty-set@@Int))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$Node@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$Node@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$OBJ@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@Int@@sl$OBJ@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Node@@sl$Node@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@sl$Node@@sl$Node@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) 0)"
    , "                      (= r empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set sl$Node)) )"
    , "                (! (= (= (card@@sl$Node r) 0) (= r empty-set@@sl$Node))"
    , "                   :pattern"
    , "                   ( (card@@sl$Node r) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (= (= (card@@sl$OBJ r) 0) (= r empty-set@@sl$OBJ))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 0) (= r empty-set@@sl$REQ))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (card@@Int (mk-set@@Int x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Node)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ)) )"
    , "                (! (= (card@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$Node)) )"
    , "                (! (= (card@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$Node)) )"
    , "                (! (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x sl$Node) )"
    , "                (! (= (card@@sl$Node (mk-set@@sl$Node x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$Node (mk-set@@sl$Node x)) ))))"
    , "(assert (forall ( (x sl$OBJ) )"
    , "                (! (= (card@@sl$OBJ (mk-set@@sl$OBJ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ (mk-set@@sl$OBJ x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (= (card@@sl$REQ (mk-set@@sl$REQ x)) 1)"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (forall ( (r (set Int)) )"
    , "                (! (= (= (card@@Int r) 1)"
    , "                      (exists ( (x Int) ) (and true (= r (mk-set@@Int x)))))"
    , "                   :pattern"
    , "                   ( (card@@Int r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$Node@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$Node)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@Int@@sl$Node@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@Int@@sl$OBJ@Close r) 1)"
    , "                      (exists ( (x (pfun Int sl$OBJ)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Node@@sl$Node@Close r) 1)"
    , "                      (exists ( (x (pfun sl$Node sl$Node)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) 1)"
    , "                      (exists ( (x (pfun sl$Node sl$OBJ)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$Node))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) 1)"
    , "                      (exists ( (x (pfun sl$REQ sl$Node)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close r) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (= (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) 1)"
    , "                      (exists ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                              (and true"
    , "                                   (= r (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r) ))))"
    , "(assert (forall ( (r (set sl$Node)) )"
    , "                (! (= (= (card@@sl$Node r) 1)"
    , "                      (exists ( (x sl$Node) )"
    , "                              (and true (= r (mk-set@@sl$Node x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Node r) ))))"
    , "(assert (forall ( (r (set sl$OBJ)) )"
    , "                (! (= (= (card@@sl$OBJ r) 1)"
    , "                      (exists ( (x sl$OBJ) ) (and true (= r (mk-set@@sl$OBJ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ r) ))))"
    , "(assert (forall ( (r (set sl$REQ)) )"
    , "                (! (= (= (card@@sl$REQ r) 1)"
    , "                      (exists ( (x sl$REQ) ) (and true (= r (mk-set@@sl$REQ x)))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ r) ))))"
    , "(assert (forall ( (r (set Int))"
    , "                  (r0 (set Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@Int)"
    , "                       (= (card@@Int (union r r0))"
    , "                          (+ (card@@Int r) (card@@Int r0))))"
    , "                   :pattern"
    , "                   ( (card@@Int (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$Node)))"
    , "                  (r0 (set (pfun Int sl$Node))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$Node@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$Node@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$Node@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$Node@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$Node@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun Int sl$OBJ)))"
    , "                  (r0 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@Int@@sl$OBJ@Close)"
    , "                       (= (card@Open@@pfun@@Int@@sl$OBJ@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@Int@@sl$OBJ@Close r)"
    , "                             (card@Open@@pfun@@Int@@sl$OBJ@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@Int@@sl$OBJ@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$Node)))"
    , "                  (r0 (set (pfun sl$Node sl$Node))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$Node@@sl$Node@Close)"
    , "                       (= (card@Open@@pfun@@sl$Node@@sl$Node@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$Node@@sl$Node@Close r)"
    , "                             (card@Open@@pfun@@sl$Node@@sl$Node@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$Node@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$Node sl$OBJ)))"
    , "                  (r0 (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close)"
    , "                       (= (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r)"
    , "                             (card@Open@@pfun@@sl$Node@@sl$OBJ@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$Node@@sl$OBJ@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$Node)))"
    , "                  (r0 (set (pfun sl$REQ sl$Node))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close)"
    , "                       (= (card@Open@@pfun@@sl$REQ@@sl$Node@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$REQ@@sl$Node@Close r)"
    , "                             (card@Open@@pfun@@sl$REQ@@sl$Node@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$Node@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set (pfun sl$REQ sl$OBJ)))"
    , "                  (r0 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (= (intersect r r0)"
    , "                          empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close)"
    , "                       (= (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union r r0))"
    , "                          (+ (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r)"
    , "                             (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close r0))))"
    , "                   :pattern"
    , "                   ( (card@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$Node))"
    , "                  (r0 (set sl$Node)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$Node)"
    , "                       (= (card@@sl$Node (union r r0))"
    , "                          (+ (card@@sl$Node r) (card@@sl$Node r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$Node (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$OBJ))"
    , "                  (r0 (set sl$OBJ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$OBJ)"
    , "                       (= (card@@sl$OBJ (union r r0))"
    , "                          (+ (card@@sl$OBJ r) (card@@sl$OBJ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$OBJ (union r r0)) ))))"
    , "(assert (forall ( (r (set sl$REQ))"
    , "                  (r0 (set sl$REQ)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl$REQ)"
    , "                       (= (card@@sl$REQ (union r r0))"
    , "                          (+ (card@@sl$REQ r) (card@@sl$REQ r0))))"
    , "                   :pattern"
    , "                   ( (card@@sl$REQ (union r r0)) ))))"
    , "(assert (= (dom@@Int@@sl$Node empty-fun@@Int@@sl$Node)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (dom@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (dom@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node)"
    , "           empty-set@@sl$REQ))"
    , "(assert (= (dom@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)"
    , "           empty-set@@sl$REQ))"
    , "(assert (forall ( (f1 (pfun Int sl$Node)) )"
    , "                (! (= (ovl@@Int@@sl$Node f1 empty-fun@@Int@@sl$Node) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$Node f1 empty-fun@@Int@@sl$Node) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$OBJ f1 empty-fun@@Int@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node)) )"
    , "                (! (= (ovl@@sl$Node@@sl$Node f1 empty-fun@@sl$Node@@sl$Node)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$Node f1 empty-fun@@sl$Node@@sl$Node) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (ovl@@sl$Node@@sl$OBJ f1 empty-fun@@sl$Node@@sl$OBJ)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$OBJ f1 empty-fun@@sl$Node@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$Node f1 empty-fun@@sl$REQ@@sl$Node)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$Node f1 empty-fun@@sl$REQ@@sl$Node) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$OBJ f1 empty-fun@@sl$REQ@@sl$OBJ) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node)) )"
    , "                (! (= (ovl@@Int@@sl$Node empty-fun@@Int@@sl$Node f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$Node empty-fun@@Int@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node)) )"
    , "                (! (= (ovl@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (ovl@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1)"
    , "                      f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (dom@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y))"
    , "                      (mk-set@@sl$Node x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                      (mk-set@@sl$Node x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                      (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                      (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (f2 (pfun Int sl$Node))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$Node f2))"
    , "                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x)"
    , "                          (apply@@Int@@sl$Node f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f2))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)"
    , "                          (apply@@Int@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (f2 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$Node f2))"
    , "                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$Node f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (f2 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f2))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (f2 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f2))"
    , "                       (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$Node f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f2))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (f2 (pfun Int sl$Node))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$Node f2))))"
    , "                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x)"
    , "                          (apply@@Int@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl$OBJ f2))))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (f2 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                            (not (elem@@sl$Node x (dom@@sl$Node@@sl$Node f2))))"
    , "                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (f2 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                            (not (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f2))))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (f2 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f2))))"
    , "                       (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                            (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f2))))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y) x) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y) x) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$Node f1)))"
    , "                       (= (apply@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1) x)"
    , "                          (apply@@Int@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl$OBJ f1)))"
    , "                       (= (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x s1)"
    , "                            (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1)))"
    , "                       (= (apply@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x s1)"
    , "                            (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1)))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x s1)"
    , "                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1)))"
    , "                       (= (apply@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (and (elem@@sl$REQ x s1)"
    , "                            (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Node f1) s1))"
    , "                       (= (apply@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1) x)"
    , "                          (apply@@Int@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (= (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x)"
    , "                          (apply@@Int@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))"
    , "                       (= (apply@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))"
    , "                       (= (apply@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$Node f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1) x)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1) x) ))))"
    , "(assert (forall ( (s2 (set sl$Node)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$Node@Close empty-fun@@Int@@sl$Node"
    , "                                                        (tfun@@Int@@sl$Node empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Node@Close empty-fun@@Int@@sl$Node"
    , "                                                          (tfun@@Int@@sl$Node empty-set@@Int s2)) ))))"
    , "(assert (forall ( (s2 (set sl$OBJ)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl$OBJ@Close empty-fun@@Int@@sl$OBJ"
    , "                                                       (tfun@@Int@@sl$OBJ empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close empty-fun@@Int@@sl$OBJ"
    , "                                                         (tfun@@Int@@sl$OBJ empty-set@@Int s2)) ))))"
    , "(assert (forall ( (s2 (set sl$Node)) )"
    , "                (! (elem@Open@@pfun@@sl$Node@@sl$Node@Close empty-fun@@sl$Node@@sl$Node"
    , "                                                            (tfun@@sl$Node@@sl$Node empty-set@@sl$Node s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close empty-fun@@sl$Node@@sl$Node"
    , "                                                              (tfun@@sl$Node@@sl$Node empty-set@@sl$Node s2)) ))))"
    , "(assert (forall ( (s2 (set sl$OBJ)) )"
    , "                (! (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close empty-fun@@sl$Node@@sl$OBJ"
    , "                                                           (tfun@@sl$Node@@sl$OBJ empty-set@@sl$Node s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close empty-fun@@sl$Node@@sl$OBJ"
    , "                                                             (tfun@@sl$Node@@sl$OBJ empty-set@@sl$Node s2)) ))))"
    , "(assert (forall ( (s2 (set sl$Node)) )"
    , "                (! (elem@Open@@pfun@@sl$REQ@@sl$Node@Close empty-fun@@sl$REQ@@sl$Node"
    , "                                                           (tfun@@sl$REQ@@sl$Node empty-set@@sl$REQ s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close empty-fun@@sl$REQ@@sl$Node"
    , "                                                             (tfun@@sl$REQ@@sl$Node empty-set@@sl$REQ s2)) ))))"
    , "(assert (forall ( (s2 (set sl$OBJ)) )"
    , "                (! (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-fun@@sl$REQ@@sl$OBJ"
    , "                                                          (tfun@@sl$REQ@@sl$OBJ empty-set@@sl$REQ s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-fun@@sl$REQ@@sl$OBJ"
    , "                                                            (tfun@@sl$REQ@@sl$OBJ empty-set@@sl$REQ s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (f2 (pfun Int sl$Node)) )"
    , "                (! (= (dom@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2))"
    , "                      (union (dom@@Int@@sl$Node f1) (dom@@Int@@sl$Node f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (ovl@@Int@@sl$Node f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (f2 (pfun Int sl$OBJ)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2))"
    , "                      (union (dom@@Int@@sl$OBJ f1) (dom@@Int@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (f2 (pfun sl$Node sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2))"
    , "                      (union (dom@@sl$Node@@sl$Node f1)"
    , "                             (dom@@sl$Node@@sl$Node f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (f2 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2))"
    , "                      (union (dom@@sl$Node@@sl$OBJ f1)"
    , "                             (dom@@sl$Node@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (f2 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$Node f1)"
    , "                             (dom@@sl$REQ@@sl$Node f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (f2 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2))"
    , "                      (union (dom@@sl$REQ@@sl$OBJ f1) (dom@@sl$REQ@@sl$OBJ f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))"
    , "                      (intersect s1 (dom@@sl$Node@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@sl$Node@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))"
    , "                      (intersect s1 (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$Node f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))"
    , "                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node)) )"
    , "                (! (= (dom@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))"
    , "                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ)) )"
    , "                (! (= (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))"
    , "                      (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                           (= (apply@@Int@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                     (apply@@Int@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                           (= (apply@@Int@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                     (apply@@Int@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                           (= (apply@@sl$Node@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                     (apply@@sl$Node@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (= (apply@@sl$Node@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                     (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                           (= (apply@@sl$REQ@@sl$Node f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                     (apply@@sl$REQ@@sl$Node f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (= (apply@@sl$REQ@@sl$OBJ f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                     (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                               x2)"
    , "                          (apply@@Int@@sl$Node f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))"
    , "                                              x2)"
    , "                          (apply@@Int@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))"
    , "                                         x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (x2 sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                                   x2)"
    , "                          (apply@@sl$Node@@sl$Node f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                              x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (x2 sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                                  x2)"
    , "                          (apply@@sl$Node@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                             x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (x2 sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                                                  x2)"
    , "                          (apply@@sl$REQ@@sl$Node f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                                             x2) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (x2 sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                                 x2)"
    , "                          (apply@@sl$REQ@@sl$OBJ f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                            x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))"
    , "                                          x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                               x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))"
    , "                                              x) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                              x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                                             x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                                              x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                                             x) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                             x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                                            x) ))))"
    , "(assert (= (ran@@Int@@sl$Node empty-fun@@Int@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (ran@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (= (ran@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (ran@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (= (ran@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node)"
    , "           empty-set@@sl$Node))"
    , "(assert (= (ran@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ)"
    , "           empty-set@@sl$OBJ))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node y (ran@@Int@@sl$Node f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                                        (= (apply@@Int@@sl$Node f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node y (ran@@Int@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                                        (= (apply@@Int@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@Int@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node y (ran@@sl$Node@@sl$Node f1))"
    , "                      (exists ( (x sl$Node) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                                        (= (apply@@sl$Node@@sl$Node f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node y (ran@@sl$Node@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@sl$Node@@sl$OBJ f1))"
    , "                      (exists ( (x sl$Node) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                                        (= (apply@@sl$Node@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@sl$Node@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node y (ran@@sl$REQ@@sl$Node f1))"
    , "                      (exists ( (x sl$REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                                        (= (apply@@sl$REQ@@sl$Node f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node y (ran@@sl$REQ@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ y (ran@@sl$REQ@@sl$OBJ f1))"
    , "                      (exists ( (x sl$REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                                        (= (apply@@sl$REQ@@sl$OBJ f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ y (ran@@sl$REQ@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (= (ran@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y))"
    , "                      (mk-set@@sl$Node y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Node (mk-fun@@Int@@sl$Node x y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (mk-fun@@Int@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (ran@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y))"
    , "                      (mk-set@@sl$Node y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$Node (mk-fun@@sl$Node@@sl$Node x y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$OBJ (mk-fun@@sl$Node@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (= (ran@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y))"
    , "                      (mk-set@@sl$Node y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$Node (mk-fun@@sl$REQ@@sl$Node x y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (ran@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y))"
    , "                      (mk-set@@sl$OBJ y))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (mk-fun@@sl$REQ@@sl$OBJ x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Node@Close f1 (tfun@@Int@@sl$Node s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$Node f1))"
    , "                           (subset (ran@@Int@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Node@Close f1 (tfun@@Int@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (tfun@@Int@@sl$OBJ s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl$OBJ f1))"
    , "                           (subset (ran@@Int@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (tfun@@Int@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (tfun@@sl$Node@@sl$Node s1 s2))"
    , "                      (and (= s1 (dom@@sl$Node@@sl$Node f1))"
    , "                           (subset (ran@@sl$Node@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (tfun@@sl$Node@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (tfun@@sl$Node@@sl$OBJ s1 s2))"
    , "                      (and (= s1 (dom@@sl$Node@@sl$OBJ f1))"
    , "                           (subset (ran@@sl$Node@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (tfun@@sl$Node@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (tfun@@sl$REQ@@sl$Node s1 s2))"
    , "                      (and (= s1 (dom@@sl$REQ@@sl$Node f1))"
    , "                           (subset (ran@@sl$REQ@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (tfun@@sl$REQ@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (tfun@@sl$REQ@@sl$OBJ s1 s2))"
    , "                      (and (= s1 (dom@@sl$REQ@@sl$OBJ f1))"
    , "                           (subset (ran@@sl$REQ@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (tfun@@sl$REQ@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Node@Close f1 (pfun@@Int@@sl$Node s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$Node f1) s1)"
    , "                           (subset (ran@@Int@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Node@Close f1 (pfun@@Int@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (pfun@@Int@@sl$OBJ s1 s2))"
    , "                      (and (subset (dom@@Int@@sl$OBJ f1) s1)"
    , "                           (subset (ran@@Int@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close f1 (pfun@@Int@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (pfun@@sl$Node@@sl$Node s1 s2))"
    , "                      (and (subset (dom@@sl$Node@@sl$Node f1) s1)"
    , "                           (subset (ran@@sl$Node@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close f1 (pfun@@sl$Node@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (pfun@@sl$Node@@sl$OBJ s1 s2))"
    , "                      (and (subset (dom@@sl$Node@@sl$OBJ f1) s1)"
    , "                           (subset (ran@@sl$Node@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close f1 (pfun@@sl$Node@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (pfun@@sl$REQ@@sl$Node s1 s2))"
    , "                      (and (subset (dom@@sl$REQ@@sl$Node f1) s1)"
    , "                           (subset (ran@@sl$REQ@@sl$Node f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close f1 (pfun@@sl$REQ@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (pfun@@sl$REQ@@sl$OBJ s1 s2))"
    , "                      (and (subset (dom@@sl$REQ@@sl$OBJ f1) s1)"
    , "                           (subset (ran@@sl$REQ@@sl$OBJ f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close f1 (pfun@@sl$REQ@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node)) )"
    , "                (! (= (injective@@Int@@sl$Node f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$Node f1)))"
    , "                                  (=> (= (apply@@Int@@sl$Node f1 x)"
    , "                                         (apply@@Int@@sl$Node f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ)) )"
    , "                (! (= (injective@@Int@@sl$OBJ f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@Int@@sl$OBJ f1 x)"
    , "                                         (apply@@Int@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node)) )"
    , "                (! (= (injective@@sl$Node@@sl$Node f1)"
    , "                      (forall ( (x sl$Node)"
    , "                                (x2 sl$Node) )"
    , "                              (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                                       (elem@@sl$Node x2 (dom@@sl$Node@@sl$Node f1)))"
    , "                                  (=> (= (apply@@sl$Node@@sl$Node f1 x)"
    , "                                         (apply@@sl$Node@@sl$Node f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Node@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (injective@@sl$Node@@sl$OBJ f1)"
    , "                      (forall ( (x sl$Node)"
    , "                                (x2 sl$Node) )"
    , "                              (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                                       (elem@@sl$Node x2 (dom@@sl$Node@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                         (apply@@sl$Node@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$Node@@sl$OBJ f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node)) )"
    , "                (! (= (injective@@sl$REQ@@sl$Node f1)"
    , "                      (forall ( (x sl$REQ)"
    , "                                (x2 sl$REQ) )"
    , "                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$Node f1)))"
    , "                                  (=> (= (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                         (apply@@sl$REQ@@sl$Node f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$REQ@@sl$Node f1) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (injective@@sl$REQ@@sl$OBJ f1)"
    , "                      (forall ( (x sl$REQ)"
    , "                                (x2 sl$REQ) )"
    , "                              (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                                       (elem@@sl$REQ x2 (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                                  (=> (= (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                         (apply@@sl$REQ@@sl$OBJ f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl$REQ@@sl$OBJ f1) ))))"
    , "(assert (injective@@Int@@sl$Node empty-fun@@Int@@sl$Node))"
    , "(assert (injective@@Int@@sl$OBJ empty-fun@@Int@@sl$OBJ))"
    , "(assert (injective@@sl$Node@@sl$Node empty-fun@@sl$Node@@sl$Node))"
    , "(assert (injective@@sl$Node@@sl$OBJ empty-fun@@sl$Node@@sl$OBJ))"
    , "(assert (injective@@sl$REQ@@sl$Node empty-fun@@sl$REQ@@sl$Node))"
    , "(assert (injective@@sl$REQ@@sl$OBJ empty-fun@@sl$REQ@@sl$OBJ))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x) (ran@@Int@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x) (ran@@Int@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x) (ran@@Int@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                      (ran@@sl$Node@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                    (ran@@sl$Node@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$Node@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$Node@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                       (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                      (ran@@sl$REQ@@sl$Node f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                    (ran@@sl$REQ@@sl$Node f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                      (ran@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                    (ran@@Int@@sl$Node (dom-subt@@Int@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                     (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                   (ran@@Int@@sl$OBJ (dom-subt@@Int@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                      (ran@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                    (ran@@sl$Node@@sl$Node (dom-subt@@sl$Node@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x"
    , "                                      (set-diff@@sl$Node (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$Node@@sl$OBJ (dom-subt@@sl$Node@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                      (ran@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                    (ran@@sl$REQ@@sl$Node (dom-subt@@sl$REQ@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (set-diff@@sl$REQ (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ (dom-subt@@sl$REQ@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                      (ran@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@Int@@sl$Node f1 x)"
    , "                                    (ran@@Int@@sl$Node (dom-rest@@Int@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                     (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)"
    , "                                   (ran@@Int@@sl$OBJ (dom-rest@@Int@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (intersect (dom@@sl$Node@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                      (ran@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$Node@@sl$Node f1 x)"
    , "                                    (ran@@sl$Node@@sl$Node (dom-rest@@sl$Node@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (s1 (set sl$Node))"
    , "                  (x sl$Node) )"
    , "                (! (=> (elem@@sl$Node x (intersect (dom@@sl$Node@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$Node@@sl$OBJ (dom-rest@@sl$Node@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$Node f1) s1))"
    , "                       (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                      (ran@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)"
    , "                                    (ran@@sl$REQ@@sl$Node (dom-rest@@sl$REQ@@sl$Node s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (s1 (set sl$REQ))"
    , "                  (x sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ x (intersect (dom@@sl$REQ@@sl$OBJ f1) s1))"
    , "                       (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                     (ran@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)"
    , "                                   (ran@@sl$REQ@@sl$OBJ (dom-rest@@sl$REQ@@sl$OBJ s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$Node f1))"
    , "                            (injective@@Int@@sl$Node f1))"
    , "                       (= (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y)))"
    , "                          (union (set-diff@@sl$Node (ran@@Int@@sl$Node f1)"
    , "                                                    (mk-set@@sl$Node (apply@@Int@@sl$Node f1 x)))"
    , "                                 (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl$OBJ f1))"
    , "                            (injective@@Int@@sl$OBJ f1))"
    , "                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@Int@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@Int@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1))"
    , "                            (injective@@sl$Node@@sl$Node f1))"
    , "                       (= (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y)))"
    , "                          (union (set-diff@@sl$Node (ran@@sl$Node@@sl$Node f1)"
    , "                                                    (mk-set@@sl$Node (apply@@sl$Node@@sl$Node f1 x)))"
    , "                                 (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1))"
    , "                            (injective@@sl$Node@@sl$OBJ f1))"
    , "                       (= (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@sl$Node@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@sl$Node@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1))"
    , "                            (injective@@sl$REQ@@sl$Node f1))"
    , "                       (= (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y)))"
    , "                          (union (set-diff@@sl$Node (ran@@sl$REQ@@sl$Node f1)"
    , "                                                    (mk-set@@sl$Node (apply@@sl$REQ@@sl$Node f1 x)))"
    , "                                 (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (and (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1))"
    , "                            (injective@@sl$REQ@@sl$OBJ f1))"
    , "                       (= (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y)))"
    , "                          (union (set-diff@@sl$OBJ (ran@@sl$REQ@@sl$OBJ f1)"
    , "                                                   (mk-set@@sl$OBJ (apply@@sl$REQ@@sl$OBJ f1 x)))"
    , "                                 (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$Node))"
    , "                  (x Int)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$Node f1)))"
    , "                       (= (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y)))"
    , "                          (union (ran@@Int@@sl$Node f1) (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$Node (ovl@@Int@@sl$Node f1 (mk-fun@@Int@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl$OBJ))"
    , "                  (x Int)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl$OBJ f1)))"
    , "                       (= (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y)))"
    , "                          (union (ran@@Int@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl$OBJ (ovl@@Int@@sl$OBJ f1 (mk-fun@@Int@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$Node))"
    , "                  (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (elem@@sl$Node x (dom@@sl$Node@@sl$Node f1)))"
    , "                       (= (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y)))"
    , "                          (union (ran@@sl$Node@@sl$Node f1) (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$Node (ovl@@sl$Node@@sl$Node f1 (mk-fun@@sl$Node@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$Node sl$OBJ))"
    , "                  (x sl$Node)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@sl$Node x (dom@@sl$Node@@sl$OBJ f1)))"
    , "                       (= (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y)))"
    , "                          (union (ran@@sl$Node@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$Node@@sl$OBJ (ovl@@sl$Node@@sl$OBJ f1 (mk-fun@@sl$Node@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$Node))"
    , "                  (x sl$REQ)"
    , "                  (y sl$Node) )"
    , "                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$Node f1)))"
    , "                       (= (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y)))"
    , "                          (union (ran@@sl$REQ@@sl$Node f1) (mk-set@@sl$Node y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$Node (ovl@@sl$REQ@@sl$Node f1 (mk-fun@@sl$REQ@@sl$Node x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl$REQ sl$OBJ))"
    , "                  (x sl$REQ)"
    , "                  (y sl$OBJ) )"
    , "                (! (=> (not (elem@@sl$REQ x (dom@@sl$REQ@@sl$OBJ f1)))"
    , "                       (= (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y)))"
    , "                          (union (ran@@sl$REQ@@sl$OBJ f1) (mk-set@@sl$OBJ y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl$REQ@@sl$OBJ (ovl@@sl$REQ@@sl$OBJ f1 (mk-fun@@sl$REQ@@sl$OBJ x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Node))"
    , "                  (y (pfun Int sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$Node@Close x (mk-set@Open@@pfun@@Int@@sl$Node@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$Node@Close x (mk-set@Open@@pfun@@Int@@sl$Node@Close y)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ))"
    , "                  (y (pfun Int sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl$OBJ@Close x (mk-set@Open@@pfun@@Int@@sl$OBJ@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl$OBJ@Close x (mk-set@Open@@pfun@@Int@@sl$OBJ@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$Node))"
    , "                  (y (pfun sl$Node sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$Node@Close x (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$Node@Close x (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$OBJ))"
    , "                  (y (pfun sl$Node sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$Node))"
    , "                  (y (pfun sl$REQ sl$Node)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$Node@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$Node@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close y)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ))"
    , "                  (y (pfun sl$REQ sl$OBJ)) )"
    , "                (! (= (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close x (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close y)) ))))"
    , "(assert (forall ( (x sl$Node)"
    , "                  (y sl$Node) )"
    , "                (! (= (elem@@sl$Node x (mk-set@@sl$Node y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$Node x (mk-set@@sl$Node y)) ))))"
    , "(assert (forall ( (x sl$OBJ)"
    , "                  (y sl$OBJ) )"
    , "                (! (= (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$OBJ x (mk-set@@sl$OBJ y)) ))))"
    , "(assert (forall ( (x sl$REQ)"
    , "                  (y sl$REQ) )"
    , "                (! (= (elem@@sl$REQ x (mk-set@@sl$REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl$REQ x (mk-set@@sl$REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Node)))"
    , "                  (s2 (set (pfun Int sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$Node@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$Node@Close (set-diff@Open@@pfun@@Int@@sl$Node@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (set-diff@Open@@pfun@@Int@@sl$Node@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (set-diff@Open@@pfun@@Int@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$Node)))"
    , "                  (s2 (set (pfun sl$Node sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Node@@sl$Node@Close s1)"
    , "                       (finite@Open@@pfun@@sl$Node@@sl$Node@Close (set-diff@Open@@pfun@@sl$Node@@sl$Node@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (set-diff@Open@@pfun@@sl$Node@@sl$Node@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$OBJ)))"
    , "                  (s2 (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s1)"
    , "                       (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$Node@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$Node)))"
    , "                  (s2 (set (pfun sl$REQ sl$Node))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s1)"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (set-diff@Open@@pfun@@sl$REQ@@sl$Node@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (set-diff@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (=> (finite@@sl$Node s1)"
    , "                       (finite@@sl$Node (set-diff@@sl$Node s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (set-diff@@sl$Node s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (finite@@sl$OBJ s1)"
    , "                       (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (set-diff@@sl$OBJ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (finite@@sl$REQ s1)"
    , "                       (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (set-diff@@sl$REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Node)))"
    , "                  (s2 (set (pfun Int sl$Node))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$Node@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$Node@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$Node@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl$OBJ@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl$OBJ@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$Node)))"
    , "                  (s2 (set (pfun sl$Node sl$Node))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$Node@@sl$Node@Close s1)"
    , "                            (finite@Open@@pfun@@sl$Node@@sl$Node@Close s2))"
    , "                       (finite@Open@@pfun@@sl$Node@@sl$Node@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$OBJ)))"
    , "                  (s2 (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s1)"
    , "                            (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s2))"
    , "                       (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$Node)))"
    , "                  (s2 (set (pfun sl$REQ sl$Node))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s1)"
    , "                            (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s2))"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (and (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)"
    , "                            (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2))"
    , "                       (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (=> (and (finite@@sl$Node s1) (finite@@sl$Node s2))"
    , "                       (finite@@sl$Node (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (and (finite@@sl$OBJ s1) (finite@@sl$OBJ s2))"
    , "                       (finite@@sl$OBJ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (and (finite@@sl$REQ s1) (finite@@sl$REQ s2))"
    , "                       (finite@@sl$REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$Node)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Node@Close (mk-set@Open@@pfun@@Int@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun Int sl$OBJ)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close (mk-set@Open@@pfun@@Int@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$Node)) )"
    , "                (! (finite@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close (mk-set@Open@@pfun@@sl$Node@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$Node sl$OBJ)) )"
    , "                (! (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$Node@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$Node)) )"
    , "                (! (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close (mk-set@Open@@pfun@@sl$REQ@@sl$Node@Close x)) ))))"
    , "(assert (forall ( (x (pfun sl$REQ sl$OBJ)) )"
    , "                (! (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close (mk-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close x)) ))))"
    , "(assert (forall ( (x sl$Node) )"
    , "                (! (finite@@sl$Node (mk-set@@sl$Node x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node (mk-set@@sl$Node x)) ))))"
    , "(assert (forall ( (x sl$OBJ) )"
    , "                (! (finite@@sl$OBJ (mk-set@@sl$OBJ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ (mk-set@@sl$OBJ x)) ))))"
    , "(assert (forall ( (x sl$REQ) )"
    , "                (! (finite@@sl$REQ (mk-set@@sl$REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ (mk-set@@sl$REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl$Node@Close empty-set@Open@@pfun@@Int@@sl$Node@Close))"
    , "(assert (finite@Open@@pfun@@Int@@sl$OBJ@Close empty-set@Open@@pfun@@Int@@sl$OBJ@Close))"
    , "(assert (finite@Open@@pfun@@sl$Node@@sl$Node@Close empty-set@Open@@pfun@@sl$Node@@sl$Node@Close))"
    , "(assert (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close empty-set@Open@@pfun@@sl$Node@@sl$OBJ@Close))"
    , "(assert (finite@Open@@pfun@@sl$REQ@@sl$Node@Close empty-set@Open@@pfun@@sl$REQ@@sl$Node@Close))"
    , "(assert (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close empty-set@Open@@pfun@@sl$REQ@@sl$OBJ@Close))"
    , "(assert (finite@@sl$Node empty-set@@sl$Node))"
    , "(assert (finite@@sl$OBJ empty-set@@sl$OBJ))"
    , "(assert (finite@@sl$REQ empty-set@@sl$REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$Node)))"
    , "                  (s2 (set (pfun Int sl$Node))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl$Node@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl$Node@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$Node@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl$Node@Close s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl$OBJ)))"
    , "                  (s2 (set (pfun Int sl$OBJ))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl$OBJ@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl$OBJ@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl$OBJ@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl$OBJ@Close s1) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$Node)))"
    , "                  (s2 (set (pfun sl$Node sl$Node))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@sl$Node@@sl$Node@Close s2)"
    , "                           (finite@Open@@pfun@@sl$Node@@sl$Node@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$Node@Close s2)"
    , "                     (finite@Open@@pfun@@sl$Node@@sl$Node@Close s1) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$Node sl$OBJ)))"
    , "                  (s2 (set (pfun sl$Node sl$OBJ))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s2)"
    , "                           (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s2)"
    , "                     (finite@Open@@pfun@@sl$Node@@sl$OBJ@Close s1) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$Node)))"
    , "                  (s2 (set (pfun sl$REQ sl$Node))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s2)"
    , "                           (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s2)"
    , "                     (finite@Open@@pfun@@sl$REQ@@sl$Node@Close s1) ))))"
    , "(assert (forall ( (s1 (set (pfun sl$REQ sl$OBJ)))"
    , "                  (s2 (set (pfun sl$REQ sl$OBJ))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2)"
    , "                           (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s2)"
    , "                     (finite@Open@@pfun@@sl$REQ@@sl$OBJ@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl$Node))"
    , "                  (s2 (set sl$Node)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$Node s2) (finite@@sl$Node s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$Node s2)"
    , "                     (finite@@sl$Node s1) ))))"
    , "(assert (forall ( (s1 (set sl$OBJ))"
    , "                  (s2 (set sl$OBJ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$OBJ s2) (finite@@sl$OBJ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$OBJ s2)"
    , "                     (finite@@sl$OBJ s1) ))))"
    , "(assert (forall ( (s1 (set sl$REQ))"
    , "                  (s2 (set sl$REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl$REQ s2) (finite@@sl$REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl$REQ s2)"
    , "                     (finite@@sl$REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (between x y z) (and (<= x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (between x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenR x y z) (and (<= x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenL x y z) (and (< x y) (<= y z)))"
    , "                   :pattern"
    , "                   ( (betweenL x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int)"
    , "                  (z Int) )"
    , "                (! (= (betweenLR x y z) (and (< x y) (< y z)))"
    , "                   :pattern"
    , "                   ( (betweenLR x y z) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "; m2:inv0"
    , "(assert (= (union (union (union pshL pshR) popL) popR) req))"
    , "; m2:inv1"
    , "(assert (= (intersect pshL pshR) empty-set@@sl$REQ))"
    , "; m2:inv2"
    , "(assert (= (intersect pshL popL) empty-set@@sl$REQ))"
    , "; m2:inv3"
    , "(assert (= (intersect pshL popR) empty-set@@sl$REQ))"
    , "; m2:inv4"
    , "(assert (= (intersect pshR popL) empty-set@@sl$REQ))"
    , "; m2:inv5"
    , "(assert (= (intersect pshR popR) empty-set@@sl$REQ))"
    , "; m2:inv6"
    , "(assert (= (intersect popL popR) empty-set@@sl$REQ))"
    , "; m3:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$OBJ@Close qe (tfun@@Int@@sl$OBJ (intervalR p q) sl$OBJ)))"
    , "; m3:inv1"
    , "(assert (<= p q))"
    , "; m3:inv2"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close insL (tfun@@sl$REQ@@sl$OBJ pshL sl$OBJ)))"
    , "; m3:inv3"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close insR (tfun@@sl$REQ@@sl$OBJ pshR sl$OBJ)))"
    , "; m3:inv4"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$OBJ@Close res (pfun@@sl$REQ@@sl$OBJ ppd sl$OBJ)))"
    , "; m4:asm0"
    , "(assert (not (finite@@sl$Node sl$Node)))"
    , "; m4:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl$Node@Close rep (tfun@@Int@@sl$Node (intervalR p q) node)))"
    , "; m4:inv1"
    , "(assert (elem@Open@@pfun@@sl$Node@@sl$OBJ@Close item (tfun@@sl$Node@@sl$OBJ node sl$OBJ)))"
    , "; m4:inv10"
    , "(assert (not (elem@@sl$Node dummy (ran@@Int@@sl$Node rep))))"
    , "; m4:inv11"
    , "(assert (not (elem@@sl$Node dummy (ran@@sl$REQ@@sl$Node nL))))"
    , "; m4:inv12"
    , "(assert (not (elem@@sl$Node dummy (ran@@sl$REQ@@sl$Node nR))))"
    , "; m4:inv3"
    , "(assert (forall ( (i Int) )"
    , "                (! (=> (betweenR p i q)"
    , "                       (= (apply@@Int@@sl$OBJ qe i)"
    , "                          (apply@@sl$Node@@sl$OBJ item (apply@@Int@@sl$Node rep i))))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl$OBJ qe i) ))))"
    , "; m4:inv4"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$Node@Close nL (pfun@@sl$REQ@@sl$Node pshL node)))"
    , "; m4:inv5"
    , "(assert (elem@Open@@pfun@@sl$REQ@@sl$Node@Close nR (pfun@@sl$REQ@@sl$Node pshR node)))"
    , "; m4:inv6"
    , "(assert (forall ( (r sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ r (dom@@sl$REQ@@sl$Node nL))"
    , "                       (= (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nL r))"
    , "                          (apply@@sl$REQ@@sl$OBJ insL r)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nL r)) ))))"
    , "; m4:inv7"
    , "(assert (forall ( (r sl$REQ) )"
    , "                (! (=> (elem@@sl$REQ r (dom@@sl$REQ@@sl$Node nR))"
    , "                       (= (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nR r))"
    , "                          (apply@@sl$REQ@@sl$OBJ insR r)))"
    , "                   :pattern"
    , "                   ( (apply@@sl$Node@@sl$OBJ item (apply@@sl$REQ@@sl$Node nR r)) ))))"
    , "; m4:inv8"
    , "(assert (finite@@sl$Node node))"
    , "; m4:inv9"
    , "(assert (elem@@sl$Node dummy node))"
    , "(assert (not (=> (and (elem@Open@@pfun@@sl$Node@@sl$Node@Close left (tfun@@sl$Node@@sl$Node node node))"
    , "                      (elem@Open@@pfun@@sl$Node@@sl$Node@Close right (tfun@@sl$Node@@sl$Node node node))"
    , "                      (=> (= p q) (and (= LH dummy) (= RH dummy))))"
    , "                 (or (and (or (not (< p q))"
    , "                              (and (= LH (apply@@Int@@sl$Node rep p))"
    , "                                   (elem@@Int p (dom@@Int@@sl$Node rep))"
    , "                                   (= RH (apply@@Int@@sl$Node rep (- q 1)))"
    , "                                   (elem@@Int (- q 1) (dom@@Int@@sl$Node rep))))"
    , "                          (= (apply@@sl$Node@@sl$Node left dummy) dummy)"
    , "                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node left))"
    , "                          (= (apply@@sl$Node@@sl$Node right dummy) dummy)"
    , "                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node right))"
    , "                          (forall ( (i Int) )"
    , "                                  (=> true"
    , "                                      (or (not (betweenR p i (- q 1)))"
    , "                                          (and (= (apply@@sl$Node@@sl$Node right (apply@@Int@@sl$Node rep i))"
    , "                                                  (apply@@Int@@sl$Node rep (+ i 1)))"
    , "                                               (elem@@sl$Node (apply@@Int@@sl$Node rep i)"
    , "                                                              (dom@@sl$Node@@sl$Node right))"
    , "                                               (elem@@Int i (dom@@Int@@sl$Node rep))"
    , "                                               (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep))))))"
    , "                          (forall ( (i Int) )"
    , "                                  (=> true"
    , "                                      (or (not (betweenR p i (- q 1)))"
    , "                                          (and (= (apply@@sl$Node@@sl$Node left (apply@@Int@@sl$Node rep (+ i 1)))"
    , "                                                  (apply@@Int@@sl$Node rep i))"
    , "                                               (elem@@sl$Node (apply@@Int@@sl$Node rep (+ i 1))"
    , "                                                              (dom@@sl$Node@@sl$Node left))"
    , "                                               (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep))"
    , "                                               (elem@@Int i (dom@@Int@@sl$Node rep))))))"
    , "                          (= (apply@@sl$Node@@sl$Node left LH) dummy)"
    , "                          (elem@@sl$Node LH (dom@@sl$Node@@sl$Node left))"
    , "                          (= (apply@@sl$Node@@sl$Node right RH) dummy)"
    , "                          (elem@@sl$Node RH (dom@@sl$Node@@sl$Node right)))"
    , "                     (and (< p q)"
    , "                          (or (and (not (= LH (apply@@Int@@sl$Node rep p)))"
    , "                                   (elem@@Int p (dom@@Int@@sl$Node rep)))"
    , "                              (and (not (= RH (apply@@Int@@sl$Node rep (- q 1))))"
    , "                                   (elem@@Int (- q 1) (dom@@Int@@sl$Node rep)))))"
    , "                     (and (not (= (apply@@sl$Node@@sl$Node left dummy) dummy))"
    , "                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node left)))"
    , "                     (and (not (= (apply@@sl$Node@@sl$Node right dummy) dummy))"
    , "                          (elem@@sl$Node dummy (dom@@sl$Node@@sl$Node right)))"
    , "                     (exists ( (i Int) )"
    , "                             (and true"
    , "                                  (and (betweenR p i (- q 1))"
    , "                                       (not (= (apply@@sl$Node@@sl$Node right (apply@@Int@@sl$Node rep i))"
    , "                                               (apply@@Int@@sl$Node rep (+ i 1))))"
    , "                                       (elem@@sl$Node (apply@@Int@@sl$Node rep i)"
    , "                                                      (dom@@sl$Node@@sl$Node right))"
    , "                                       (elem@@Int i (dom@@Int@@sl$Node rep))"
    , "                                       (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep)))))"
    , "                     (exists ( (i Int) )"
    , "                             (and true"
    , "                                  (and (betweenR p i (- q 1))"
    , "                                       (not (= (apply@@sl$Node@@sl$Node left (apply@@Int@@sl$Node rep (+ i 1)))"
    , "                                               (apply@@Int@@sl$Node rep i)))"
    , "                                       (elem@@sl$Node (apply@@Int@@sl$Node rep (+ i 1))"
    , "                                                      (dom@@sl$Node@@sl$Node left))"
    , "                                       (elem@@Int (+ i 1) (dom@@Int@@sl$Node rep))"
    , "                                       (elem@@Int i (dom@@Int@@sl$Node rep)))))"
    , "                     (and (not (= (apply@@sl$Node@@sl$Node left LH) dummy))"
    , "                          (elem@@sl$Node LH (dom@@sl$Node@@sl$Node left)))"
    , "                     (and (not (= (apply@@sl$Node@@sl$Node right RH) dummy))"
    , "                          (elem@@sl$Node RH (dom@@sl$Node@@sl$Node right)))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m5/INV/WD"
    ]
