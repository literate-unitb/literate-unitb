(echo "> m1/INIT/FIS")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-fun @@lambda@@_0 (Bool Int) (Array P (Maybe Int)))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (forall ( (@@fv@@_0 Bool)
                  (@@fv@@_1 Int)
                  (@@bv@@_0 P) )
                (=> true
                    (= (select (@@lambda@@_0 @@fv@@_0 @@fv@@_1) @@bv@@_0)
                       (ite @@fv@@_0 (Just @@fv@@_1) Nothing)))))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (not (exists ( (pc (pfun P Int)) )
                     (and true (= pc (@@lambda@@_0 true 0))))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/INIT/FIS
(echo "> m1/INIT/INV/inv0")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-fun @@lambda@@_0 (Bool Int) (Array P (Maybe Int)))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (forall ( (@@fv@@_0 Bool)
                  (@@fv@@_1 Int)
                  (@@bv@@_0 P) )
                (=> true
                    (= (select (@@lambda@@_0 @@fv@@_0 @@fv@@_1) @@bv@@_0)
                       (ite @@fv@@_0 (Just @@fv@@_1) Nothing)))))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (= pc (@@lambda@@_0 true 0)))
(assert (not (forall ( (p_0 P)
                       (p_1 P) )
                     (=> true
                         (<= (apply@@P@@Int pc p_0)
                             (+ (apply@@P@@Int pc p_1) 1))))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/INIT/INV/inv0
(echo "> m1/step/FIS")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (forall ( (p_0 P)
                  (p_1 P) )
                (=> true
                    (<= (apply@@P@@Int pc p_0)
                        (+ (apply@@P@@Int pc p_1) 1)))))
(assert (forall ( (p_0 P) )
                (=> true
                    (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_0)))))
(assert (not (exists ( (pc@prime (pfun P Int)) )
                     (and true
                          (= pc@prime
                             (ovl@@P@@Int pc (mk-fun@@P@@Int p (+ (apply@@P@@Int pc p) 1))))))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/FIS
(echo "> m1/step/INV/inv0/case 1/easy (155,2)")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-const pc@prime (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (= p p_1))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (forall ( (p_0 P)
                  (p_1 P) )
                (=> true
                    (<= (apply@@P@@Int pc p_0)
                        (+ (apply@@P@@Int pc p_1) 1)))))
(assert (forall ( (p_0 P) )
                (=> true
                    (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_0)))))
(assert (= pc@prime
           (ovl@@P@@Int pc (mk-fun@@P@@Int p (+ (apply@@P@@Int pc p) 1)))))
(assert (not (<= (apply@@P@@Int pc@prime p_0)
                 (+ (apply@@P@@Int pc@prime p_1) 1))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/INV/inv0/case 1/easy (155,2)
(echo "> m1/step/INV/inv0/case 2/goal (158,51)")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-const pc@prime (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (= (<= (apply@@P@@Int pc@prime p_0)
               (+ (apply@@P@@Int pc@prime p_1) 1))
           true))
(assert (not (<= (apply@@P@@Int pc@prime p_0)
                 (+ (apply@@P@@Int pc@prime p_1) 1))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/INV/inv0/case 2/goal (158,51)
(echo "> m1/step/INV/inv0/case 2/hypotheses (158,51)")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-const pc@prime (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (and (not (= p p_1)) (= p p_0)))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (forall ( (p_0 P)
                  (p_1 P) )
                (=> true
                    (<= (apply@@P@@Int pc p_0)
                        (+ (apply@@P@@Int pc p_1) 1)))))
(assert (forall ( (p_0 P) )
                (=> true
                    (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_0)))))
(assert (= pc@prime
           (ovl@@P@@Int pc (mk-fun@@P@@Int p (+ (apply@@P@@Int pc p) 1)))))
(assert (not (and (= pc@prime
                     (ovl@@P@@Int pc (mk-fun@@P@@Int p (+ (apply@@P@@Int pc p) 1))))
                  (not (= p p_1))
                  (= p p_0)
                  (forall ( (p_0 P) )
                          (=> true
                              (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_0)))))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/INV/inv0/case 2/hypotheses (158,51)
(echo "> m1/step/INV/inv0/case 2/relation (158,51)")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-const pc@prime (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (= (<= (apply@@P@@Int pc@prime p_0)
               (+ (apply@@P@@Int pc@prime p_1) 1))
           (<= (+ (apply@@P@@Int pc p) 1)
               (+ (apply@@P@@Int pc p_1) 1))))
(assert (= (<= (+ (apply@@P@@Int pc p) 1)
               (+ (apply@@P@@Int pc p_1) 1))
           (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_1))))
(assert (= (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_1))
           true))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (not (= (<= (apply@@P@@Int pc@prime p_0)
                    (+ (apply@@P@@Int pc@prime p_1) 1))
                true)))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/INV/inv0/case 2/relation (158,51)
(echo "> m1/step/INV/inv0/case 2/step (161,1)")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-const pc@prime (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (= pc@prime
           (ovl@@P@@Int pc (mk-fun@@P@@Int p (+ (apply@@P@@Int pc p) 1)))))
(assert (and (not (= p p_1)) (= p p_0)))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (not (= (<= (apply@@P@@Int pc@prime p_0)
                    (+ (apply@@P@@Int pc@prime p_1) 1))
                (<= (+ (apply@@P@@Int pc p) 1)
                    (+ (apply@@P@@Int pc p_1) 1)))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/INV/inv0/case 2/step (161,1)
(echo "> m1/step/INV/inv0/case 2/step (163,1)")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-const pc@prime (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (not (= (<= (+ (apply@@P@@Int pc p) 1)
                    (+ (apply@@P@@Int pc p_1) 1))
                (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_1)))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/INV/inv0/case 2/step (163,1)
(echo "> m1/step/INV/inv0/case 2/step (165,1)")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-const pc@prime (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (forall ( (p_0 P) )
                (=> true
                    (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_0)))))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (not (= (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_1))
                true)))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/INV/inv0/case 2/step (165,1)
(echo "> m1/step/INV/inv0/case 3/easy (170,2)")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-const pc@prime (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (and (not (= p p_1)) (not (= p p_0))))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (forall ( (p_0 P)
                  (p_1 P) )
                (=> true
                    (<= (apply@@P@@Int pc p_0)
                        (+ (apply@@P@@Int pc p_1) 1)))))
(assert (forall ( (p_0 P) )
                (=> true
                    (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_0)))))
(assert (= pc@prime
           (ovl@@P@@Int pc (mk-fun@@P@@Int p (+ (apply@@P@@Int pc p) 1)))))
(assert (not (<= (apply@@P@@Int pc@prime p_0)
                 (+ (apply@@P@@Int pc@prime p_1) 1))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/INV/inv0/case 3/easy (170,2)
(echo "> m1/step/INV/inv0/completeness (152,1)")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-const pc@prime (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (forall ( (p_0 P)
                  (p_1 P) )
                (=> true
                    (<= (apply@@P@@Int pc p_0)
                        (+ (apply@@P@@Int pc p_1) 1)))))
(assert (forall ( (p_0 P) )
                (=> true
                    (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_0)))))
(assert (= pc@prime
           (ovl@@P@@Int pc (mk-fun@@P@@Int p (+ (apply@@P@@Int pc p) 1)))))
(assert (not (or (= p p_1)
                 (and (not (= p p_1)) (= p p_0))
                 (and (not (= p p_1)) (not (= p p_0))))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/INV/inv0/completeness (152,1)
(echo "> m1/step/SCH")
(push)
(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))
(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))
(declare-datatypes () ( (Null null) ))
; comment: we don't need to declare the sort Bool
; comment: we don't need to declare the sort Int
(declare-sort P 0)
; comment: we don't need to declare the sort Real
(define-sort pfun (a b) (Array a (Maybe b)))
(define-sort set (a) (Array a Bool))
(declare-const N Int)
(declare-const P (set P))
(declare-const k Int)
(declare-const p P)
(declare-const p_0 P)
(declare-const p_1 P)
(declare-const pc (pfun P Int))
(declare-fun apply@@P@@Int ( (pfun P Int)   P ) Int)
(declare-fun dom-rest@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom-subt@@P@@Int
             ( (set P)
               (pfun P Int) )
             (pfun P Int))
(declare-fun dom@@P@@Int ( (pfun P Int) ) (set P))
(declare-fun elem@@Int (Int (set Int)) Bool)
(declare-fun elem@@P (P (set P)) Bool)
(declare-fun elem@Open@@pfun@@P@@Int@Close
             ( (pfun P Int)
               (set (pfun P Int)) )
             Bool)
(declare-fun empty-fun@@P@@Int () (pfun P Int))
(declare-fun empty-set@@Int () (set Int))
(declare-fun empty-set@@P () (set P))
(declare-fun empty-set@Open@@pfun@@P@@Int@Close
             ()
             (set (pfun P Int)))
(declare-fun intersect@@Int
             ( (set Int)
               (set Int) )
             (set Int))
(declare-fun intersect@@P ( (set P)   (set P) ) (set P))
(declare-fun intersect@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun mk-fun@@P@@Int (P Int) (pfun P Int))
(declare-fun mk-set@@Int (Int) (set Int))
(declare-fun mk-set@@P (P) (set P))
(declare-fun mk-set@Open@@pfun@@P@@Int@Close
             ( (pfun P Int) )
             (set (pfun P Int)))
(declare-fun ovl@@P@@Int
             ( (pfun P Int)
               (pfun P Int) )
             (pfun P Int))
(declare-fun set-diff@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun set-diff@@P ( (set P)   (set P) ) (set P))
(declare-fun set-diff@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(declare-fun set@@P@@Int ( (pfun P Int) ) (set Int))
(declare-fun tfun@@P@@Int
             ( (set P)
               (set Int) )
             (set (pfun P Int)))
(declare-fun bunion@@Int ( (set Int)   (set Int) ) (set Int))
(declare-fun bunion@@P ( (set P)   (set P) ) (set P))
(declare-fun bunion@Open@@pfun@@P@@Int@Close
             ( (set (pfun P Int))
               (set (pfun P Int)) )
             (set (pfun P Int)))
(assert (forall ( (x Int)
                  (y Int) )
                (=> true (= (elem@@Int x (mk-set@@Int y)) (= x y)))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (set-diff@@Int s1 s2))
                       (and (elem@@Int x s1) (not (elem@@Int x s2)))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (intersect@@Int s1 s2))
                       (and (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int)
                  (s1 (set Int))
                  (s2 (set Int)) )
                (=> true
                    (= (elem@@Int x (bunion@@Int s1 s2))
                       (or (elem@@Int x s1) (elem@@Int x s2))))))
(assert (forall ( (x Int) )
                (=> true (not (elem@@Int x empty-set@@Int)))))
(assert (forall ( (x Int)
                  (s1 (set Int)) )
                (=> true (= (elem@@Int x s1) (select s1 x)))))
(assert (forall ( (x P)
                  (y P) )
                (=> true (= (elem@@P x (mk-set@@P y)) (= x y)))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (set-diff@@P s1 s2))
                       (and (elem@@P x s1) (not (elem@@P x s2)))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (intersect@@P s1 s2))
                       (and (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P)
                  (s1 (set P))
                  (s2 (set P)) )
                (=> true
                    (= (elem@@P x (bunion@@P s1 s2))
                       (or (elem@@P x s1) (elem@@P x s2))))))
(assert (forall ( (x P) )
                (=> true (not (elem@@P x empty-set@@P)))))
(assert (forall ( (x P)
                  (s1 (set P)) )
                (=> true (= (elem@@P x s1) (select s1 x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (bunion@@P (dom@@P@@Int f1) (dom@@P@@Int f2))
                       (dom@@P@@Int (ovl@@P@@Int f1 f2))))))
(assert (= (dom@@P@@Int empty-fun@@P@@Int) empty-set@@P))
(assert (forall ( (x P)
                  (y Int) )
                (=> true
                    (= (dom@@P@@Int (mk-fun@@P@@Int x y)) (mk-set@@P x)))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (dom@@P@@Int f2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f2 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (f2 (pfun P Int))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) (dom@@P@@Int f2)))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 f2) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P)) )
                (=> true
                    (= (dom@@P@@Int (dom-subt@@P@@Int s1 f1))
                       (set-diff@@P (dom@@P@@Int f1) s1)))))
(assert (forall ( (x P)
                  (y Int) )
                (=> true (= (apply@@P@@Int (mk-fun@@P@@Int x y) x) y))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (intersect@@P s1 (dom@@P@@Int f1)))
                        (= (apply@@P@@Int (dom-rest@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (f1 (pfun P Int))
                  (s1 (set P))
                  (x P) )
                (=> true
                    (=> (elem@@P x (set-diff@@P (dom@@P@@Int f1) s1))
                        (= (apply@@P@@Int (dom-subt@@P@@Int s1 f1) x)
                           (apply@@P@@Int f1 x))))))
(assert (forall ( (x P) )
                (=> true (= (select empty-fun@@P@@Int x) Nothing))))
(assert (forall ( (x P)
                  (x2 P)
                  (y Int) )
                (=> true
                    (= (select (mk-fun@@P@@Int x y) x2)
                       (ite (= x x2) (Just y) Nothing)))))
(assert (forall ( (x P)
                  (f1 (pfun P Int))
                  (f2 (pfun P Int)) )
                (=> true
                    (= (select (ovl@@P@@Int f1 f2) x)
                       (ite (= (select f1 x) Nothing)
                            (select f2 x)
                            (select f1 x))))))
(assert (forall ( (x P)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (select (dom@@P@@Int f1) x)
                       (not (= (select f1 x) Nothing))))))
(assert (forall ( (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (elem@@Int y (set@@P@@Int f1))
                       (exists ( (x P) )
                               (and (elem@@P x (dom@@P@@Int f1))
                                    (= (apply@@P@@Int f1 x) y)))))))
(assert (forall ( (x P)
                  (y Int)
                  (f1 (pfun P Int)) )
                (=> true
                    (= (and (elem@@P x (dom@@P@@Int f1))
                            (= (apply@@P@@Int f1 x) y))
                       (= (select f1 x) (Just y))))))
(assert (forall ( (f1 (pfun P Int))
                  (x2 P)
                  (x P)
                  (y Int) )
                (=> true
                    (=> (not (= x x2))
                        (= (apply@@P@@Int (ovl@@P@@Int f1 (mk-fun@@P@@Int x y)) x2)
                           (apply@@P@@Int f1 x2))))))
(assert (forall ( (x (pfun P Int))
                  (y (pfun P Int)) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (mk-set@Open@@pfun@@P@@Int@Close y))
                       (= x y)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (set-diff@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (not (elem@Open@@pfun@@P@@Int@Close x s2)))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (intersect@Open@@pfun@@P@@Int@Close s1 s2))
                       (and (elem@Open@@pfun@@P@@Int@Close x s1)
                            (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int)))
                  (s2 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x (bunion@Open@@pfun@@P@@Int@Close s1 s2))
                       (or (elem@Open@@pfun@@P@@Int@Close x s1)
                           (elem@Open@@pfun@@P@@Int@Close x s2))))))
(assert (forall ( (x (pfun P Int)) )
                (=> true
                    (not (elem@Open@@pfun@@P@@Int@Close x empty-set@Open@@pfun@@P@@Int@Close)))))
(assert (forall ( (x (pfun P Int))
                  (s1 (set (pfun P Int))) )
                (=> true
                    (= (elem@Open@@pfun@@P@@Int@Close x s1)
                       (select s1 x)))))
(assert (forall ( (x@@ P) ) (=> true (elem@@P x@@ P))))
(assert (forall ( (p_0 P)
                  (p_1 P) )
                (=> true
                    (<= (apply@@P@@Int pc p_0)
                        (+ (apply@@P@@Int pc p_1) 1)))))
(assert true)
(assert (not (forall ( (p_0 P) )
                     (=> true
                         (<= (apply@@P@@Int pc p) (apply@@P@@Int pc p_0))))))
(check-sat-using (or-else (then qe smt)
                          (then simplify smt)
                          (then skip smt)
                          (then (using-params simplify :expand-power true) smt)))

(pop)
; end of m1/step/SCH
