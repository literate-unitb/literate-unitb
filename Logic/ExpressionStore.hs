{-# LANGUAGE FlexibleContexts #-}
module Logic.ExpressionStore 
    ( ExprStore, insert, empty_store, get_string )
where

    -- Modules
import Logic.Expr
import Logic.Expr.TypeChecking

    -- Libraries
import Control.DeepSeq
import Data.Map as M ( insertWith, Map, empty, lookup ) --, (!) )

newtype ExprStore = ExprStore { getMap :: Map UntypedExpr [String] }
    deriving Eq

instance NFData ExprStore where
    rnf (ExprStore x) = rnf x

empty_store :: ExprStore
empty_store = ExprStore empty

insert :: Expr -> String -> ExprStore -> ExprStore
insert e str (ExprStore st) = ExprStore $ insertWith (++) (stripTypes e) [str] st

get_string :: ExprStore -> Expr -> String
get_string es e = maybe (to_latex e) head $ (M.lookup $ stripTypes e) $ getMap es

--(!) x y = maybe (error $ "ExprStore: expression not found: " ++ show y) id $ M.lookup y x

generated_by :: String
generated_by = "" --  % this is generated by Literate Unit-B"

to_latex :: Expr -> String
to_latex (FunApp (Fun _ "=" _ _) [Word (Var x _),Word (Var y _)])
        = primed x ++ " = " ++ primed y ++ generated_by
    where
        prime = "@prime"
        primed x
                | suffix == prime = prefix ++ "'"
                | otherwise       = x
            where
                (prefix, suffix) = splitAt (length x - length prime) x
to_latex e 
    | e == zfalse = "\\false " ++ generated_by
    | otherwise   = error $ "ExprStore.to_latex: cannot convert expression to LaTeX: " ++ show e
