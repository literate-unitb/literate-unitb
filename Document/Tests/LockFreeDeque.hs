module Document.Tests.LockFreeDeque 
    -- ( test_case, test, path4, result4 )
where

    -- Modules
import Document.Document
import Document.Tests.Suite

    -- Libraries
import Utilities.Syntactic

import Tests.UnitTest

test_case :: TestCase
test_case = Case "Specification and refinement of a lock-free algorithm" test True

test :: IO Bool
test = test_cases
            [ (POCase "test 0, verification, specification with intervals" 
                (verify path0 0) result0)
            , (POCase "test 1, verification, failed proof with intervals" 
                (verify path1 0) result1)
            , (StringCase "test 2, error message name clash in guards" 
                case2 result2)
            , (POCase "test 3, verification, looking up function outside of domain" 
                (verify path3 0) result3)
            , (POCase "test 4, m1, liveness implemented with conditional behavior"
                (verify path4 1) result4)
            , (StringCase "test 5, transient, two branches, enablement of non-empty"
                (proof_obligation path4 "m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:non:empty/EN" 1)
                result5)
            , (StringCase "test 6, transient, two branches, enablement of empty"
                (proof_obligation path4 "m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:empty/EN" 1)
                result6)
            , (StringCase "test 7, transient, two branches, negation of empty"
                (proof_obligation path4 "m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:empty/NEG" 1)
                result7)
            , (StringCase "test 8, transient, two branches, negation of non-empty"
                (proof_obligation path4 "m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:empty/NEG" 1)
                result8)
            , (StringCase "test 9, transient, two branches, follow and disjunction"
                (proof_obligation path4 "m1/m1:prog3/REF/ensure/m1/TR/leadsto" 1)
                result9)
            , (StringCase "test 10, duplicate refinement of liveness properties"
                (find_errors path10)
                result10)
            ]            

result0 :: String
result0 = unlines
    [ "  o  m0/INIT/FIS/emp"
    , "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/FIS/res"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/INIT/WD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/emp@prime"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/FIS/res@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/INV/m0:inv1"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act3"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act4"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , "  o  m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:right/FIS/emp@prime"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/FIS/res@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/INV/m0:inv1"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act3"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act4"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:push:left/FIS/emp@prime"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , "  o  m0/m0:push:left/FIS/res@prime"
    , "  o  m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/INV/m0:inv1"
    , "  o  m0/m0:push:left/SCH"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:right/FIS/emp@prime"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , "  o  m0/m0:push:right/FIS/res@prime"
    , "  o  m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/INV/m0:inv1"
    , "  o  m0/m0:push:right/SCH"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , "  o  m0/m0:push:right/WD/GRD"
    , "passed 65 / 65"
    ]

path0 :: FilePath
path0 = "tests/lock-free deque/main.tex"

path1 :: FilePath
path1 = "tests/lock-free deque/main2.tex"

result1 :: String
result1 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/WD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , "  o  m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , " xxx m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/SCH"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act2"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , " xxx m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/SCH"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act1"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , "  o  m0/m0:push:right/WD/GRD"
    , "passed 48 / 50"
    ]

path2 :: String
path2 = "tests/lock-free deque/main3.tex"

case2 :: IO String
case2 = do
        r <- parse_machine path2
        case r of
            Right _ -> do
                return "successful verification"
            Left xs -> return $ unlines $ map format_error xs


result2 :: String
result2 = unlines
    [ "error: Multiple expressions with the label m0:inv0"
    , "\tinvariant: (41,15)"
    , "\tinvariant: (44,3)"
    , ""
    , "error: Multiple expressions with the label m0:grd0"
    , "\tguard (event m0:pop:right): (86,3)"
    , "\tguard (event m0:pop:right): (87,3)"
    , ""
    ]

path3 :: String
path3 = "tests/lock-free deque/main4.tex"

result3 :: String
result3 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/INIT/WD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/INV/m0:inv1"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , " xxx m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/INV/m0:inv1"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , "  o  m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/INV/m0:inv1"
    , "  o  m0/m0:push:left/SCH"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act2"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , "  o  m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/INV/m0:inv1"
    , "  o  m0/m0:push:right/SCH"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act1"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , " xxx m0/m0:push:right/WD/GRD"
    , "passed 53 / 55"
    ]

path4 :: FilePath
path4 = "tests/lock-free deque/main6.tex"

result4 :: String
result4 = unlines
    [ "  o  m1/INIT/FIS/emp"
    , "  o  m1/INIT/FIS/p"
    , "  o  m1/INIT/FIS/popL"
    , "  o  m1/INIT/FIS/popR"
    , "  o  m1/INIT/FIS/pshL"
    , "  o  m1/INIT/FIS/pshR"
    , "  o  m1/INIT/FIS/q"
    , "  o  m1/INIT/FIS/qe"
    , "  o  m1/INIT/FIS/res"
    , "  o  m1/INIT/FIS/resL"
    , "  o  m1/INIT/FIS/resR"
    , "  o  m1/INIT/INV/m1:inv0"
    , "  o  m1/INIT/INV/m1:inv1"
    , "  o  m1/INIT/WD"
    , "  o  m1/INV/WD"
    , "  o  m1/m0:pop:left:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:left:empty/FIS/p@prime"
    , "  o  m1/m0:pop:left:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:left:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:left:empty/FIS/q@prime"
    , "  o  m1/m0:pop:left:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:left:empty/FIS/res@prime"
    , "  o  m1/m0:pop:left:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:left:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:left:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:left:empty/SCH"
    , "  o  m1/m0:pop:left:empty/SCH/m1/0/REF/replace/prog/leadsto"
    , "  o  m1/m0:pop:left:empty/SCH/m1/0/REF/replace/str"
    , "  o  m1/m0:pop:left:empty/SCH/m1/1/REF/weaken"
    , "  o  m1/m0:pop:left:empty/WD/ACT/m1:a4"
    , "  o  m1/m0:pop:left:empty/WD/C_SCH"
    , "  o  m1/m0:pop:left:empty/WD/F_SCH"
    , "  o  m1/m0:pop:left:empty/WD/GRD"
    , "  o  m1/m0:pop:left:non:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/p@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/q@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/res@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:left:non:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:left:non:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:left:non:empty/SCH"
    , "  o  m1/m0:pop:left:non:empty/SCH/m1/0/REF/replace/prog/leadsto"
    , "  o  m1/m0:pop:left:non:empty/SCH/m1/0/REF/replace/str"
    , "  o  m1/m0:pop:left:non:empty/SCH/m1/1/REF/weaken"
    , "  o  m1/m0:pop:left:non:empty/WD/ACT/m1:a4"
    , "  o  m1/m0:pop:left:non:empty/WD/ACT/m1:a5"
    , "  o  m1/m0:pop:left:non:empty/WD/C_SCH"
    , "  o  m1/m0:pop:left:non:empty/WD/F_SCH"
    , "  o  m1/m0:pop:left:non:empty/WD/GRD"
    , "  o  m1/m0:pop:right:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:right:empty/FIS/p@prime"
    , "  o  m1/m0:pop:right:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:right:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:right:empty/FIS/q@prime"
    , "  o  m1/m0:pop:right:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:right:empty/FIS/res@prime"
    , "  o  m1/m0:pop:right:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:right:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:right:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:right:empty/SCH"
    , "  o  m1/m0:pop:right:empty/SCH/m1/0/REF/replace/prog/leadsto"
    , "  o  m1/m0:pop:right:empty/SCH/m1/0/REF/replace/str"
    , "  o  m1/m0:pop:right:empty/SCH/m1/1/REF/weaken"
    , "  o  m1/m0:pop:right:empty/WD/ACT/m1:a2"
    , "  o  m1/m0:pop:right:empty/WD/C_SCH"
    , "  o  m1/m0:pop:right:empty/WD/F_SCH"
    , "  o  m1/m0:pop:right:empty/WD/GRD"
    , "  o  m1/m0:pop:right:non:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/p@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/q@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/res@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:right:non:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:right:non:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:right:non:empty/SCH"
    , "  o  m1/m0:pop:right:non:empty/SCH/m1/0/REF/replace/prog/leadsto"
    , "  o  m1/m0:pop:right:non:empty/SCH/m1/0/REF/replace/str"
    , "  o  m1/m0:pop:right:non:empty/SCH/m1/1/REF/weaken"
    , "  o  m1/m0:pop:right:non:empty/WD/ACT/m1:a2"
    , "  o  m1/m0:pop:right:non:empty/WD/ACT/m1:a3"
    , "  o  m1/m0:pop:right:non:empty/WD/C_SCH"
    , "  o  m1/m0:pop:right:non:empty/WD/F_SCH"
    , "  o  m1/m0:pop:right:non:empty/WD/GRD"
    , "  o  m1/m0:push:left/FIS/emp@prime"
    , "  o  m1/m0:push:left/FIS/p@prime"
    , "  o  m1/m0:push:left/FIS/popL@prime"
    , "  o  m1/m0:push:left/FIS/popR@prime"
    , "  o  m1/m0:push:left/FIS/pshL@prime"
    , "  o  m1/m0:push:left/FIS/pshR@prime"
    , "  o  m1/m0:push:left/FIS/q@prime"
    , "  o  m1/m0:push:left/FIS/qe@prime"
    , "  o  m1/m0:push:left/FIS/res@prime"
    , "  o  m1/m0:push:left/FIS/resL@prime"
    , "  o  m1/m0:push:left/FIS/resR@prime"
    , "  o  m1/m0:push:left/INV/m1:inv0"
    , "  o  m1/m0:push:left/INV/m1:inv1"
    , "  o  m1/m0:push:left/SCH"
    , "  o  m1/m0:push:left/SCH/m1/0/REF/weaken"
    , "  o  m1/m0:push:left/WD/ACT/m1:a0"
    , "  o  m1/m0:push:left/WD/C_SCH"
    , "  o  m1/m0:push:left/WD/F_SCH"
    , "  o  m1/m0:push:left/WD/GRD"
    , "  o  m1/m0:push:right/FIS/emp@prime"
    , "  o  m1/m0:push:right/FIS/p@prime"
    , "  o  m1/m0:push:right/FIS/popL@prime"
    , "  o  m1/m0:push:right/FIS/popR@prime"
    , "  o  m1/m0:push:right/FIS/pshL@prime"
    , "  o  m1/m0:push:right/FIS/pshR@prime"
    , "  o  m1/m0:push:right/FIS/q@prime"
    , "  o  m1/m0:push:right/FIS/qe@prime"
    , "  o  m1/m0:push:right/FIS/res@prime"
    , "  o  m1/m0:push:right/FIS/resL@prime"
    , "  o  m1/m0:push:right/FIS/resR@prime"
    , "  o  m1/m0:push:right/INV/m1:inv0"
    , "  o  m1/m0:push:right/INV/m1:inv1"
    , "  o  m1/m0:push:right/SCH"
    , "  o  m1/m0:push:right/SCH/m1/0/REF/weaken"
    , "  o  m1/m0:push:right/WD/ACT/m1:a0"
    , "  o  m1/m0:push:right/WD/C_SCH"
    , "  o  m1/m0:push:right/WD/F_SCH"
    , "  o  m1/m0:push:right/WD/GRD"
    , "  o  m1/m1:prog0/PROG/WD/lhs"
    , "  o  m1/m1:prog0/PROG/WD/rhs"
    , "  o  m1/m1:prog0/REF/ensure/m1/TR/m0:push:left/EN"
    , "  o  m1/m1:prog0/REF/ensure/m1/TR/m0:push:left/NEG"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:pop:left:empty/SAF"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:pop:left:non:empty/SAF"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:pop:right:empty/SAF"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:pop:right:non:empty/SAF"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:push:left/SAF"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:push:right/SAF"
    , "  o  m1/m1:prog1/PROG/WD/lhs"
    , "  o  m1/m1:prog1/PROG/WD/rhs"
    , "  o  m1/m1:prog1/REF/ensure/m1/TR/m0:push:right/EN"
    , "  o  m1/m1:prog1/REF/ensure/m1/TR/m0:push:right/NEG"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:pop:left:empty/SAF"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:pop:left:non:empty/SAF"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:pop:right:empty/SAF"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:pop:right:non:empty/SAF"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:push:left/SAF"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:push:right/SAF"
    , "  o  m1/m1:prog2/PROG/WD/lhs"
    , "  o  m1/m1:prog2/PROG/WD/rhs"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/leadsto"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/m0:pop:right:empty/EN"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/m0:pop:right:empty/NEG"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/m0:pop:right:non:empty/EN"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/m0:pop:right:non:empty/NEG"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:pop:left:empty/SAF"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:pop:left:non:empty/SAF"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:pop:right:empty/SAF"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:pop:right:non:empty/SAF"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:push:left/SAF"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:push:right/SAF"
    , "  o  m1/m1:prog3/PROG/WD/lhs"
    , "  o  m1/m1:prog3/PROG/WD/rhs"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/leadsto"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:empty/EN"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:empty/NEG"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:non:empty/EN"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:non:empty/NEG"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:pop:left:empty/SAF"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:pop:left:non:empty/SAF"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:pop:right:empty/SAF"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:pop:right:non:empty/SAF"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:push:left/SAF"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:push:right/SAF"
    , "passed 185 / 185"
    ]

    -- enablement non-empty
result5 :: String
result5 = unlines 
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort Val 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort Req 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set Req))"
    , "(declare-const popL@prime (set Req))"
    , "(declare-const popR (set Req))"
    , "(declare-const popR@prime (set Req))"
    , "(declare-const pshL (pfun Req Val))"
    , "(declare-const pshL@prime (pfun Req Val))"
    , "(declare-const pshR (pfun Req Val))"
    , "(declare-const pshR@prime (pfun Req Val))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int Val))"
    , "(declare-const qe@prime (pfun Int Val))"
    , "(declare-const r Req)"
    , "(declare-const res Val)"
    , "(declare-const res@prime Val)"
    , "(declare-const resL (pfun Req Val))"
    , "(declare-const resL@prime (pfun Req Val))"
    , "(declare-const resR (pfun Req Val))"
    , "(declare-const resR@prime (pfun Req Val))"
    , "(declare-fun apply@@Int@@Val ( (pfun Int Val) Int ) Val)"
    , "(declare-fun apply@@Req@@Val ( (pfun Req Val) Req ) Val)"
    , "(declare-fun dom-rest@@Int@@Val"
    , "             ( (set Int)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun dom-rest@@Req@@Val"
    , "             ( (set Req)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun dom-subt@@Int@@Val"
    , "             ( (set Int)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun dom-subt@@Req@@Val"
    , "             ( (set Req)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun dom@@Int@@Val ( (pfun Int Val) ) (set Int))"
    , "(declare-fun dom@@Req@@Val ( (pfun Req Val) ) (set Req))"
    , "(declare-fun empty-fun@@Int@@Val () (pfun Int Val))"
    , "(declare-fun empty-fun@@Req@@Val () (pfun Req Val))"
    , "(declare-fun injective@@Int@@Val ( (pfun Int Val) ) Bool)"
    , "(declare-fun injective@@Req@@Val ( (pfun Req Val) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@Val (Int Val) (pfun Int Val))"
    , "(declare-fun mk-fun@@Req@@Val (Req Val) (pfun Req Val))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@Req (Req) (set Req))"
    , "(declare-fun mk-set@@Val (Val) (set Val))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@Val@Close"
    , "             ( (pfun Int Val) )"
    , "             (set (pfun Int Val)))"
    , "(declare-fun ovl@@Int@@Val"
    , "             ( (pfun Int Val)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun ovl@@Req@@Val"
    , "             ( (pfun Req Val)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun ran@@Int@@Val ( (pfun Int Val) ) (set Val))"
    , "(declare-fun ran@@Req@@Val ( (pfun Req Val) ) (set Val))"
    , "(declare-fun set@@Int@@Val ( (pfun Int Val) ) (set Val))"
    , "(declare-fun set@@Req@@Val ( (pfun Req Val) ) (set Val))"
    , "(declare-fun tfun@@Int@@Val"
    , "             ( (set Int)"
    , "               (set Val) )"
    , "             (set (pfun Int Val)))"
    , "(define-fun Req () (set Req) ( (as const (set Req)) true ))"
    , "(define-fun Val () (set Val) ( (as const (set Val)) true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@Req"
    , "            ( (s1 (set Req)) )"
    , "            (set Req)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@Val"
    , "            ( (s1 (set Val)) )"
    , "            (set Val)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@Open@@pfun@@Int@@Val@Close"
    , "            ( (s1 (set (pfun Int Val))) )"
    , "            (set (pfun Int Val))"
    , "            ((_ map not) s1))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@Req"
    , "            ( (x Req)"
    , "              (s1 (set Req)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@Val"
    , "            ( (x Val)"
    , "              (s1 (set Val)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@Val@Close"
    , "            ( (x (pfun Int Val))"
    , "              (s1 (set (pfun Int Val))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@Req"
    , "            ()"
    , "            (set Req)"
    , "            ( (as const (set Req))"
    , "              false ))"
    , "(define-fun empty-set@@Val"
    , "            ()"
    , "            (set Val)"
    , "            ( (as const (set Val))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@Val@Close"
    , "            ()"
    , "            (set (pfun Int Val))"
    , "            ( (as const (set (pfun Int Val)))"
    , "              false ))"
    , "(define-fun r@param () Req r)"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@Req"
    , "            ( (s1 (set Req))"
    , "              (s2 (set Req)) )"
    , "            (set Req)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@Val"
    , "            ( (s1 (set Val))"
    , "              (s2 (set Val)) )"
    , "            (set Val)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@Open@@pfun@@Int@@Val@Close"
    , "            ( (s1 (set (pfun Int Val)))"
    , "              (s2 (set (pfun Int Val))) )"
    , "            (set (pfun Int Val))"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (= (dom@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                      (union (dom@@Int@@Val f1) (dom@@Int@@Val f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (ovl@@Int@@Val f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (= (dom@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                      (union (dom@@Req@@Val f1) (dom@@Req@@Val f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (ovl@@Req@@Val f1 f2)) ))))"
    , "(assert (= (dom@@Int@@Val empty-fun@@Int@@Val)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@Req@@Val empty-fun@@Req@@Val)"
    , "           empty-set@@Req))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (dom@@Int@@Val (mk-fun@@Int@@Val x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (mk-fun@@Int@@Val x y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (dom@@Req@@Val (mk-fun@@Req@@Val x y))"
    , "                      (mk-set@@Req x))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (mk-fun@@Req@@Val x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f2))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x)"
    , "                          (apply@@Int@@Val f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f2))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x)"
    , "                          (apply@@Req@@Val f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                            (not (elem@@Int x (dom@@Int@@Val f2))))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                            (not (elem@@Req x (dom@@Req@@Val f2))))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Val (dom-subt@@Int@@Val s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (dom-subt@@Int@@Val s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req)) )"
    , "                (! (= (dom@@Req@@Val (dom-subt@@Req@@Val s1 f1))"
    , "                      (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (dom-subt@@Req@@Val s1 f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Int@@Val (mk-fun@@Int@@Val x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (mk-fun@@Int@@Val x y) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Req@@Val (mk-fun@@Req@@Val x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (mk-fun@@Req@@Val x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req))"
    , "                  (x Req) )"
    , "                (! (=> (and (elem@@Req x s1) (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select empty-fun@@Int@@Val x)"
    , "                      (as Nothing (Maybe Val)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Int@@Val x) ))))"
    , "(assert (forall ( (x Req) )"
    , "                (! (= (select empty-fun@@Req@@Val x)"
    , "                      (as Nothing (Maybe Val)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Req@@Val x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (x2 Int)"
    , "                  (y Val) )"
    , "                (! (= (select (mk-fun@@Int@@Val x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Val))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Int@@Val x y) x2) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (x2 Req)"
    , "                  (y Val) )"
    , "                (! (= (select (mk-fun@@Req@@Val x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Val))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Req@@Val x y) x2) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (= (select (ovl@@Int@@Val f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Val)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (= (select (ovl@@Req@@Val f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Val)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (select (dom@@Int@@Val f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe Val)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Int@@Val f1) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (select (dom@@Req@@Val f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe Val)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Req@@Val f1) x) ))))"
    , "(assert (forall ( (y Val)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (elem@@Val y (set@@Int@@Val f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                   (= (apply@@Int@@Val f1 x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (set@@Int@@Val f1)) ))))"
    , "(assert (forall ( (y Val)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (elem@@Val y (set@@Req@@Val f1))"
    , "                      (exists ( (x Req) )"
    , "                              (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                   (= (apply@@Req@@Val f1 x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (set@@Req@@Val f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                           (= (apply@@Int@@Val f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                           (= (apply@@Req@@Val f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x2 Int)"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x2)"
    , "                          (apply@@Int@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x2 Req)"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x2)"
    , "                          (apply@@Req@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x) ))))"
    , "(assert (= (ran@@Int@@Val empty-fun@@Int@@Val)"
    , "           empty-set@@Val))"
    , "(assert (= (ran@@Req@@Val empty-fun@@Req@@Val)"
    , "           empty-set@@Val))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val y (ran@@Int@@Val f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                        (= (apply@@Int@@Val f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (ran@@Int@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val y (ran@@Req@@Val f1))"
    , "                      (exists ( (x Req) )"
    , "                              (and true"
    , "                                   (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                        (= (apply@@Req@@Val f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (ran@@Req@@Val f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (ran@@Int@@Val (mk-fun@@Int@@Val x y))"
    , "                      (mk-set@@Val y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (mk-fun@@Int@@Val x y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (ran@@Req@@Val (mk-fun@@Req@@Val x y))"
    , "                      (mk-set@@Val y))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (mk-fun@@Req@@Val x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (subset (ran@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                           (union (ran@@Int@@Val f1) (ran@@Int@@Val f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                             (union (ran@@Int@@Val f1) (ran@@Int@@Val f2))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (subset (ran@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                           (union (ran@@Req@@Val f1) (ran@@Req@@Val f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                             (union (ran@@Req@@Val f1) (ran@@Req@@Val f2))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set Val)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@Val@Close f1 (tfun@@Int@@Val s1 s2))"
    , "                      (and (= s1 (dom@@Int@@Val f1))"
    , "                           (subset (ran@@Int@@Val f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@Val@Close f1 (tfun@@Int@@Val s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val)) )"
    , "                (! (= (injective@@Int@@Val f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@Val f1)))"
    , "                                  (=> (= (apply@@Int@@Val f1 x) (apply@@Int@@Val f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@Val f1) ))))"
    , "(assert (forall ( (f1 (pfun Req Val)) )"
    , "                (! (= (injective@@Req@@Val f1)"
    , "                      (forall ( (x Req)"
    , "                                (x2 Req) )"
    , "                              (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                       (elem@@Req x2 (dom@@Req@@Val f1)))"
    , "                                  (=> (= (apply@@Req@@Val f1 x) (apply@@Req@@Val f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Req@@Val f1) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (and (injective@@Int@@Val f1)"
    , "                            (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (ran@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1))"
    , "                          (set-diff@@Val (ran@@Int@@Val f1)"
    , "                                         (mk-set@@Val (apply@@Int@@Val f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (and (injective@@Req@@Val f1)"
    , "                            (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (ran@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1))"
    , "                          (set-diff@@Val (ran@@Req@@Val f1)"
    , "                                         (mk-set@@Val (apply@@Req@@Val f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (x2 Int) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Int x2 (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1) x2)"
    , "                          (apply@@Int@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (x2 Req) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Req x2 (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1) x2)"
    , "                          (apply@@Req@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f1))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val (mk-set@@Int x) f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val (mk-set@@Int x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f1))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val (mk-set@@Req x) f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val (mk-set@@Req x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (not (elem@@Int x s1))"
    , "                            (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (and (not (elem@@Req x s1))"
    , "                            (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (and (elem@@Req x s1) (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x) (ran@@Int@@Val f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x) (ran@@Int@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x) (ran@@Req@@Val f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x) (ran@@Req@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                  (ran@@Int@@Val (dom-subt@@Int@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                (ran@@Int@@Val (dom-subt@@Int@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (elem@@Req x (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                  (ran@@Req@@Val (dom-subt@@Req@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                (ran@@Req@@Val (dom-subt@@Req@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                  (ran@@Int@@Val (dom-rest@@Int@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                (ran@@Int@@Val (dom-rest@@Int@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (elem@@Req x (intersect (dom@@Req@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                  (ran@@Req@@Val (dom-rest@@Req@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                (ran@@Req@@Val (dom-rest@@Req@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                            (injective@@Int@@Val f1))"
    , "                       (= (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)))"
    , "                          (union (set-diff@@Val (ran@@Int@@Val f1)"
    , "                                                (mk-set@@Val (apply@@Int@@Val f1 x)))"
    , "                                 (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                            (injective@@Req@@Val f1))"
    , "                       (= (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)))"
    , "                          (union (set-diff@@Val (ran@@Req@@Val f1)"
    , "                                                (mk-set@@Val (apply@@Req@@Val f1 x)))"
    , "                                 (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)))"
    , "                          (union (ran@@Int@@Val f1) (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (not (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)))"
    , "                          (union (ran@@Req@@Val f1) (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (y Val) )"
    , "                (! (= (= (set@@Int@@Val f1) (mk-set@@Val y))"
    , "                      (forall ( (x Int) )"
    , "                              (=> true"
    , "                                  (or (= (select f1 x) (Just y))"
    , "                                      (= (select f1 x) (as Nothing (Maybe Val)))))))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (y Val) )"
    , "                (! (= (= (set@@Req@@Val f1) (mk-set@@Val y))"
    , "                      (forall ( (x Req) )"
    , "                              (=> true"
    , "                                  (or (= (select f1 x) (Just y))"
    , "                                      (= (select f1 x) (as Nothing (Maybe Val)))))))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int Val))"
    , "                  (y (pfun Int Val)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@Val@Close x (mk-set@Open@@pfun@@Int@@Val@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@Val@Close x (mk-set@Open@@pfun@@Int@@Val@Close y)) ))))"
    , "(assert (forall ( (x Val)"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val x (mk-set@@Val y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Val x (mk-set@@Val y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Req) )"
    , "                (! (= (elem@@Req x (mk-set@@Req y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Req x (mk-set@@Req y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@Val@Close qe (tfun@@Int@@Val (intervalR p q) Val)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@Req@@Val resR) popR)"
    , "           empty-set@@Req))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@Req@@Val resL) popL)"
    , "           empty-set@@Req))"
    , "(assert (not (=> (and (elem@@Req r popL) (elem@@Req r popL))"
    , "                 (elem@@Req r@param popL))))" 
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

result6 :: String
result6 = unlines 
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort Val 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort Req 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set Req))"
    , "(declare-const popL@prime (set Req))"
    , "(declare-const popR (set Req))"
    , "(declare-const popR@prime (set Req))"
    , "(declare-const pshL (pfun Req Val))"
    , "(declare-const pshL@prime (pfun Req Val))"
    , "(declare-const pshR (pfun Req Val))"
    , "(declare-const pshR@prime (pfun Req Val))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int Val))"
    , "(declare-const qe@prime (pfun Int Val))"
    , "(declare-const r Req)"
    , "(declare-const res Val)"
    , "(declare-const res@prime Val)"
    , "(declare-const resL (pfun Req Val))"
    , "(declare-const resL@prime (pfun Req Val))"
    , "(declare-const resR (pfun Req Val))"
    , "(declare-const resR@prime (pfun Req Val))"
    , "(declare-fun apply@@Int@@Val ( (pfun Int Val) Int ) Val)"
    , "(declare-fun apply@@Req@@Val ( (pfun Req Val) Req ) Val)"
    , "(declare-fun dom-rest@@Int@@Val"
    , "             ( (set Int)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun dom-rest@@Req@@Val"
    , "             ( (set Req)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun dom-subt@@Int@@Val"
    , "             ( (set Int)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun dom-subt@@Req@@Val"
    , "             ( (set Req)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun dom@@Int@@Val ( (pfun Int Val) ) (set Int))"
    , "(declare-fun dom@@Req@@Val ( (pfun Req Val) ) (set Req))"
    , "(declare-fun empty-fun@@Int@@Val () (pfun Int Val))"
    , "(declare-fun empty-fun@@Req@@Val () (pfun Req Val))"
    , "(declare-fun injective@@Int@@Val ( (pfun Int Val) ) Bool)"
    , "(declare-fun injective@@Req@@Val ( (pfun Req Val) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@Val (Int Val) (pfun Int Val))"
    , "(declare-fun mk-fun@@Req@@Val (Req Val) (pfun Req Val))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@Req (Req) (set Req))"
    , "(declare-fun mk-set@@Val (Val) (set Val))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@Val@Close"
    , "             ( (pfun Int Val) )"
    , "             (set (pfun Int Val)))"
    , "(declare-fun ovl@@Int@@Val"
    , "             ( (pfun Int Val)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun ovl@@Req@@Val"
    , "             ( (pfun Req Val)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun ran@@Int@@Val ( (pfun Int Val) ) (set Val))"
    , "(declare-fun ran@@Req@@Val ( (pfun Req Val) ) (set Val))"
    , "(declare-fun set@@Int@@Val ( (pfun Int Val) ) (set Val))"
    , "(declare-fun set@@Req@@Val ( (pfun Req Val) ) (set Val))"
    , "(declare-fun tfun@@Int@@Val"
    , "             ( (set Int)"
    , "               (set Val) )"
    , "             (set (pfun Int Val)))"
    , "(define-fun Req () (set Req) ( (as const (set Req)) true ))"
    , "(define-fun Val () (set Val) ( (as const (set Val)) true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@Req"
    , "            ( (s1 (set Req)) )"
    , "            (set Req)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@Val"
    , "            ( (s1 (set Val)) )"
    , "            (set Val)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@Open@@pfun@@Int@@Val@Close"
    , "            ( (s1 (set (pfun Int Val))) )"
    , "            (set (pfun Int Val))"
    , "            ((_ map not) s1))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@Req"
    , "            ( (x Req)"
    , "              (s1 (set Req)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@Val"
    , "            ( (x Val)"
    , "              (s1 (set Val)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@Val@Close"
    , "            ( (x (pfun Int Val))"
    , "              (s1 (set (pfun Int Val))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@Req"
    , "            ()"
    , "            (set Req)"
    , "            ( (as const (set Req))"
    , "              false ))"
    , "(define-fun empty-set@@Val"
    , "            ()"
    , "            (set Val)"
    , "            ( (as const (set Val))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@Val@Close"
    , "            ()"
    , "            (set (pfun Int Val))"
    , "            ( (as const (set (pfun Int Val)))"
    , "              false ))"
    , "(define-fun r@param () Req r)"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@Req"
    , "            ( (s1 (set Req))"
    , "              (s2 (set Req)) )"
    , "            (set Req)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@Val"
    , "            ( (s1 (set Val))"
    , "              (s2 (set Val)) )"
    , "            (set Val)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@Open@@pfun@@Int@@Val@Close"
    , "            ( (s1 (set (pfun Int Val)))"
    , "              (s2 (set (pfun Int Val))) )"
    , "            (set (pfun Int Val))"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (= (dom@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                      (union (dom@@Int@@Val f1) (dom@@Int@@Val f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (ovl@@Int@@Val f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (= (dom@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                      (union (dom@@Req@@Val f1) (dom@@Req@@Val f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (ovl@@Req@@Val f1 f2)) ))))"
    , "(assert (= (dom@@Int@@Val empty-fun@@Int@@Val)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@Req@@Val empty-fun@@Req@@Val)"
    , "           empty-set@@Req))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (dom@@Int@@Val (mk-fun@@Int@@Val x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (mk-fun@@Int@@Val x y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (dom@@Req@@Val (mk-fun@@Req@@Val x y))"
    , "                      (mk-set@@Req x))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (mk-fun@@Req@@Val x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f2))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x)"
    , "                          (apply@@Int@@Val f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f2))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x)"
    , "                          (apply@@Req@@Val f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                            (not (elem@@Int x (dom@@Int@@Val f2))))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                            (not (elem@@Req x (dom@@Req@@Val f2))))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Val (dom-subt@@Int@@Val s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (dom-subt@@Int@@Val s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req)) )"
    , "                (! (= (dom@@Req@@Val (dom-subt@@Req@@Val s1 f1))"
    , "                      (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (dom-subt@@Req@@Val s1 f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Int@@Val (mk-fun@@Int@@Val x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (mk-fun@@Int@@Val x y) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Req@@Val (mk-fun@@Req@@Val x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (mk-fun@@Req@@Val x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req))"
    , "                  (x Req) )"
    , "                (! (=> (and (elem@@Req x s1) (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select empty-fun@@Int@@Val x)"
    , "                      (as Nothing (Maybe Val)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Int@@Val x) ))))"
    , "(assert (forall ( (x Req) )"
    , "                (! (= (select empty-fun@@Req@@Val x)"
    , "                      (as Nothing (Maybe Val)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Req@@Val x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (x2 Int)"
    , "                  (y Val) )"
    , "                (! (= (select (mk-fun@@Int@@Val x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Val))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Int@@Val x y) x2) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (x2 Req)"
    , "                  (y Val) )"
    , "                (! (= (select (mk-fun@@Req@@Val x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Val))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Req@@Val x y) x2) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (= (select (ovl@@Int@@Val f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Val)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (= (select (ovl@@Req@@Val f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Val)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (select (dom@@Int@@Val f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe Val)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Int@@Val f1) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (select (dom@@Req@@Val f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe Val)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Req@@Val f1) x) ))))"
    , "(assert (forall ( (y Val)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (elem@@Val y (set@@Int@@Val f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                   (= (apply@@Int@@Val f1 x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (set@@Int@@Val f1)) ))))"
    , "(assert (forall ( (y Val)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (elem@@Val y (set@@Req@@Val f1))"
    , "                      (exists ( (x Req) )"
    , "                              (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                   (= (apply@@Req@@Val f1 x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (set@@Req@@Val f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                           (= (apply@@Int@@Val f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                           (= (apply@@Req@@Val f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x2 Int)"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x2)"
    , "                          (apply@@Int@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x2 Req)"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x2)"
    , "                          (apply@@Req@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x) ))))"
    , "(assert (= (ran@@Int@@Val empty-fun@@Int@@Val)"
    , "           empty-set@@Val))"
    , "(assert (= (ran@@Req@@Val empty-fun@@Req@@Val)"
    , "           empty-set@@Val))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val y (ran@@Int@@Val f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                        (= (apply@@Int@@Val f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (ran@@Int@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val y (ran@@Req@@Val f1))"
    , "                      (exists ( (x Req) )"
    , "                              (and true"
    , "                                   (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                        (= (apply@@Req@@Val f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (ran@@Req@@Val f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (ran@@Int@@Val (mk-fun@@Int@@Val x y))"
    , "                      (mk-set@@Val y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (mk-fun@@Int@@Val x y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (ran@@Req@@Val (mk-fun@@Req@@Val x y))"
    , "                      (mk-set@@Val y))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (mk-fun@@Req@@Val x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (subset (ran@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                           (union (ran@@Int@@Val f1) (ran@@Int@@Val f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                             (union (ran@@Int@@Val f1) (ran@@Int@@Val f2))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (subset (ran@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                           (union (ran@@Req@@Val f1) (ran@@Req@@Val f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                             (union (ran@@Req@@Val f1) (ran@@Req@@Val f2))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set Val)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@Val@Close f1 (tfun@@Int@@Val s1 s2))"
    , "                      (and (= s1 (dom@@Int@@Val f1))"
    , "                           (subset (ran@@Int@@Val f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@Val@Close f1 (tfun@@Int@@Val s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val)) )"
    , "                (! (= (injective@@Int@@Val f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@Val f1)))"
    , "                                  (=> (= (apply@@Int@@Val f1 x) (apply@@Int@@Val f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@Val f1) ))))"
    , "(assert (forall ( (f1 (pfun Req Val)) )"
    , "                (! (= (injective@@Req@@Val f1)"
    , "                      (forall ( (x Req)"
    , "                                (x2 Req) )"
    , "                              (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                       (elem@@Req x2 (dom@@Req@@Val f1)))"
    , "                                  (=> (= (apply@@Req@@Val f1 x) (apply@@Req@@Val f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Req@@Val f1) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (and (injective@@Int@@Val f1)"
    , "                            (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (ran@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1))"
    , "                          (set-diff@@Val (ran@@Int@@Val f1)"
    , "                                         (mk-set@@Val (apply@@Int@@Val f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (and (injective@@Req@@Val f1)"
    , "                            (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (ran@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1))"
    , "                          (set-diff@@Val (ran@@Req@@Val f1)"
    , "                                         (mk-set@@Val (apply@@Req@@Val f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (x2 Int) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Int x2 (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1) x2)"
    , "                          (apply@@Int@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (x2 Req) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Req x2 (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1) x2)"
    , "                          (apply@@Req@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f1))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val (mk-set@@Int x) f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val (mk-set@@Int x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f1))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val (mk-set@@Req x) f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val (mk-set@@Req x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (not (elem@@Int x s1))"
    , "                            (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (and (not (elem@@Req x s1))"
    , "                            (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (and (elem@@Req x s1) (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x) (ran@@Int@@Val f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x) (ran@@Int@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x) (ran@@Req@@Val f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x) (ran@@Req@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                  (ran@@Int@@Val (dom-subt@@Int@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                (ran@@Int@@Val (dom-subt@@Int@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (elem@@Req x (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                  (ran@@Req@@Val (dom-subt@@Req@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                (ran@@Req@@Val (dom-subt@@Req@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                  (ran@@Int@@Val (dom-rest@@Int@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                (ran@@Int@@Val (dom-rest@@Int@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (elem@@Req x (intersect (dom@@Req@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                  (ran@@Req@@Val (dom-rest@@Req@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                (ran@@Req@@Val (dom-rest@@Req@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                            (injective@@Int@@Val f1))"
    , "                       (= (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)))"
    , "                          (union (set-diff@@Val (ran@@Int@@Val f1)"
    , "                                                (mk-set@@Val (apply@@Int@@Val f1 x)))"
    , "                                 (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                            (injective@@Req@@Val f1))"
    , "                       (= (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)))"
    , "                          (union (set-diff@@Val (ran@@Req@@Val f1)"
    , "                                                (mk-set@@Val (apply@@Req@@Val f1 x)))"
    , "                                 (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)))"
    , "                          (union (ran@@Int@@Val f1) (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (not (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)))"
    , "                          (union (ran@@Req@@Val f1) (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (y Val) )"
    , "                (! (= (= (set@@Int@@Val f1) (mk-set@@Val y))"
    , "                      (forall ( (x Int) )"
    , "                              (=> true"
    , "                                  (or (= (select f1 x) (Just y))"
    , "                                      (= (select f1 x) (as Nothing (Maybe Val)))))))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (y Val) )"
    , "                (! (= (= (set@@Req@@Val f1) (mk-set@@Val y))"
    , "                      (forall ( (x Req) )"
    , "                              (=> true"
    , "                                  (or (= (select f1 x) (Just y))"
    , "                                      (= (select f1 x) (as Nothing (Maybe Val)))))))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int Val))"
    , "                  (y (pfun Int Val)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@Val@Close x (mk-set@Open@@pfun@@Int@@Val@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@Val@Close x (mk-set@Open@@pfun@@Int@@Val@Close y)) ))))"
    , "(assert (forall ( (x Val)"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val x (mk-set@@Val y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Val x (mk-set@@Val y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Req) )"
    , "                (! (= (elem@@Req x (mk-set@@Req y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Req x (mk-set@@Req y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@Val@Close qe (tfun@@Int@@Val (intervalR p q) Val)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@Req@@Val resR) popR)"
    , "           empty-set@@Req))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@Req@@Val resL) popL)"
    , "           empty-set@@Req))"
    , "(assert (not (=> (and (elem@@Req r popL) (elem@@Req r popL))"
    , "                 (elem@@Req r@param popL))))" 
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

result7 :: String
result7 = unlines 
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort Val 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort Req 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set Req))"
    , "(declare-const popL@prime (set Req))"
    , "(declare-const popR (set Req))"
    , "(declare-const popR@prime (set Req))"
    , "(declare-const pshL (pfun Req Val))"
    , "(declare-const pshL@prime (pfun Req Val))"
    , "(declare-const pshR (pfun Req Val))"
    , "(declare-const pshR@prime (pfun Req Val))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int Val))"
    , "(declare-const qe@prime (pfun Int Val))"
    , "(declare-const r Req)"
    , "(declare-const res Val)"
    , "(declare-const res@prime Val)"
    , "(declare-const resL (pfun Req Val))"
    , "(declare-const resL@prime (pfun Req Val))"
    , "(declare-const resR (pfun Req Val))"
    , "(declare-const resR@prime (pfun Req Val))"
    , "(declare-fun apply@@Int@@Val ( (pfun Int Val) Int ) Val)"
    , "(declare-fun apply@@Req@@Val ( (pfun Req Val) Req ) Val)"
    , "(declare-fun dom-rest@@Int@@Val"
    , "             ( (set Int)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun dom-rest@@Req@@Val"
    , "             ( (set Req)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun dom-subt@@Int@@Val"
    , "             ( (set Int)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun dom-subt@@Req@@Val"
    , "             ( (set Req)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun dom@@Int@@Val ( (pfun Int Val) ) (set Int))"
    , "(declare-fun dom@@Req@@Val ( (pfun Req Val) ) (set Req))"
    , "(declare-fun empty-fun@@Int@@Val () (pfun Int Val))"
    , "(declare-fun empty-fun@@Req@@Val () (pfun Req Val))"
    , "(declare-fun injective@@Int@@Val ( (pfun Int Val) ) Bool)"
    , "(declare-fun injective@@Req@@Val ( (pfun Req Val) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@Val (Int Val) (pfun Int Val))"
    , "(declare-fun mk-fun@@Req@@Val (Req Val) (pfun Req Val))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@Req (Req) (set Req))"
    , "(declare-fun mk-set@@Val (Val) (set Val))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@Val@Close"
    , "             ( (pfun Int Val) )"
    , "             (set (pfun Int Val)))"
    , "(declare-fun ovl@@Int@@Val"
    , "             ( (pfun Int Val)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun ovl@@Req@@Val"
    , "             ( (pfun Req Val)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun ran@@Int@@Val ( (pfun Int Val) ) (set Val))"
    , "(declare-fun ran@@Req@@Val ( (pfun Req Val) ) (set Val))"
    , "(declare-fun set@@Int@@Val ( (pfun Int Val) ) (set Val))"
    , "(declare-fun set@@Req@@Val ( (pfun Req Val) ) (set Val))"
    , "(declare-fun tfun@@Int@@Val"
    , "             ( (set Int)"
    , "               (set Val) )"
    , "             (set (pfun Int Val)))"
    , "(define-fun Req () (set Req) ( (as const (set Req)) true ))"
    , "(define-fun Val () (set Val) ( (as const (set Val)) true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@Req"
    , "            ( (s1 (set Req)) )"
    , "            (set Req)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@Val"
    , "            ( (s1 (set Val)) )"
    , "            (set Val)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@Open@@pfun@@Int@@Val@Close"
    , "            ( (s1 (set (pfun Int Val))) )"
    , "            (set (pfun Int Val))"
    , "            ((_ map not) s1))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@Req"
    , "            ( (x Req)"
    , "              (s1 (set Req)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@Val"
    , "            ( (x Val)"
    , "              (s1 (set Val)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@Val@Close"
    , "            ( (x (pfun Int Val))"
    , "              (s1 (set (pfun Int Val))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@Req"
    , "            ()"
    , "            (set Req)"
    , "            ( (as const (set Req))"
    , "              false ))"
    , "(define-fun empty-set@@Val"
    , "            ()"
    , "            (set Val)"
    , "            ( (as const (set Val))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@Val@Close"
    , "            ()"
    , "            (set (pfun Int Val))"
    , "            ( (as const (set (pfun Int Val)))"
    , "              false ))"
    , "(define-fun r@param () Req r)"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@Req"
    , "            ( (s1 (set Req))"
    , "              (s2 (set Req)) )"
    , "            (set Req)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@Val"
    , "            ( (s1 (set Val))"
    , "              (s2 (set Val)) )"
    , "            (set Val)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@Open@@pfun@@Int@@Val@Close"
    , "            ( (s1 (set (pfun Int Val)))"
    , "              (s2 (set (pfun Int Val))) )"
    , "            (set (pfun Int Val))"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (= (dom@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                      (union (dom@@Int@@Val f1) (dom@@Int@@Val f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (ovl@@Int@@Val f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (= (dom@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                      (union (dom@@Req@@Val f1) (dom@@Req@@Val f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (ovl@@Req@@Val f1 f2)) ))))"
    , "(assert (= (dom@@Int@@Val empty-fun@@Int@@Val)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@Req@@Val empty-fun@@Req@@Val)"
    , "           empty-set@@Req))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (dom@@Int@@Val (mk-fun@@Int@@Val x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (mk-fun@@Int@@Val x y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (dom@@Req@@Val (mk-fun@@Req@@Val x y))"
    , "                      (mk-set@@Req x))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (mk-fun@@Req@@Val x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f2))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x)"
    , "                          (apply@@Int@@Val f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f2))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x)"
    , "                          (apply@@Req@@Val f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                            (not (elem@@Int x (dom@@Int@@Val f2))))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                            (not (elem@@Req x (dom@@Req@@Val f2))))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Val (dom-subt@@Int@@Val s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (dom-subt@@Int@@Val s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req)) )"
    , "                (! (= (dom@@Req@@Val (dom-subt@@Req@@Val s1 f1))"
    , "                      (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (dom-subt@@Req@@Val s1 f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Int@@Val (mk-fun@@Int@@Val x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (mk-fun@@Int@@Val x y) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Req@@Val (mk-fun@@Req@@Val x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (mk-fun@@Req@@Val x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req))"
    , "                  (x Req) )"
    , "                (! (=> (and (elem@@Req x s1) (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select empty-fun@@Int@@Val x)"
    , "                      (as Nothing (Maybe Val)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Int@@Val x) ))))"
    , "(assert (forall ( (x Req) )"
    , "                (! (= (select empty-fun@@Req@@Val x)"
    , "                      (as Nothing (Maybe Val)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Req@@Val x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (x2 Int)"
    , "                  (y Val) )"
    , "                (! (= (select (mk-fun@@Int@@Val x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Val))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Int@@Val x y) x2) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (x2 Req)"
    , "                  (y Val) )"
    , "                (! (= (select (mk-fun@@Req@@Val x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Val))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Req@@Val x y) x2) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (= (select (ovl@@Int@@Val f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Val)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (= (select (ovl@@Req@@Val f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Val)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (select (dom@@Int@@Val f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe Val)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Int@@Val f1) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (select (dom@@Req@@Val f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe Val)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Req@@Val f1) x) ))))"
    , "(assert (forall ( (y Val)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (elem@@Val y (set@@Int@@Val f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                   (= (apply@@Int@@Val f1 x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (set@@Int@@Val f1)) ))))"
    , "(assert (forall ( (y Val)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (elem@@Val y (set@@Req@@Val f1))"
    , "                      (exists ( (x Req) )"
    , "                              (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                   (= (apply@@Req@@Val f1 x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (set@@Req@@Val f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                           (= (apply@@Int@@Val f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                           (= (apply@@Req@@Val f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x2 Int)"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x2)"
    , "                          (apply@@Int@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x2 Req)"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x2)"
    , "                          (apply@@Req@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x) ))))"
    , "(assert (= (ran@@Int@@Val empty-fun@@Int@@Val)"
    , "           empty-set@@Val))"
    , "(assert (= (ran@@Req@@Val empty-fun@@Req@@Val)"
    , "           empty-set@@Val))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val y (ran@@Int@@Val f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                        (= (apply@@Int@@Val f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (ran@@Int@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val y (ran@@Req@@Val f1))"
    , "                      (exists ( (x Req) )"
    , "                              (and true"
    , "                                   (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                        (= (apply@@Req@@Val f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (ran@@Req@@Val f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (ran@@Int@@Val (mk-fun@@Int@@Val x y))"
    , "                      (mk-set@@Val y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (mk-fun@@Int@@Val x y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (ran@@Req@@Val (mk-fun@@Req@@Val x y))"
    , "                      (mk-set@@Val y))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (mk-fun@@Req@@Val x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (subset (ran@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                           (union (ran@@Int@@Val f1) (ran@@Int@@Val f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                             (union (ran@@Int@@Val f1) (ran@@Int@@Val f2))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (subset (ran@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                           (union (ran@@Req@@Val f1) (ran@@Req@@Val f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                             (union (ran@@Req@@Val f1) (ran@@Req@@Val f2))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set Val)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@Val@Close f1 (tfun@@Int@@Val s1 s2))"
    , "                      (and (= s1 (dom@@Int@@Val f1))"
    , "                           (subset (ran@@Int@@Val f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@Val@Close f1 (tfun@@Int@@Val s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val)) )"
    , "                (! (= (injective@@Int@@Val f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@Val f1)))"
    , "                                  (=> (= (apply@@Int@@Val f1 x) (apply@@Int@@Val f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@Val f1) ))))"
    , "(assert (forall ( (f1 (pfun Req Val)) )"
    , "                (! (= (injective@@Req@@Val f1)"
    , "                      (forall ( (x Req)"
    , "                                (x2 Req) )"
    , "                              (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                       (elem@@Req x2 (dom@@Req@@Val f1)))"
    , "                                  (=> (= (apply@@Req@@Val f1 x) (apply@@Req@@Val f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Req@@Val f1) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (and (injective@@Int@@Val f1)"
    , "                            (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (ran@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1))"
    , "                          (set-diff@@Val (ran@@Int@@Val f1)"
    , "                                         (mk-set@@Val (apply@@Int@@Val f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (and (injective@@Req@@Val f1)"
    , "                            (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (ran@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1))"
    , "                          (set-diff@@Val (ran@@Req@@Val f1)"
    , "                                         (mk-set@@Val (apply@@Req@@Val f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (x2 Int) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Int x2 (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1) x2)"
    , "                          (apply@@Int@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (x2 Req) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Req x2 (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1) x2)"
    , "                          (apply@@Req@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f1))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val (mk-set@@Int x) f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val (mk-set@@Int x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f1))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val (mk-set@@Req x) f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val (mk-set@@Req x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (not (elem@@Int x s1))"
    , "                            (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (and (not (elem@@Req x s1))"
    , "                            (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (and (elem@@Req x s1) (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x) (ran@@Int@@Val f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x) (ran@@Int@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x) (ran@@Req@@Val f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x) (ran@@Req@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                  (ran@@Int@@Val (dom-subt@@Int@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                (ran@@Int@@Val (dom-subt@@Int@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (elem@@Req x (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                  (ran@@Req@@Val (dom-subt@@Req@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                (ran@@Req@@Val (dom-subt@@Req@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                  (ran@@Int@@Val (dom-rest@@Int@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                (ran@@Int@@Val (dom-rest@@Int@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (elem@@Req x (intersect (dom@@Req@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                  (ran@@Req@@Val (dom-rest@@Req@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                (ran@@Req@@Val (dom-rest@@Req@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                            (injective@@Int@@Val f1))"
    , "                       (= (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)))"
    , "                          (union (set-diff@@Val (ran@@Int@@Val f1)"
    , "                                                (mk-set@@Val (apply@@Int@@Val f1 x)))"
    , "                                 (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                            (injective@@Req@@Val f1))"
    , "                       (= (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)))"
    , "                          (union (set-diff@@Val (ran@@Req@@Val f1)"
    , "                                                (mk-set@@Val (apply@@Req@@Val f1 x)))"
    , "                                 (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)))"
    , "                          (union (ran@@Int@@Val f1) (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (not (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)))"
    , "                          (union (ran@@Req@@Val f1) (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (y Val) )"
    , "                (! (= (= (set@@Int@@Val f1) (mk-set@@Val y))"
    , "                      (forall ( (x Int) )"
    , "                              (=> true"
    , "                                  (or (= (select f1 x) (Just y))"
    , "                                      (= (select f1 x) (as Nothing (Maybe Val)))))))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (y Val) )"
    , "                (! (= (= (set@@Req@@Val f1) (mk-set@@Val y))"
    , "                      (forall ( (x Req) )"
    , "                              (=> true"
    , "                                  (or (= (select f1 x) (Just y))"
    , "                                      (= (select f1 x) (as Nothing (Maybe Val)))))))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int Val))"
    , "                  (y (pfun Int Val)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@Val@Close x (mk-set@Open@@pfun@@Int@@Val@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@Val@Close x (mk-set@Open@@pfun@@Int@@Val@Close y)) ))))"
    , "(assert (forall ( (x Val)"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val x (mk-set@@Val y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Val x (mk-set@@Val y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Req) )"
    , "                (! (= (elem@@Req x (mk-set@@Req y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Req x (mk-set@@Req y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "; SKIP:p"
    , "(assert (= p@prime p))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:qe"
    , "(assert (= qe@prime qe))"
    , "; SKIP:res"
    , "(assert (= res@prime res))"
    , "; SKIP:resL"
    , "(assert (= resL@prime resL))"
    , "; SKIP:resR"
    , "(assert (= resR@prime resR))"
    , "; m0:act4"
    , "(assert (= emp@prime true))"
    , "; m0:grd0"
    , "(assert (= p q))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@Val@Close qe (tfun@@Int@@Val (intervalR p q) Val)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:a4"
    , "(assert (= popL@prime"
    , "           (set-diff@@Req popL (mk-set@@Req r@param))))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@Req@@Val resR) popR)"
    , "           empty-set@@Req))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@Req@@Val resL) popL)"
    , "           empty-set@@Req))"
    , "; m1:sch0"
    , "(assert (elem@@Req r@param popL))"
    , "; m1:sch1"
    , "(assert (= p q))"
    , "(assert (not (=> (and (elem@@Req r popL) (elem@@Req r popL))"
    , "                 (not (and (elem@@Req r popL@prime) (elem@@Req r popL@prime))))))" 
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

result8 :: String
result8 = unlines 
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort Val 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort Req 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set Req))"
    , "(declare-const popL@prime (set Req))"
    , "(declare-const popR (set Req))"
    , "(declare-const popR@prime (set Req))"
    , "(declare-const pshL (pfun Req Val))"
    , "(declare-const pshL@prime (pfun Req Val))"
    , "(declare-const pshR (pfun Req Val))"
    , "(declare-const pshR@prime (pfun Req Val))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int Val))"
    , "(declare-const qe@prime (pfun Int Val))"
    , "(declare-const r Req)"
    , "(declare-const res Val)"
    , "(declare-const res@prime Val)"
    , "(declare-const resL (pfun Req Val))"
    , "(declare-const resL@prime (pfun Req Val))"
    , "(declare-const resR (pfun Req Val))"
    , "(declare-const resR@prime (pfun Req Val))"
    , "(declare-fun apply@@Int@@Val ( (pfun Int Val) Int ) Val)"
    , "(declare-fun apply@@Req@@Val ( (pfun Req Val) Req ) Val)"
    , "(declare-fun dom-rest@@Int@@Val"
    , "             ( (set Int)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun dom-rest@@Req@@Val"
    , "             ( (set Req)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun dom-subt@@Int@@Val"
    , "             ( (set Int)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun dom-subt@@Req@@Val"
    , "             ( (set Req)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun dom@@Int@@Val ( (pfun Int Val) ) (set Int))"
    , "(declare-fun dom@@Req@@Val ( (pfun Req Val) ) (set Req))"
    , "(declare-fun empty-fun@@Int@@Val () (pfun Int Val))"
    , "(declare-fun empty-fun@@Req@@Val () (pfun Req Val))"
    , "(declare-fun injective@@Int@@Val ( (pfun Int Val) ) Bool)"
    , "(declare-fun injective@@Req@@Val ( (pfun Req Val) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@Val (Int Val) (pfun Int Val))"
    , "(declare-fun mk-fun@@Req@@Val (Req Val) (pfun Req Val))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@Req (Req) (set Req))"
    , "(declare-fun mk-set@@Val (Val) (set Val))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@Val@Close"
    , "             ( (pfun Int Val) )"
    , "             (set (pfun Int Val)))"
    , "(declare-fun ovl@@Int@@Val"
    , "             ( (pfun Int Val)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun ovl@@Req@@Val"
    , "             ( (pfun Req Val)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun ran@@Int@@Val ( (pfun Int Val) ) (set Val))"
    , "(declare-fun ran@@Req@@Val ( (pfun Req Val) ) (set Val))"
    , "(declare-fun set@@Int@@Val ( (pfun Int Val) ) (set Val))"
    , "(declare-fun set@@Req@@Val ( (pfun Req Val) ) (set Val))"
    , "(declare-fun tfun@@Int@@Val"
    , "             ( (set Int)"
    , "               (set Val) )"
    , "             (set (pfun Int Val)))"
    , "(define-fun Req () (set Req) ( (as const (set Req)) true ))"
    , "(define-fun Val () (set Val) ( (as const (set Val)) true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@Req"
    , "            ( (s1 (set Req)) )"
    , "            (set Req)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@Val"
    , "            ( (s1 (set Val)) )"
    , "            (set Val)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@Open@@pfun@@Int@@Val@Close"
    , "            ( (s1 (set (pfun Int Val))) )"
    , "            (set (pfun Int Val))"
    , "            ((_ map not) s1))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@Req"
    , "            ( (x Req)"
    , "              (s1 (set Req)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@Val"
    , "            ( (x Val)"
    , "              (s1 (set Val)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@Val@Close"
    , "            ( (x (pfun Int Val))"
    , "              (s1 (set (pfun Int Val))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@Req"
    , "            ()"
    , "            (set Req)"
    , "            ( (as const (set Req))"
    , "              false ))"
    , "(define-fun empty-set@@Val"
    , "            ()"
    , "            (set Val)"
    , "            ( (as const (set Val))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@Val@Close"
    , "            ()"
    , "            (set (pfun Int Val))"
    , "            ( (as const (set (pfun Int Val)))"
    , "              false ))"
    , "(define-fun r@param () Req r)"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@Req"
    , "            ( (s1 (set Req))"
    , "              (s2 (set Req)) )"
    , "            (set Req)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@Val"
    , "            ( (s1 (set Val))"
    , "              (s2 (set Val)) )"
    , "            (set Val)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@Open@@pfun@@Int@@Val@Close"
    , "            ( (s1 (set (pfun Int Val)))"
    , "              (s2 (set (pfun Int Val))) )"
    , "            (set (pfun Int Val))"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (= (dom@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                      (union (dom@@Int@@Val f1) (dom@@Int@@Val f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (ovl@@Int@@Val f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (= (dom@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                      (union (dom@@Req@@Val f1) (dom@@Req@@Val f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (ovl@@Req@@Val f1 f2)) ))))"
    , "(assert (= (dom@@Int@@Val empty-fun@@Int@@Val)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@Req@@Val empty-fun@@Req@@Val)"
    , "           empty-set@@Req))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (dom@@Int@@Val (mk-fun@@Int@@Val x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (mk-fun@@Int@@Val x y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (dom@@Req@@Val (mk-fun@@Req@@Val x y))"
    , "                      (mk-set@@Req x))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (mk-fun@@Req@@Val x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f2))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x)"
    , "                          (apply@@Int@@Val f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f2))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x)"
    , "                          (apply@@Req@@Val f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                            (not (elem@@Int x (dom@@Int@@Val f2))))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                            (not (elem@@Req x (dom@@Req@@Val f2))))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Val (dom-subt@@Int@@Val s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (dom-subt@@Int@@Val s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req)) )"
    , "                (! (= (dom@@Req@@Val (dom-subt@@Req@@Val s1 f1))"
    , "                      (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (dom-subt@@Req@@Val s1 f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Int@@Val (mk-fun@@Int@@Val x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (mk-fun@@Int@@Val x y) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Req@@Val (mk-fun@@Req@@Val x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (mk-fun@@Req@@Val x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req))"
    , "                  (x Req) )"
    , "                (! (=> (and (elem@@Req x s1) (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select empty-fun@@Int@@Val x)"
    , "                      (as Nothing (Maybe Val)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Int@@Val x) ))))"
    , "(assert (forall ( (x Req) )"
    , "                (! (= (select empty-fun@@Req@@Val x)"
    , "                      (as Nothing (Maybe Val)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Req@@Val x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (x2 Int)"
    , "                  (y Val) )"
    , "                (! (= (select (mk-fun@@Int@@Val x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Val))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Int@@Val x y) x2) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (x2 Req)"
    , "                  (y Val) )"
    , "                (! (= (select (mk-fun@@Req@@Val x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Val))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Req@@Val x y) x2) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (= (select (ovl@@Int@@Val f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Val)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (= (select (ovl@@Req@@Val f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Val)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (select (dom@@Int@@Val f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe Val)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Int@@Val f1) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (select (dom@@Req@@Val f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe Val)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Req@@Val f1) x) ))))"
    , "(assert (forall ( (y Val)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (elem@@Val y (set@@Int@@Val f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                   (= (apply@@Int@@Val f1 x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (set@@Int@@Val f1)) ))))"
    , "(assert (forall ( (y Val)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (elem@@Val y (set@@Req@@Val f1))"
    , "                      (exists ( (x Req) )"
    , "                              (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                   (= (apply@@Req@@Val f1 x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (set@@Req@@Val f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                           (= (apply@@Int@@Val f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                           (= (apply@@Req@@Val f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x2 Int)"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x2)"
    , "                          (apply@@Int@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x2 Req)"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x2)"
    , "                          (apply@@Req@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x) ))))"
    , "(assert (= (ran@@Int@@Val empty-fun@@Int@@Val)"
    , "           empty-set@@Val))"
    , "(assert (= (ran@@Req@@Val empty-fun@@Req@@Val)"
    , "           empty-set@@Val))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val y (ran@@Int@@Val f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                        (= (apply@@Int@@Val f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (ran@@Int@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val y (ran@@Req@@Val f1))"
    , "                      (exists ( (x Req) )"
    , "                              (and true"
    , "                                   (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                        (= (apply@@Req@@Val f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (ran@@Req@@Val f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (ran@@Int@@Val (mk-fun@@Int@@Val x y))"
    , "                      (mk-set@@Val y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (mk-fun@@Int@@Val x y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (ran@@Req@@Val (mk-fun@@Req@@Val x y))"
    , "                      (mk-set@@Val y))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (mk-fun@@Req@@Val x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (subset (ran@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                           (union (ran@@Int@@Val f1) (ran@@Int@@Val f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                             (union (ran@@Int@@Val f1) (ran@@Int@@Val f2))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (subset (ran@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                           (union (ran@@Req@@Val f1) (ran@@Req@@Val f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                             (union (ran@@Req@@Val f1) (ran@@Req@@Val f2))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set Val)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@Val@Close f1 (tfun@@Int@@Val s1 s2))"
    , "                      (and (= s1 (dom@@Int@@Val f1))"
    , "                           (subset (ran@@Int@@Val f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@Val@Close f1 (tfun@@Int@@Val s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val)) )"
    , "                (! (= (injective@@Int@@Val f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@Val f1)))"
    , "                                  (=> (= (apply@@Int@@Val f1 x) (apply@@Int@@Val f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@Val f1) ))))"
    , "(assert (forall ( (f1 (pfun Req Val)) )"
    , "                (! (= (injective@@Req@@Val f1)"
    , "                      (forall ( (x Req)"
    , "                                (x2 Req) )"
    , "                              (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                       (elem@@Req x2 (dom@@Req@@Val f1)))"
    , "                                  (=> (= (apply@@Req@@Val f1 x) (apply@@Req@@Val f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Req@@Val f1) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (and (injective@@Int@@Val f1)"
    , "                            (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (ran@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1))"
    , "                          (set-diff@@Val (ran@@Int@@Val f1)"
    , "                                         (mk-set@@Val (apply@@Int@@Val f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (and (injective@@Req@@Val f1)"
    , "                            (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (ran@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1))"
    , "                          (set-diff@@Val (ran@@Req@@Val f1)"
    , "                                         (mk-set@@Val (apply@@Req@@Val f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (x2 Int) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Int x2 (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1) x2)"
    , "                          (apply@@Int@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (x2 Req) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Req x2 (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1) x2)"
    , "                          (apply@@Req@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f1))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val (mk-set@@Int x) f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val (mk-set@@Int x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f1))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val (mk-set@@Req x) f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val (mk-set@@Req x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (not (elem@@Int x s1))"
    , "                            (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (and (not (elem@@Req x s1))"
    , "                            (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (and (elem@@Req x s1) (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x) (ran@@Int@@Val f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x) (ran@@Int@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x) (ran@@Req@@Val f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x) (ran@@Req@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                  (ran@@Int@@Val (dom-subt@@Int@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                (ran@@Int@@Val (dom-subt@@Int@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (elem@@Req x (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                  (ran@@Req@@Val (dom-subt@@Req@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                (ran@@Req@@Val (dom-subt@@Req@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                  (ran@@Int@@Val (dom-rest@@Int@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                (ran@@Int@@Val (dom-rest@@Int@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (elem@@Req x (intersect (dom@@Req@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                  (ran@@Req@@Val (dom-rest@@Req@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                (ran@@Req@@Val (dom-rest@@Req@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                            (injective@@Int@@Val f1))"
    , "                       (= (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)))"
    , "                          (union (set-diff@@Val (ran@@Int@@Val f1)"
    , "                                                (mk-set@@Val (apply@@Int@@Val f1 x)))"
    , "                                 (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                            (injective@@Req@@Val f1))"
    , "                       (= (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)))"
    , "                          (union (set-diff@@Val (ran@@Req@@Val f1)"
    , "                                                (mk-set@@Val (apply@@Req@@Val f1 x)))"
    , "                                 (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)))"
    , "                          (union (ran@@Int@@Val f1) (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (not (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)))"
    , "                          (union (ran@@Req@@Val f1) (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (y Val) )"
    , "                (! (= (= (set@@Int@@Val f1) (mk-set@@Val y))"
    , "                      (forall ( (x Int) )"
    , "                              (=> true"
    , "                                  (or (= (select f1 x) (Just y))"
    , "                                      (= (select f1 x) (as Nothing (Maybe Val)))))))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (y Val) )"
    , "                (! (= (= (set@@Req@@Val f1) (mk-set@@Val y))"
    , "                      (forall ( (x Req) )"
    , "                              (=> true"
    , "                                  (or (= (select f1 x) (Just y))"
    , "                                      (= (select f1 x) (as Nothing (Maybe Val)))))))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int Val))"
    , "                  (y (pfun Int Val)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@Val@Close x (mk-set@Open@@pfun@@Int@@Val@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@Val@Close x (mk-set@Open@@pfun@@Int@@Val@Close y)) ))))"
    , "(assert (forall ( (x Val)"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val x (mk-set@@Val y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Val x (mk-set@@Val y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Req) )"
    , "                (! (= (elem@@Req x (mk-set@@Req y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Req x (mk-set@@Req y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "; SKIP:p"
    , "(assert (= p@prime p))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:qe"
    , "(assert (= qe@prime qe))"
    , "; SKIP:res"
    , "(assert (= res@prime res))"
    , "; SKIP:resL"
    , "(assert (= resL@prime resL))"
    , "; SKIP:resR"
    , "(assert (= resR@prime resR))"
    , "; m0:act4"
    , "(assert (= emp@prime true))"
    , "; m0:grd0"
    , "(assert (= p q))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@Val@Close qe (tfun@@Int@@Val (intervalR p q) Val)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:a4"
    , "(assert (= popL@prime"
    , "           (set-diff@@Req popL (mk-set@@Req r@param))))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@Req@@Val resR) popR)"
    , "           empty-set@@Req))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@Req@@Val resL) popL)"
    , "           empty-set@@Req))"
    , "; m1:sch0"
    , "(assert (elem@@Req r@param popL))"
    , "; m1:sch1"
    , "(assert (= p q))"
    , "(assert (not (=> (and (elem@@Req r popL) (elem@@Req r popL))"
    , "                 (not (and (elem@@Req r popL@prime) (elem@@Req r popL@prime))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

result9 :: String
result9 = unlines
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort Val 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort Req 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set Req))"
    , "(declare-const popL@prime (set Req))"
    , "(declare-const popR (set Req))"
    , "(declare-const popR@prime (set Req))"
    , "(declare-const pshL (pfun Req Val))"
    , "(declare-const pshL@prime (pfun Req Val))"
    , "(declare-const pshR (pfun Req Val))"
    , "(declare-const pshR@prime (pfun Req Val))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int Val))"
    , "(declare-const qe@prime (pfun Int Val))"
    , "(declare-const r Req)"
    , "(declare-const r0 Req)"
    , "(declare-const r@m0-pop-left-empty Req)"
    , "(declare-const r@m0-pop-left-non-empty Req)"
    , "(declare-const res Val)"
    , "(declare-const res@prime Val)"
    , "(declare-const resL (pfun Req Val))"
    , "(declare-const resL@prime (pfun Req Val))"
    , "(declare-const resR (pfun Req Val))"
    , "(declare-const resR@prime (pfun Req Val))"
    , "(declare-fun apply@@Int@@Val ( (pfun Int Val) Int ) Val)"
    , "(declare-fun apply@@Req@@Val ( (pfun Req Val) Req ) Val)"
    , "(declare-fun dom-rest@@Int@@Val"
    , "             ( (set Int)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun dom-rest@@Req@@Val"
    , "             ( (set Req)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun dom-subt@@Int@@Val"
    , "             ( (set Int)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun dom-subt@@Req@@Val"
    , "             ( (set Req)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun dom@@Int@@Val ( (pfun Int Val) ) (set Int))"
    , "(declare-fun dom@@Req@@Val ( (pfun Req Val) ) (set Req))"
    , "(declare-fun empty-fun@@Int@@Val () (pfun Int Val))"
    , "(declare-fun empty-fun@@Req@@Val () (pfun Req Val))"
    , "(declare-fun injective@@Int@@Val ( (pfun Int Val) ) Bool)"
    , "(declare-fun injective@@Req@@Val ( (pfun Req Val) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@Val (Int Val) (pfun Int Val))"
    , "(declare-fun mk-fun@@Req@@Val (Req Val) (pfun Req Val))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@Req (Req) (set Req))"
    , "(declare-fun mk-set@@Val (Val) (set Val))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@Val@Close"
    , "             ( (pfun Int Val) )"
    , "             (set (pfun Int Val)))"
    , "(declare-fun ovl@@Int@@Val"
    , "             ( (pfun Int Val)"
    , "               (pfun Int Val) )"
    , "             (pfun Int Val))"
    , "(declare-fun ovl@@Req@@Val"
    , "             ( (pfun Req Val)"
    , "               (pfun Req Val) )"
    , "             (pfun Req Val))"
    , "(declare-fun ran@@Int@@Val ( (pfun Int Val) ) (set Val))"
    , "(declare-fun ran@@Req@@Val ( (pfun Req Val) ) (set Val))"
    , "(declare-fun set@@Int@@Val ( (pfun Int Val) ) (set Val))"
    , "(declare-fun set@@Req@@Val ( (pfun Req Val) ) (set Val))"
    , "(declare-fun tfun@@Int@@Val"
    , "             ( (set Int)"
    , "               (set Val) )"
    , "             (set (pfun Int Val)))"
    , "(define-fun Req () (set Req) ( (as const (set Req)) true ))"
    , "(define-fun Val () (set Val) ( (as const (set Val)) true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@Req"
    , "            ( (s1 (set Req)) )"
    , "            (set Req)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@Val"
    , "            ( (s1 (set Val)) )"
    , "            (set Val)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@Open@@pfun@@Int@@Val@Close"
    , "            ( (s1 (set (pfun Int Val))) )"
    , "            (set (pfun Int Val))"
    , "            ((_ map not) s1))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@Req"
    , "            ( (x Req)"
    , "              (s1 (set Req)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@Val"
    , "            ( (x Val)"
    , "              (s1 (set Val)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@Val@Close"
    , "            ( (x (pfun Int Val))"
    , "              (s1 (set (pfun Int Val))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@Req"
    , "            ()"
    , "            (set Req)"
    , "            ( (as const (set Req))"
    , "              false ))"
    , "(define-fun empty-set@@Val"
    , "            ()"
    , "            (set Val)"
    , "            ( (as const (set Val))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@Val@Close"
    , "            ()"
    , "            (set (pfun Int Val))"
    , "            ( (as const (set (pfun Int Val)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@Req"
    , "            ( (s1 (set Req))"
    , "              (s2 (set Req)) )"
    , "            (set Req)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@Val"
    , "            ( (s1 (set Val))"
    , "              (s2 (set Val)) )"
    , "            (set Val)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@Open@@pfun@@Int@@Val@Close"
    , "            ( (s1 (set (pfun Int Val)))"
    , "              (s2 (set (pfun Int Val))) )"
    , "            (set (pfun Int Val))"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (= (dom@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                      (union (dom@@Int@@Val f1) (dom@@Int@@Val f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (ovl@@Int@@Val f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (= (dom@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                      (union (dom@@Req@@Val f1) (dom@@Req@@Val f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (ovl@@Req@@Val f1 f2)) ))))"
    , "(assert (= (dom@@Int@@Val empty-fun@@Int@@Val)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@Req@@Val empty-fun@@Req@@Val)"
    , "           empty-set@@Req))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (dom@@Int@@Val (mk-fun@@Int@@Val x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (mk-fun@@Int@@Val x y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (dom@@Req@@Val (mk-fun@@Req@@Val x y))"
    , "                      (mk-set@@Req x))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (mk-fun@@Req@@Val x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f2))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x)"
    , "                          (apply@@Int@@Val f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f2))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x)"
    , "                          (apply@@Req@@Val f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                            (not (elem@@Int x (dom@@Int@@Val f2))))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                            (not (elem@@Req x (dom@@Req@@Val f2))))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Val (dom-subt@@Int@@Val s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Val (dom-subt@@Int@@Val s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req)) )"
    , "                (! (= (dom@@Req@@Val (dom-subt@@Req@@Val s1 f1))"
    , "                      (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Req@@Val (dom-subt@@Req@@Val s1 f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Int@@Val (mk-fun@@Int@@Val x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (mk-fun@@Int@@Val x y) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Req@@Val (mk-fun@@Req@@Val x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (mk-fun@@Req@@Val x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req))"
    , "                  (x Req) )"
    , "                (! (=> (and (elem@@Req x s1) (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (s1 (set Req))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select empty-fun@@Int@@Val x)"
    , "                      (as Nothing (Maybe Val)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Int@@Val x) ))))"
    , "(assert (forall ( (x Req) )"
    , "                (! (= (select empty-fun@@Req@@Val x)"
    , "                      (as Nothing (Maybe Val)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Req@@Val x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (x2 Int)"
    , "                  (y Val) )"
    , "                (! (= (select (mk-fun@@Int@@Val x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Val))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Int@@Val x y) x2) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (x2 Req)"
    , "                  (y Val) )"
    , "                (! (= (select (mk-fun@@Req@@Val x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe Val))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Req@@Val x y) x2) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (= (select (ovl@@Int@@Val f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Val)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Int@@Val f1 f2) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (= (select (ovl@@Req@@Val f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe Val)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Req@@Val f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (select (dom@@Int@@Val f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe Val)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Int@@Val f1) x) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (select (dom@@Req@@Val f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe Val)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Req@@Val f1) x) ))))"
    , "(assert (forall ( (y Val)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (elem@@Val y (set@@Int@@Val f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                   (= (apply@@Int@@Val f1 x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (set@@Int@@Val f1)) ))))"
    , "(assert (forall ( (y Val)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (elem@@Val y (set@@Req@@Val f1))"
    , "                      (exists ( (x Req) )"
    , "                              (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                   (= (apply@@Req@@Val f1 x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (set@@Req@@Val f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val)"
    , "                  (f1 (pfun Int Val)) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                           (= (apply@@Int@@Val f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val)"
    , "                  (f1 (pfun Req Val)) )"
    , "                (! (= (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                           (= (apply@@Req@@Val f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x2 Int)"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x2)"
    , "                          (apply@@Int@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x2 Req)"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x2)"
    , "                          (apply@@Req@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (= (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)) x) ))))"
    , "(assert (= (ran@@Int@@Val empty-fun@@Int@@Val)"
    , "           empty-set@@Val))"
    , "(assert (= (ran@@Req@@Val empty-fun@@Req@@Val)"
    , "           empty-set@@Val))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val y (ran@@Int@@Val f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                        (= (apply@@Int@@Val f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (ran@@Int@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val y (ran@@Req@@Val f1))"
    , "                      (exists ( (x Req) )"
    , "                              (and true"
    , "                                   (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                        (= (apply@@Req@@Val f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Val y (ran@@Req@@Val f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Val) )"
    , "                (! (= (ran@@Int@@Val (mk-fun@@Int@@Val x y))"
    , "                      (mk-set@@Val y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (mk-fun@@Int@@Val x y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Val) )"
    , "                (! (= (ran@@Req@@Val (mk-fun@@Req@@Val x y))"
    , "                      (mk-set@@Val y))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (mk-fun@@Req@@Val x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (f2 (pfun Int Val)) )"
    , "                (! (subset (ran@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                           (union (ran@@Int@@Val f1) (ran@@Int@@Val f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Int@@Val (ovl@@Int@@Val f1 f2))"
    , "                             (union (ran@@Int@@Val f1) (ran@@Int@@Val f2))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (f2 (pfun Req Val)) )"
    , "                (! (subset (ran@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                           (union (ran@@Req@@Val f1) (ran@@Req@@Val f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Req@@Val (ovl@@Req@@Val f1 f2))"
    , "                             (union (ran@@Req@@Val f1) (ran@@Req@@Val f2))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set Val)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@Val@Close f1 (tfun@@Int@@Val s1 s2))"
    , "                      (and (= s1 (dom@@Int@@Val f1))"
    , "                           (subset (ran@@Int@@Val f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@Val@Close f1 (tfun@@Int@@Val s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val)) )"
    , "                (! (= (injective@@Int@@Val f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@Val f1)))"
    , "                                  (=> (= (apply@@Int@@Val f1 x) (apply@@Int@@Val f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@Val f1) ))))"
    , "(assert (forall ( (f1 (pfun Req Val)) )"
    , "                (! (= (injective@@Req@@Val f1)"
    , "                      (forall ( (x Req)"
    , "                                (x2 Req) )"
    , "                              (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                                       (elem@@Req x2 (dom@@Req@@Val f1)))"
    , "                                  (=> (= (apply@@Req@@Val f1 x) (apply@@Req@@Val f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Req@@Val f1) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (and (injective@@Int@@Val f1)"
    , "                            (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (ran@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1))"
    , "                          (set-diff@@Val (ran@@Int@@Val f1)"
    , "                                         (mk-set@@Val (apply@@Int@@Val f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (and (injective@@Req@@Val f1)"
    , "                            (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (ran@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1))"
    , "                          (set-diff@@Val (ran@@Req@@Val f1)"
    , "                                         (mk-set@@Val (apply@@Req@@Val f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (x2 Int) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Int x2 (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1) x2)"
    , "                          (apply@@Int@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val (mk-set@@Int x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (x2 Req) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Req x2 (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1) x2)"
    , "                          (apply@@Req@@Val f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val (mk-set@@Req x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f1))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val (mk-set@@Int x) f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val (mk-set@@Int x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f1))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val (mk-set@@Req x) f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val (mk-set@@Req x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (not (elem@@Int x s1))"
    , "                            (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-subt@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (and (not (elem@@Req x s1))"
    , "                            (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-subt@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x)"
    , "                          (apply@@Int@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Val (dom-rest@@Int@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (and (elem@@Req x s1) (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x)"
    , "                          (apply@@Req@@Val f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Req@@Val (dom-rest@@Req@@Val s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Val f1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x) (ran@@Int@@Val f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x) (ran@@Int@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req) )"
    , "                (! (=> (elem@@Req x (dom@@Req@@Val f1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x) (ran@@Req@@Val f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x) (ran@@Req@@Val f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                  (ran@@Int@@Val (dom-subt@@Int@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                (ran@@Int@@Val (dom-subt@@Int@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (elem@@Req x (set-diff@@Req (dom@@Req@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                  (ran@@Req@@Val (dom-subt@@Req@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                (ran@@Req@@Val (dom-subt@@Req@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                  (ran@@Int@@Val (dom-rest@@Int@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Int@@Val f1 x)"
    , "                                (ran@@Int@@Val (dom-rest@@Int@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (s1 (set Req)) )"
    , "                (! (=> (elem@@Req x (intersect (dom@@Req@@Val f1) s1))"
    , "                       (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                  (ran@@Req@@Val (dom-rest@@Req@@Val s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Val (apply@@Req@@Val f1 x)"
    , "                                (ran@@Req@@Val (dom-rest@@Req@@Val s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Val f1))"
    , "                            (injective@@Int@@Val f1))"
    , "                       (= (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)))"
    , "                          (union (set-diff@@Val (ran@@Int@@Val f1)"
    , "                                                (mk-set@@Val (apply@@Int@@Val f1 x)))"
    , "                                 (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (and (elem@@Req x (dom@@Req@@Val f1))"
    , "                            (injective@@Req@@Val f1))"
    , "                       (= (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)))"
    , "                          (union (set-diff@@Val (ran@@Req@@Val f1)"
    , "                                                (mk-set@@Val (apply@@Req@@Val f1 x)))"
    , "                                 (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (x Int)"
    , "                  (y Val) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@Val f1)))"
    , "                       (= (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y)))"
    , "                          (union (ran@@Int@@Val f1) (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Val (ovl@@Int@@Val f1 (mk-fun@@Int@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (x Req)"
    , "                  (y Val) )"
    , "                (! (=> (not (elem@@Req x (dom@@Req@@Val f1)))"
    , "                       (= (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y)))"
    , "                          (union (ran@@Req@@Val f1) (mk-set@@Val y))))"
    , "                   :pattern"
    , "                   ( (ran@@Req@@Val (ovl@@Req@@Val f1 (mk-fun@@Req@@Val x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Val))"
    , "                  (y Val) )"
    , "                (! (= (= (set@@Int@@Val f1) (mk-set@@Val y))"
    , "                      (forall ( (x Int) )"
    , "                              (=> true"
    , "                                  (or (= (select f1 x) (Just y))"
    , "                                      (= (select f1 x) (as Nothing (Maybe Val)))))))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Req Val))"
    , "                  (y Val) )"
    , "                (! (= (= (set@@Req@@Val f1) (mk-set@@Val y))"
    , "                      (forall ( (x Req) )"
    , "                              (=> true"
    , "                                  (or (= (select f1 x) (Just y))"
    , "                                      (= (select f1 x) (as Nothing (Maybe Val)))))))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int Val))"
    , "                  (y (pfun Int Val)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@Val@Close x (mk-set@Open@@pfun@@Int@@Val@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@Val@Close x (mk-set@Open@@pfun@@Int@@Val@Close y)) ))))"
    , "(assert (forall ( (x Val)"
    , "                  (y Val) )"
    , "                (! (= (elem@@Val x (mk-set@@Val y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Val x (mk-set@@Val y)) ))))"
    , "(assert (forall ( (x Req)"
    , "                  (y Req) )"
    , "                (! (= (elem@@Req x (mk-set@@Req y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Req x (mk-set@@Req y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (not (forall ( (r Req)"
    , "                       (r@m0-pop-left-empty Req)"
    , "                       (r@m0-pop-left-non-empty Req) )"
    , "                     (=> (and (elem@@Req r popL)"
    , "                              (elem@@Req r popL)"
    , "                              (elem@@Req r@m0-pop-left-empty popL)"
    , "                              (elem@@Req r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "(assert (not (forall ( (r@m0-pop-left-empty Req)"
    , "                       (r@m0-pop-left-non-empty Req) )"
    , "                     (=> (and (elem@@Req r0 popL)"
    , "                              (elem@@Req r0 popL)"
    , "                              (elem@@Req r@m0-pop-left-empty popL)"
    , "                              (elem@@Req r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "(assert (not (forall ( (r@m0-pop-left-non-empty Req) )"
    , "                     (=> (and (elem@@Req r0 popL)"
    , "                              (elem@@Req r0 popL)"
    , "                              (elem@@Req r@m0-pop-left-empty popL)"
    , "                              (elem@@Req r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@Val@Close qe (tfun@@Int@@Val (intervalR p q) Val)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@Req@@Val resR) popR)"
    , "           empty-set@@Req))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@Req@@Val resL) popL)"
    , "           empty-set@@Req))"
    , "(assert (not (=> (and (elem@@Req r0 popL)"
    , "                      (elem@@Req r0 popL)"
    , "                      (elem@@Req r@m0-pop-left-empty popL)"
    , "                      (elem@@Req r@m0-pop-left-non-empty popL))"
    , "                 (or (= p q) (< p q)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

path10 :: FilePath 
path10 = "tests/lock-free deque/main6-err0.tex"

result10 :: String
result10 = unlines
    [ "error: Multiple refinement of progress property m1:prog3"
    , "\tm1:prog3: (223,4)"
    , "\tm1:prog3: (254,1)"
    , ""
    ]
