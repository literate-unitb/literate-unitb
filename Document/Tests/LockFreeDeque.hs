{-# LANGUAGE OverloadedStrings #-}
module Document.Tests.LockFreeDeque 
    -- ( test_case, test, path4, result4 )
where

    -- Modules
import Document.Tests.Suite

import Logic.Proof

import UnitB.AST

    -- Libraries
import Control.Lens hiding (indices)

import Data.List as L
import Data.Map as M
import Data.Set as S

import Tests.UnitTest

import Utilities.BipartiteGraph

-- import Utilities.TH

test_case :: TestCase
test_case = test

test :: TestCase
test = test_cases
            "Specification and refinement of a lock-free algorithm"
            [ (POCase "test 0, verification, specification with intervals" 
                (verify path0 0) result0)
            , (POCase "test 1, verification, failed proof with intervals" 
                (verify path1 0) result1)
            , (StringCase "test 2, error message name clash in guards" 
                case2 result2)
            , (POCase "test 3, verification, looking up function outside of domain" 
                (verify path3 0) result3)
            , (POCase "test 4, m1, liveness implemented with conditional behavior"
                (verify path4 1) result4)
            , (StringCase "test 5, transient, two branches, enablement of non-empty"
                (proof_obligation path4 "m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN" 1)
                result5)
            , (StringCase "test 6, transient, two branches, enablement of empty"
                (proof_obligation path4 "m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN" 1)
                result6)
            , (StringCase "test 7, transient, two branches, negation of empty"
                (proof_obligation path4 "m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG" 1)
                result7)
            , (StringCase "test 8, transient, two branches, negation of non-empty"
                (proof_obligation path4 "m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG" 1)
                result8)
            , (StringCase "test 9, transient, two branches, follow and disjunction"
                (proof_obligation path4 "m1/LIVE/m1:prog3/ensure/TR/leadsto" 1)
                result9)
            , (StringCase "test 10, duplicate refinement of liveness properties"
                (find_errors path10)
                result10)
            , StringCase "test 11, missing witness"
                (find_errors path11)
                result11
            , POCase "test 12, carrier sets without using sets"
                case12 result12
            , POCase "test 13, event splitting"
                case13 result13
            , Case "test 14, event splitting, event sets"
                case14 result14                
            , Case "test 15, event splitting, expression sets"
                case15 result15
            , Case "test 16, event splitting, index decl"
                case16 result16
            , StringCase "test 17, empty parameter list"
                case17 result17
            , StringCase "test 18, empty list in VarScope"
                case18 result18
            , StringCase "test 19, splitting POs"
                case19 result19
            ]            

result0 :: String
result0 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/emp@prime"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/FIS/res@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/INV/m0:inv1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act3"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act4"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , "  o  m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:left/WWD"
    , "  o  m0/m0:pop:right/FIS/emp@prime"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/FIS/res@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/INV/m0:inv1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act3"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act4"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:pop:right/WWD"
    , "  o  m0/m0:push:left/FIS/emp@prime"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , "  o  m0/m0:push:left/FIS/res@prime"
    , "  o  m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/INV/m0:inv1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:left/WWD"
    , "  o  m0/m0:push:right/FIS/emp@prime"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , "  o  m0/m0:push:right/FIS/res@prime"
    , "  o  m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/INV/m0:inv1"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , "  o  m0/m0:push:right/WD/GRD"
    , "  o  m0/m0:push:right/WWD"
    , "passed 64 / 64"
    ]

path0 :: FilePath
path0 = "tests/lock-free deque/main.tex"

path1 :: FilePath
path1 = "tests/lock-free deque/main2.tex"

result1 :: String
result1 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , "  o  m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:left/WWD"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:pop:right/WWD"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , " xxx m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act2"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:left/WWD"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , " xxx m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act1"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , "  o  m0/m0:push:right/WD/GRD"
    , "  o  m0/m0:push:right/WWD"
    , "passed 51 / 53"
    ]

path2 :: String
path2 = "tests/lock-free deque/main3.tex"

case2 :: IO String
case2 = find_errors path2


result2 :: String
result2 = unlines
    [ "Multiple expressions with the label m0:inv0"
    , "error 42:1:"
    , "\tinvariant"
    , ""
    , "error 44:4:"
    , "\tinvariant"
    , ""
    , ""
    , "Multiple expressions with the label m0:grd0"
    , "error 86:4:"
    , "\tguard (event 'm0:pop:right')"
    , ""
    , "error 87:4:"
    , "\tguard (event 'm0:pop:right')"
    , ""
    , ""
    ]

path3 :: String
path3 = "tests/lock-free deque/main4.tex"

result3 :: String
result3 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/INV/m0:inv1"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/SCH/x"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , " xxx m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:left/WWD"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/INV/m0:inv1"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/SCH/x"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:pop:right/WWD"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , "  o  m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/INV/m0:inv1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act2"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:left/WWD"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , "  o  m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/INV/m0:inv1"
    , "  o  m0/m0:push:right/SCH/x"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act1"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , " xxx m0/m0:push:right/WD/GRD"
    , "  o  m0/m0:push:right/WWD"
    , "passed 59 / 61"
    ]

path4 :: FilePath
path4 = "tests/lock-free deque/main6.tex"

result4 :: String
result4 = unlines
    [ "  o  m1/INIT/FIS/p"
    , "  o  m1/INIT/FIS/q"
    , "  o  m1/INIT/FIS/qe"
    , "  o  m1/INIT/FIS/resL"
    , "  o  m1/INIT/FIS/resR"
    , "  o  m1/INIT/INV/m1:inv0"
    , "  o  m1/INIT/INV/m1:inv1"
    , "  o  m1/INIT/WD"
    , "  o  m1/INIT/WWD"
    , "  o  m1/INV/WD"
    , "  o  m1/LIVE/m1:prog0/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/m1:prog0/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/WD"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/WD/witness/r"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/m0:push:left/EN"
    , "  o  m1/LIVE/m1:prog0/ensure/TR/m0:push:left/NEG"
    , "  o  m1/LIVE/m1:prog1/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/m1:prog1/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/WD"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/WD/witness/r"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/m0:push:right/EN"
    , "  o  m1/LIVE/m1:prog1/ensure/TR/m0:push:right/NEG"
    , "  o  m1/LIVE/m1:prog2/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/m1:prog2/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/WD"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/WD/witness/r"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/leadsto"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:empty/EN"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:empty/NEG"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:non:empty/EN"
    , "  o  m1/LIVE/m1:prog2/ensure/TR/m0:pop:right:non:empty/NEG"
    , "  o  m1/LIVE/m1:prog3/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/m1:prog3/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/WD"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/WD/witness/r"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/WFIS/r/r@prime"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/leadsto"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN"
    , "  o  m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG"
    , "  o  m1/m0:pop:left:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:left:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:left:empty/FIS/p@prime"
    , "  o  m1/m0:pop:left:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:left:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:left:empty/FIS/q@prime"
    , "  o  m1/m0:pop:left:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:left:empty/FIS/res@prime"
    , "  o  m1/m0:pop:left:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:left:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:left:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:left:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:left:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:left:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:left:empty/WD/ACT/m1:a4"
    , "  o  m1/m0:pop:left:empty/WD/C_SCH"
    , "  o  m1/m0:pop:left:empty/WD/F_SCH"
    , "  o  m1/m0:pop:left:empty/WD/GRD"
    , "  o  m1/m0:pop:left:empty/WWD"
    , "  o  m1/m0:pop:left:non:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:left:non:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/p@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/q@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/res@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:left:non:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:left:non:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:left:non:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:left:non:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:left:non:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:left:non:empty/SCH/m1:grd0"
    , "  o  m1/m0:pop:left:non:empty/WD/ACT/m1:a4"
    , "  o  m1/m0:pop:left:non:empty/WD/ACT/m1:a5"
    , "  o  m1/m0:pop:left:non:empty/WD/C_SCH"
    , "  o  m1/m0:pop:left:non:empty/WD/F_SCH"
    , "  o  m1/m0:pop:left:non:empty/WD/GRD"
    , "  o  m1/m0:pop:left:non:empty/WWD"
    , "  o  m1/m0:pop:right:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:right:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:right:empty/FIS/p@prime"
    , "  o  m1/m0:pop:right:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:right:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:right:empty/FIS/q@prime"
    , "  o  m1/m0:pop:right:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:right:empty/FIS/res@prime"
    , "  o  m1/m0:pop:right:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:right:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:right:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:right:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:right:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:right:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:right:empty/WD/ACT/m1:a2"
    , "  o  m1/m0:pop:right:empty/WD/C_SCH"
    , "  o  m1/m0:pop:right:empty/WD/F_SCH"
    , "  o  m1/m0:pop:right:empty/WD/GRD"
    , "  o  m1/m0:pop:right:empty/WWD"
    , "  o  m1/m0:pop:right:non:empty/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:pop:right:non:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/p@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/q@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/res@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:right:non:empty/F_SCH/replace/eqv"
    , "  o  m1/m0:pop:right:non:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:right:non:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:pop:right:non:empty/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:pop:right:non:empty/SCH/m0:grd0"
    , "  o  m1/m0:pop:right:non:empty/SCH/m1:grd0"
    , "  o  m1/m0:pop:right:non:empty/WD/ACT/m1:a2"
    , "  o  m1/m0:pop:right:non:empty/WD/ACT/m1:a3"
    , "  o  m1/m0:pop:right:non:empty/WD/C_SCH"
    , "  o  m1/m0:pop:right:non:empty/WD/F_SCH"
    , "  o  m1/m0:pop:right:non:empty/WD/GRD"
    , "  o  m1/m0:pop:right:non:empty/WWD"
    , "  o  m1/m0:push:left/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:push:left/FIS/emp@prime"
    , "  o  m1/m0:push:left/FIS/p@prime"
    , "  o  m1/m0:push:left/FIS/popL@prime"
    , "  o  m1/m0:push:left/FIS/popR@prime"
    , "  o  m1/m0:push:left/FIS/pshL@prime"
    , "  o  m1/m0:push:left/FIS/pshR@prime"
    , "  o  m1/m0:push:left/FIS/q@prime"
    , "  o  m1/m0:push:left/FIS/qe@prime"
    , "  o  m1/m0:push:left/FIS/res@prime"
    , "  o  m1/m0:push:left/FIS/resL@prime"
    , "  o  m1/m0:push:left/FIS/resR@prime"
    , "  o  m1/m0:push:left/INV/m1:inv0"
    , "  o  m1/m0:push:left/INV/m1:inv1"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:push:left/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:push:left/SCH"
    , "  o  m1/m0:push:left/SCH/x"
    , "  o  m1/m0:push:left/WD/ACT/m1:a0"
    , "  o  m1/m0:push:left/WD/C_SCH"
    , "  o  m1/m0:push:left/WD/F_SCH"
    , "  o  m1/m0:push:left/WD/GRD"
    , "  o  m1/m0:push:left/WWD"
    , "  o  m1/m0:push:right/C_SCH/weaken/m1:sch0"
    , "  o  m1/m0:push:right/FIS/emp@prime"
    , "  o  m1/m0:push:right/FIS/p@prime"
    , "  o  m1/m0:push:right/FIS/popL@prime"
    , "  o  m1/m0:push:right/FIS/popR@prime"
    , "  o  m1/m0:push:right/FIS/pshL@prime"
    , "  o  m1/m0:push:right/FIS/pshR@prime"
    , "  o  m1/m0:push:right/FIS/q@prime"
    , "  o  m1/m0:push:right/FIS/qe@prime"
    , "  o  m1/m0:push:right/FIS/res@prime"
    , "  o  m1/m0:push:right/FIS/resL@prime"
    , "  o  m1/m0:push:right/FIS/resR@prime"
    , "  o  m1/m0:push:right/INV/m1:inv0"
    , "  o  m1/m0:push:right/INV/m1:inv1"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog0/ensure"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog1/ensure"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog2/ensure"
    , "  o  m1/m0:push:right/SAF/LIVE/m1:prog3/ensure"
    , "  o  m1/m0:push:right/SCH"
    , "  o  m1/m0:push:right/SCH/x"
    , "  o  m1/m0:push:right/WD/ACT/m1:a0"
    , "  o  m1/m0:push:right/WD/C_SCH"
    , "  o  m1/m0:push:right/WD/F_SCH"
    , "  o  m1/m0:push:right/WD/GRD"
    , "  o  m1/m0:push:right/WWD"
    , "  o  m1/m1:prog0/PROG/WD/lhs"
    , "  o  m1/m1:prog0/PROG/WD/rhs"
    , "  o  m1/m1:prog1/PROG/WD/lhs"
    , "  o  m1/m1:prog1/PROG/WD/rhs"
    , "  o  m1/m1:prog2/PROG/WD/lhs"
    , "  o  m1/m1:prog2/PROG/WD/rhs"
    , "  o  m1/m1:prog3/PROG/WD/lhs"
    , "  o  m1/m1:prog3/PROG/WD/rhs"
    , "passed 206 / 206"
    ]

    -- enablement non-empty
result5 :: String
result5 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl@REQ))"
    , "(declare-const popL@prime (set sl@REQ))"
    , "(declare-const popR (set sl@REQ))"
    , "(declare-const popR@prime (set sl@REQ))"
    , "(declare-const pshL (pfun sl@REQ sl@G))"
    , "(declare-const pshL@prime (pfun sl@REQ sl@G))"
    , "(declare-const pshR (pfun sl@REQ sl@G))"
    , "(declare-const pshR@prime (pfun sl@REQ sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@REQ)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-const resL (pfun sl@REQ sl@G))"
    , "(declare-const resL@prime (pfun sl@REQ sl@G))"
    , "(declare-const resR (pfun sl@REQ sl@G))"
    , "(declare-const resR@prime (pfun sl@REQ sl@G))"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-rest@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun dom@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G) )"
    , "             (set sl@REQ))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun empty-fun@@sl@REQ@@sl@G () (pfun sl@REQ sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@REQ ( (set sl@REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun injective@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@REQ (sl@REQ) (set sl@REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ovl@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun r@param () sl@REQ)"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun ran@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              true ))"
    , "(define-fun all@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@REQ"
    , "            ( (s1 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@REQ"
    , "            ( (x sl@REQ)"
    , "              (s1 (set sl@REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@REQ))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (ovl@@sl@REQ@@sl@G f1 empty-fun@@sl@REQ@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl@REQ@@sl@G f1 empty-fun@@sl@REQ@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (ovl@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G f1) ))))"
    , "(assert (forall ( (s2 (set sl@G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                     (tfun@@Int@@sl@G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                       (tfun@@Int@@sl@G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                      (union (dom@@sl@REQ@@sl@G f1) (dom@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))"
    , "                      (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (= (ran@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl@G empty-fun@@Int@@sl@G))"
    , "(assert (injective@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@REQ) )"
    , "                (! (= (elem@@sl@REQ x (mk-set@@sl@REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (mk-set@@sl@REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (finite@@sl@G s1)"
    , "                       (finite@@sl@G (set-diff@@sl@G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (set-diff@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (finite@@sl@REQ s1)"
    , "                       (finite@@sl@REQ (set-diff@@sl@REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (set-diff@@sl@REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl@G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (and (finite@@sl@G s1) (finite@@sl@G s2))"
    , "                       (finite@@sl@G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (and (finite@@sl@REQ s1) (finite@@sl@REQ s2))"
    , "                       (finite@@sl@REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x)) ))))"
    , "(assert (forall ( (x sl@REQ) )"
    , "                (! (finite@@sl@REQ (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (mk-set@@sl@REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl@G@Close empty-set@Open@@pfun@@Int@@sl@G@Close))"
    , "(assert (finite@@sl@G empty-set@@sl@G))"
    , "(assert (finite@@sl@REQ empty-set@@sl@REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl@G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl@G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@G s2) (finite@@sl@G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G s2)"
    , "                     (finite@@sl@G s1) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@REQ s2) (finite@@sl@REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ s2)"
    , "                     (finite@@sl@REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resR) popR)"
    , "           empty-set@@sl@REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resL) popL)"
    , "           empty-set@@sl@REQ))"
    , "(assert (not (=> (and (elem@@sl@REQ r popL) (elem@@sl@REQ r popL))"
    , "                 (elem@@sl@REQ r@param popL))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/EN"
    ]

result6 :: String
result6 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl@REQ))"
    , "(declare-const popL@prime (set sl@REQ))"
    , "(declare-const popR (set sl@REQ))"
    , "(declare-const popR@prime (set sl@REQ))"
    , "(declare-const pshL (pfun sl@REQ sl@G))"
    , "(declare-const pshL@prime (pfun sl@REQ sl@G))"
    , "(declare-const pshR (pfun sl@REQ sl@G))"
    , "(declare-const pshR@prime (pfun sl@REQ sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@REQ)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-const resL (pfun sl@REQ sl@G))"
    , "(declare-const resL@prime (pfun sl@REQ sl@G))"
    , "(declare-const resR (pfun sl@REQ sl@G))"
    , "(declare-const resR@prime (pfun sl@REQ sl@G))"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-rest@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun dom@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G) )"
    , "             (set sl@REQ))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun empty-fun@@sl@REQ@@sl@G () (pfun sl@REQ sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@REQ ( (set sl@REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun injective@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@REQ (sl@REQ) (set sl@REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ovl@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun r@param () sl@REQ)"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun ran@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              true ))"
    , "(define-fun all@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@REQ"
    , "            ( (s1 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@REQ"
    , "            ( (x sl@REQ)"
    , "              (s1 (set sl@REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@REQ))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (ovl@@sl@REQ@@sl@G f1 empty-fun@@sl@REQ@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl@REQ@@sl@G f1 empty-fun@@sl@REQ@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (ovl@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G f1) ))))"
    , "(assert (forall ( (s2 (set sl@G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                     (tfun@@Int@@sl@G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                       (tfun@@Int@@sl@G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                      (union (dom@@sl@REQ@@sl@G f1) (dom@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))"
    , "                      (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (= (ran@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl@G empty-fun@@Int@@sl@G))"
    , "(assert (injective@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@REQ) )"
    , "                (! (= (elem@@sl@REQ x (mk-set@@sl@REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (mk-set@@sl@REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (finite@@sl@G s1)"
    , "                       (finite@@sl@G (set-diff@@sl@G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (set-diff@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (finite@@sl@REQ s1)"
    , "                       (finite@@sl@REQ (set-diff@@sl@REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (set-diff@@sl@REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl@G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (and (finite@@sl@G s1) (finite@@sl@G s2))"
    , "                       (finite@@sl@G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (and (finite@@sl@REQ s1) (finite@@sl@REQ s2))"
    , "                       (finite@@sl@REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x)) ))))"
    , "(assert (forall ( (x sl@REQ) )"
    , "                (! (finite@@sl@REQ (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (mk-set@@sl@REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl@G@Close empty-set@Open@@pfun@@Int@@sl@G@Close))"
    , "(assert (finite@@sl@G empty-set@@sl@G))"
    , "(assert (finite@@sl@REQ empty-set@@sl@REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl@G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl@G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@G s2) (finite@@sl@G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G s2)"
    , "                     (finite@@sl@G s1) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@REQ s2) (finite@@sl@REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ s2)"
    , "                     (finite@@sl@REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resR) popR)"
    , "           empty-set@@sl@REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resL) popL)"
    , "           empty-set@@sl@REQ))"
    , "(assert (not (=> (and (elem@@sl@REQ r popL) (elem@@sl@REQ r popL))"
    , "                 (elem@@sl@REQ r@param popL))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/EN"
    ]

result7 :: String
result7 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl@REQ))"
    , "(declare-const popL@prime (set sl@REQ))"
    , "(declare-const popR (set sl@REQ))"
    , "(declare-const popR@prime (set sl@REQ))"
    , "(declare-const pshL (pfun sl@REQ sl@G))"
    , "(declare-const pshL@prime (pfun sl@REQ sl@G))"
    , "(declare-const pshR (pfun sl@REQ sl@G))"
    , "(declare-const pshR@prime (pfun sl@REQ sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@REQ)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-const resL (pfun sl@REQ sl@G))"
    , "(declare-const resL@prime (pfun sl@REQ sl@G))"
    , "(declare-const resR (pfun sl@REQ sl@G))"
    , "(declare-const resR@prime (pfun sl@REQ sl@G))"
    , "(declare-fun apply@@Int@@sl@G ( (pfun Int sl@G) Int ) sl@G)"
    , "(declare-fun apply@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               sl@REQ )"
    , "             sl@G)"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-rest@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun dom@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G) )"
    , "             (set sl@REQ))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun empty-fun@@sl@REQ@@sl@G () (pfun sl@REQ sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@REQ ( (set sl@REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun injective@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl@G (Int sl@G) (pfun Int sl@G))"
    , "(declare-fun mk-fun@@sl@REQ@@sl@G"
    , "             (sl@REQ sl@G)"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@G (sl@G) (set sl@G))"
    , "(declare-fun mk-set@@sl@REQ (sl@REQ) (set sl@REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ovl@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun r@param () sl@REQ)"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun ran@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              true ))"
    , "(define-fun all@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@REQ"
    , "            ( (s1 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@G"
    , "            ( (x sl@G)"
    , "              (s1 (set sl@G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@REQ"
    , "            ( (x sl@REQ)"
    , "              (s1 (set sl@REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@REQ))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (ovl@@sl@REQ@@sl@G f1 empty-fun@@sl@REQ@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl@REQ@@sl@G f1 empty-fun@@sl@REQ@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (ovl@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl@G f2))))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (s2 (set sl@G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                     (tfun@@Int@@sl@G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                       (tfun@@Int@@sl@G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                      (union (dom@@sl@REQ@@sl@G f1) (dom@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))"
    , "                      (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                           (= (apply@@Int@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                     (apply@@Int@@sl@G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                           (= (apply@@Int@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                     (apply@@Int@@sl@G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                           (= (apply@@sl@REQ@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                     (apply@@sl@REQ@@sl@G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                           (= (apply@@sl@REQ@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                     (apply@@sl@REQ@@sl@G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (x2 sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                               x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (= (ran@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@Int@@sl@G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                        (= (apply@@Int@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@sl@REQ@@sl@G f1))"
    , "                      (exists ( (x sl@REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                        (= (apply@@sl@REQ@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (injective@@Int@@sl@G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                                  (=> (= (apply@@Int@@sl@G f1 x) (apply@@Int@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (injective@@sl@REQ@@sl@G f1)"
    , "                      (forall ( (x sl@REQ)"
    , "                                (x2 sl@REQ) )"
    , "                              (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                       (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                                  (=> (= (apply@@sl@REQ@@sl@G f1 x)"
    , "                                         (apply@@sl@REQ@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl@REQ@@sl@G f1) ))))"
    , "(assert (injective@@Int@@sl@G empty-fun@@Int@@sl@G))"
    , "(assert (injective@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (intersect (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (injective@@Int@@sl@G f1))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (injective@@sl@REQ@@sl@G f1))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (ran@@Int@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (ran@@sl@REQ@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@G)"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G x (mk-set@@sl@G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G x (mk-set@@sl@G y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@REQ) )"
    , "                (! (= (elem@@sl@REQ x (mk-set@@sl@REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (mk-set@@sl@REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (finite@@sl@G s1)"
    , "                       (finite@@sl@G (set-diff@@sl@G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (set-diff@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (finite@@sl@REQ s1)"
    , "                       (finite@@sl@REQ (set-diff@@sl@REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (set-diff@@sl@REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl@G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (and (finite@@sl@G s1) (finite@@sl@G s2))"
    , "                       (finite@@sl@G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (and (finite@@sl@REQ s1) (finite@@sl@REQ s2))"
    , "                       (finite@@sl@REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x)) ))))"
    , "(assert (forall ( (x sl@G) )"
    , "                (! (finite@@sl@G (mk-set@@sl@G x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (mk-set@@sl@G x)) ))))"
    , "(assert (forall ( (x sl@REQ) )"
    , "                (! (finite@@sl@REQ (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (mk-set@@sl@REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl@G@Close empty-set@Open@@pfun@@Int@@sl@G@Close))"
    , "(assert (finite@@sl@G empty-set@@sl@G))"
    , "(assert (finite@@sl@REQ empty-set@@sl@REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl@G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl@G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@G s2) (finite@@sl@G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G s2)"
    , "                     (finite@@sl@G s1) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@REQ s2) (finite@@sl@REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ s2)"
    , "                     (finite@@sl@REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; SKIP:p"
    , "(assert (= p@prime p))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:qe"
    , "(assert (= qe@prime qe))"
    , "; SKIP:res"
    , "(assert (= res@prime res))"
    , "; SKIP:resL"
    , "(assert (= resL@prime resL))"
    , "; SKIP:resR"
    , "(assert (= resR@prime resR))"
    , "; m0:act4"
    , "(assert (= emp@prime true))"
    , "; m0:grd0"
    , "(assert (= p q))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:a4"
    , "(assert (= popL@prime"
    , "           (set-diff@@sl@REQ popL (mk-set@@sl@REQ r@param))))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resR) popR)"
    , "           empty-set@@sl@REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resL) popL)"
    , "           empty-set@@sl@REQ))"
    , "; m1:sch0"
    , "(assert (elem@@sl@REQ r@param popL))"
    , "; m1:sch1"
    , "(assert (= p q))"
    , "(assert (not (=> (and (elem@@sl@REQ r popL) (elem@@sl@REQ r popL))"
    , "                 (not (and (elem@@sl@REQ r popL@prime)"
    , "                           (elem@@sl@REQ r popL@prime))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:empty/NEG"
    ]

result8 :: String
result8 = unlines 
    [ "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl@REQ))"
    , "(declare-const popL@prime (set sl@REQ))"
    , "(declare-const popR (set sl@REQ))"
    , "(declare-const popR@prime (set sl@REQ))"
    , "(declare-const pshL (pfun sl@REQ sl@G))"
    , "(declare-const pshL@prime (pfun sl@REQ sl@G))"
    , "(declare-const pshR (pfun sl@REQ sl@G))"
    , "(declare-const pshR@prime (pfun sl@REQ sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@REQ)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-const resL (pfun sl@REQ sl@G))"
    , "(declare-const resL@prime (pfun sl@REQ sl@G))"
    , "(declare-const resR (pfun sl@REQ sl@G))"
    , "(declare-const resR@prime (pfun sl@REQ sl@G))"
    , "(declare-fun apply@@Int@@sl@G ( (pfun Int sl@G) Int ) sl@G)"
    , "(declare-fun apply@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               sl@REQ )"
    , "             sl@G)"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-rest@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun dom@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G) )"
    , "             (set sl@REQ))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun empty-fun@@sl@REQ@@sl@G () (pfun sl@REQ sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@REQ ( (set sl@REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun injective@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl@G (Int sl@G) (pfun Int sl@G))"
    , "(declare-fun mk-fun@@sl@REQ@@sl@G"
    , "             (sl@REQ sl@G)"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@G (sl@G) (set sl@G))"
    , "(declare-fun mk-set@@sl@REQ (sl@REQ) (set sl@REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ovl@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun r@param () sl@REQ)"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun ran@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              true ))"
    , "(define-fun all@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@REQ"
    , "            ( (s1 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@G"
    , "            ( (x sl@G)"
    , "              (s1 (set sl@G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@REQ"
    , "            ( (x sl@REQ)"
    , "              (s1 (set sl@REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@REQ))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (ovl@@sl@REQ@@sl@G f1 empty-fun@@sl@REQ@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl@REQ@@sl@G f1 empty-fun@@sl@REQ@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (ovl@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl@G f2))))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (s2 (set sl@G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                     (tfun@@Int@@sl@G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                       (tfun@@Int@@sl@G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                      (union (dom@@sl@REQ@@sl@G f1) (dom@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))"
    , "                      (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                           (= (apply@@Int@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                     (apply@@Int@@sl@G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                           (= (apply@@Int@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                     (apply@@Int@@sl@G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                           (= (apply@@sl@REQ@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                     (apply@@sl@REQ@@sl@G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                           (= (apply@@sl@REQ@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                     (apply@@sl@REQ@@sl@G f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (x2 sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                               x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (= (ran@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@Int@@sl@G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                        (= (apply@@Int@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@sl@REQ@@sl@G f1))"
    , "                      (exists ( (x sl@REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                        (= (apply@@sl@REQ@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (injective@@Int@@sl@G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                                  (=> (= (apply@@Int@@sl@G f1 x) (apply@@Int@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (injective@@sl@REQ@@sl@G f1)"
    , "                      (forall ( (x sl@REQ)"
    , "                                (x2 sl@REQ) )"
    , "                              (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                       (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                                  (=> (= (apply@@sl@REQ@@sl@G f1 x)"
    , "                                         (apply@@sl@REQ@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl@REQ@@sl@G f1) ))))"
    , "(assert (injective@@Int@@sl@G empty-fun@@Int@@sl@G))"
    , "(assert (injective@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (intersect (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (injective@@Int@@sl@G f1))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (injective@@sl@REQ@@sl@G f1))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (ran@@Int@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (ran@@sl@REQ@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@G)"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G x (mk-set@@sl@G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G x (mk-set@@sl@G y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@REQ) )"
    , "                (! (= (elem@@sl@REQ x (mk-set@@sl@REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (mk-set@@sl@REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (finite@@sl@G s1)"
    , "                       (finite@@sl@G (set-diff@@sl@G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (set-diff@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (finite@@sl@REQ s1)"
    , "                       (finite@@sl@REQ (set-diff@@sl@REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (set-diff@@sl@REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl@G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (and (finite@@sl@G s1) (finite@@sl@G s2))"
    , "                       (finite@@sl@G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (and (finite@@sl@REQ s1) (finite@@sl@REQ s2))"
    , "                       (finite@@sl@REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x)) ))))"
    , "(assert (forall ( (x sl@G) )"
    , "                (! (finite@@sl@G (mk-set@@sl@G x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (mk-set@@sl@G x)) ))))"
    , "(assert (forall ( (x sl@REQ) )"
    , "                (! (finite@@sl@REQ (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (mk-set@@sl@REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl@G@Close empty-set@Open@@pfun@@Int@@sl@G@Close))"
    , "(assert (finite@@sl@G empty-set@@sl@G))"
    , "(assert (finite@@sl@REQ empty-set@@sl@REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl@G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl@G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@G s2) (finite@@sl@G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G s2)"
    , "                     (finite@@sl@G s1) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@REQ s2) (finite@@sl@REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ s2)"
    , "                     (finite@@sl@REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:resR"
    , "(assert (= resR@prime resR))"
    , "; m0:act0"
    , "(assert (= qe@prime (dom-subt@@Int@@sl@G (mk-set@@Int p) qe)))"
    , "; m0:act1"
    , "(assert (= p@prime (+ p 1)))"
    , "; m0:act3"
    , "(assert (= res@prime (apply@@Int@@sl@G qe p)))"
    , "; m0:act4"
    , "(assert (= emp@prime false))"
    , "; m0:grd0"
    , "(assert (< p q))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:a4"
    , "(assert (= popL@prime"
    , "           (set-diff@@sl@REQ popL (mk-set@@sl@REQ r@param))))"
    , "; m1:a5"
    , "(assert (= resL@prime"
    , "           (ovl@@sl@REQ@@sl@G resL"
    , "                              (mk-fun@@sl@REQ@@sl@G r@param (apply@@Int@@sl@G qe p)))))"
    , "; m1:grd0"
    , "(assert (elem@@sl@REQ r@param popL))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resR) popR)"
    , "           empty-set@@sl@REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resL) popL)"
    , "           empty-set@@sl@REQ))"
    , "; m1:sch0"
    , "(assert (elem@@sl@REQ r@param popL))"
    , "; m1:sch1"
    , "(assert (< p q))"
    , "(assert (not (=> (and (elem@@sl@REQ r popL) (elem@@sl@REQ r popL))"
    , "                 (not (and (elem@@sl@REQ r popL@prime)"
    , "                           (elem@@sl@REQ r popL@prime))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/m0:pop:left:non:empty/NEG"
    ]

result9 :: String
result9 = unlines
    [ "; m1/LIVE/m1:prog3/ensure/TR/leadsto"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl@REQ))"
    , "(declare-const popL@prime (set sl@REQ))"
    , "(declare-const popR (set sl@REQ))"
    , "(declare-const popR@prime (set sl@REQ))"
    , "(declare-const pshL (pfun sl@REQ sl@G))"
    , "(declare-const pshL@prime (pfun sl@REQ sl@G))"
    , "(declare-const pshR (pfun sl@REQ sl@G))"
    , "(declare-const pshR@prime (pfun sl@REQ sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@REQ)"
    , "(declare-const r0 sl@REQ)"
    , "(declare-const r@m0-pop-left-empty sl@REQ)"
    , "(declare-const r@m0-pop-left-non-empty sl@REQ)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-const resL (pfun sl@REQ sl@G))"
    , "(declare-const resL@prime (pfun sl@REQ sl@G))"
    , "(declare-const resR (pfun sl@REQ sl@G))"
    , "(declare-const resR@prime (pfun sl@REQ sl@G))"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-rest@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun dom@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G) )"
    , "             (set sl@REQ))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun empty-fun@@sl@REQ@@sl@G () (pfun sl@REQ sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@REQ ( (set sl@REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun injective@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@REQ (sl@REQ) (set sl@REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ovl@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun ran@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              true ))"
    , "(define-fun all@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@REQ"
    , "            ( (s1 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@REQ"
    , "            ( (x sl@REQ)"
    , "              (s1 (set sl@REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@REQ))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (ovl@@sl@REQ@@sl@G f1 empty-fun@@sl@REQ@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl@REQ@@sl@G f1 empty-fun@@sl@REQ@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (ovl@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G f1) ))))"
    , "(assert (forall ( (s2 (set sl@G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                     (tfun@@Int@@sl@G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                       (tfun@@Int@@sl@G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                      (union (dom@@sl@REQ@@sl@G f1) (dom@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))"
    , "                      (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (= (ran@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl@G empty-fun@@Int@@sl@G))"
    , "(assert (injective@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@REQ) )"
    , "                (! (= (elem@@sl@REQ x (mk-set@@sl@REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (mk-set@@sl@REQ y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (finite@@sl@G s1)"
    , "                       (finite@@sl@G (set-diff@@sl@G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (set-diff@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (finite@@sl@REQ s1)"
    , "                       (finite@@sl@REQ (set-diff@@sl@REQ s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (set-diff@@sl@REQ s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl@G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (and (finite@@sl@G s1) (finite@@sl@G s2))"
    , "                       (finite@@sl@G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (and (finite@@sl@REQ s1) (finite@@sl@REQ s2))"
    , "                       (finite@@sl@REQ (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x)) ))))"
    , "(assert (forall ( (x sl@REQ) )"
    , "                (! (finite@@sl@REQ (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ (mk-set@@sl@REQ x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl@G@Close empty-set@Open@@pfun@@Int@@sl@G@Close))"
    , "(assert (finite@@sl@G empty-set@@sl@G))"
    , "(assert (finite@@sl@REQ empty-set@@sl@REQ))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl@G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl@G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@G s2) (finite@@sl@G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G s2)"
    , "                     (finite@@sl@G s1) ))))"
    , "(assert (forall ( (s1 (set sl@REQ))"
    , "                  (s2 (set sl@REQ)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@REQ s2) (finite@@sl@REQ s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@REQ s2)"
    , "                     (finite@@sl@REQ s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (not (forall ( (r sl@REQ)"
    , "                       (r@m0-pop-left-empty sl@REQ)"
    , "                       (r@m0-pop-left-non-empty sl@REQ) )"
    , "                     (=> (and (elem@@sl@REQ r popL)"
    , "                              (elem@@sl@REQ r popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "(assert (not (forall ( (r@m0-pop-left-empty sl@REQ)"
    , "                       (r@m0-pop-left-non-empty sl@REQ) )"
    , "                     (=> (and (elem@@sl@REQ r0 popL)"
    , "                              (elem@@sl@REQ r0 popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "(assert (not (forall ( (r@m0-pop-left-non-empty sl@REQ) )"
    , "                     (=> (and (elem@@sl@REQ r0 popL)"
    , "                              (elem@@sl@REQ r0 popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resR) popR)"
    , "           empty-set@@sl@REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resL) popL)"
    , "           empty-set@@sl@REQ))"
    , "(assert (not (=> (and (elem@@sl@REQ r0 popL)"
    , "                      (elem@@sl@REQ r0 popL)"
    , "                      (elem@@sl@REQ r@m0-pop-left-empty popL)"
    , "                      (elem@@sl@REQ r@m0-pop-left-non-empty popL))"
    , "                 (or (= p q) (< p q)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/m1:prog3/ensure/TR/leadsto"
    ]

path10 :: FilePath 
path10 = "tests/lock-free deque/main6-err0.tex"

result10 :: String
result10 = unlines
    [ "Multiple refinement of progress property m1:prog3"
    , "error 223:5:"
    , "\tm1:prog3"
    , ""
    , "error 255:1:"
    , "\tm1:prog3"
    , ""
    , ""
    ]

path11 :: FilePath 
path11 = "tests/lock-free deque/main6-err1.tex"

result11 :: String
result11 = unlines
    [ "error 223:5:"
    , "    A witness is needed for r in event 'm0:pop:left:empty'"
    , "error 223:5:"
    , "    A witness is needed for r in event 'm0:pop:left:non:empty'"
    ]

path12 :: FilePath
path12 = "tests/lock-free deque/main7-err0.tex"

case12 :: IO (String, Map Label Sequent)
case12 = verify path12 0

result12 :: String
result12 = unlines
    [ "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "passed 3 / 3"
    ]

path13 :: FilePath
path13 = "tests/lock-free deque/main7.tex"

case13 :: IO (String, Map Label Sequent)
case13 = verify path13 0

result13 :: String
result13 = unlines
    [ "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/v@prime"
    , "  o  m0/evt/WD/ACT/act0"
    , "  o  m0/evt/WD/C_SCH"
    , "  o  m0/evt/WD/F_SCH"
    , "  o  m0/evt/WD/GRD"
    , "  o  m0/evt/WWD"
    , "passed 9 / 9"
    ]

case14 :: IO (Either String ([SkipOrEvent],[SkipOrEvent],[SkipOrEvent]))
case14 = runEitherT $ do
    ms <- view' machines <$> get_system path13
    let m0 = ms ! "m0"
        m1 = ms ! "m1"
        m2 = ms ! "m2"
    return $ (m0,m1,m2) & each %~ (M.keys . rightMap . view' events)

result14 :: Either String ([SkipOrEvent],[SkipOrEvent],[SkipOrEvent])
result14 = Right $ ([Left SkipEvent,"evt"],[Left SkipEvent,"evt0","evt1","evt2"],[Left SkipEvent,"evt0","evt1","evt2"])

type ExprSet = [(SkipOrEvent,[Label])]

case15 :: IO (Either String (ExprSet,ExprSet,ExprSet))
case15 = runEitherT $ do
    ms <- view' machines <$> get_system path13
    let m0 = ms ! "m0"
        m1 = ms ! "m1"
        m2 = ms ! "m2"
        exprs e = S.toList $ keysSet (view actions e) `S.union` keysSet (view guards e)
    return $ (m0,m1,m2) & each %~ (M.toList . M.map exprs . rightMap . view' events)

result15 :: Either String (ExprSet,ExprSet,ExprSet)
result15 = Right   ( [(Left SkipEvent,[]),("evt",["act0"])]
                   , [(Left SkipEvent,[]),("evt0",["act0"]),("evt1",["act0","grd0"]),("evt2",["act0"])]
                   , [(Left SkipEvent,[]),("evt0",["act0"]),("evt1",["act0","grd0"]),("evt2",["act0"])])

case16 :: IO (Either String (ExprSet,ExprSet,ExprSet))
case16 = runEitherT $ do
    ms <- view' machines <$> get_system path13
    let m0 = ms ! "m0"
        m1 = ms ! "m1"
        m2 = ms ! "m2"
        decls e = L.map label $ M.keys (view indices e)
    return $ (m0,m1,m2) & each %~ (M.toList . M.map decls . rightMap . view' events)

result16 :: Either String (ExprSet,ExprSet,ExprSet)
result16 = Right   ( [(Left SkipEvent,[]),("evt",["p"])]
                   , [(Left SkipEvent,[]),("evt0",["p"]),("evt1",["p"]),("evt2",["p","q"])]
                   , [(Left SkipEvent,[]),("evt0",["p"]),("evt1",["p"]),("evt2",["p","q"])])

path17 :: FilePath
path17 = "tests/lock-free deque/main8-err0.tex"

case17 :: IO String
case17 = find_errors path17

result17 :: String
result17 = unlines
    [ "error 60:12:"
    , "    expecting more arguments"
    ]

path18 :: FilePath
path18 = "tests/lock-free deque/main8-err1.tex"

case18 :: IO String
case18 = find_errors path18

result18 :: String
result18 = concat
    [ "no errors"
    ]

path19 :: FilePath
path19 = "tests/lock-free deque/main8.tex"

case19 :: IO String
case19 = proof_obligation path19 "m1/resp:pop:left/F_SCH/replace/eqv" 1

result19 :: String
result19 = unlines
    [ "; m1/resp:pop:left/F_SCH/replace/eqv"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(declare-sort sl@Req 0)"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const ppL (set sl@Req))"
    , "(declare-const ppL@prime (set sl@Req))"
    , "(declare-const ppR (set sl@Req))"
    , "(declare-const ppR@prime (set sl@Req))"
    , "(declare-const psL (pfun sl@Req sl@G))"
    , "(declare-const psL@prime (pfun sl@Req sl@G))"
    , "(declare-const psR (pfun sl@Req sl@G))"
    , "(declare-const psR@prime (pfun sl@Req sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@Req)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@Req ( (set sl@Req) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@Req (sl@Req) (set sl@Req))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              true ))"
    , "(define-fun all@@sl@Req"
    , "            ()"
    , "            (set sl@Req)"
    , "            ( (as const (set sl@Req))"
    , "              true ))"
    , "(define-fun all@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@Req"
    , "            ( (s1 (set sl@Req)) )"
    , "            (set sl@Req)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@Req"
    , "            ( (x sl@Req)"
    , "              (s1 (set sl@Req)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@Req"
    , "            ()"
    , "            (set sl@Req)"
    , "            ( (as const (set sl@Req))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@Req"
    , "            ( (s1 (set sl@Req))"
    , "              (s2 (set sl@Req)) )"
    , "            (set sl@Req)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@Req"
    , "            ()"
    , "            (set sl@Req)"
    , "            ( (as const (set sl@Req))"
    , "              true ))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@Req"
    , "            ( (s1 (set sl@Req))"
    , "              (s2 (set sl@Req)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G f1 empty-fun@@Int@@sl@G) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@sl@G empty-fun@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (s2 (set sl@G)) )"
    , "                (! (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                     (tfun@@Int@@sl@G empty-set@@Int s2))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close empty-fun@@Int@@sl@G"
    , "                                                       (tfun@@Int@@sl@G empty-set@@Int s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))"
    , "                      (intersect s1 (dom@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (injective@@Int@@sl@G empty-fun@@Int@@sl@G))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@Req)"
    , "                  (y sl@Req) )"
    , "                (! (= (elem@@sl@Req x (mk-set@@sl@Req y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Req x (mk-set@@sl@Req y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (set-diff@Open@@pfun@@Int@@sl@G@Close s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (finite@@sl@G s1)"
    , "                       (finite@@sl@G (set-diff@@sl@G s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (set-diff@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Req))"
    , "                  (s2 (set sl@Req)) )"
    , "                (! (=> (finite@@sl@Req s1)"
    , "                       (finite@@sl@Req (set-diff@@sl@Req s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Req (set-diff@@sl@Req s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (and (finite@Open@@pfun@@Int@@sl@G@Close s1)"
    , "                            (finite@Open@@pfun@@Int@@sl@G@Close s2))"
    , "                       (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (and (finite@@sl@G s1) (finite@@sl@G s2))"
    , "                       (finite@@sl@G (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Req))"
    , "                  (s2 (set sl@Req)) )"
    , "                (! (=> (and (finite@@sl@Req s1) (finite@@sl@Req s2))"
    , "                       (finite@@sl@Req (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Req (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G)) )"
    , "                (! (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close (mk-set@Open@@pfun@@Int@@sl@G@Close x)) ))))"
    , "(assert (forall ( (x sl@Req) )"
    , "                (! (finite@@sl@Req (mk-set@@sl@Req x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Req (mk-set@@sl@Req x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@Open@@pfun@@Int@@sl@G@Close empty-set@Open@@pfun@@Int@@sl@G@Close))"
    , "(assert (finite@@sl@G empty-set@@sl@G))"
    , "(assert (finite@@sl@Req empty-set@@sl@Req))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set (pfun Int sl@G)))"
    , "                  (s2 (set (pfun Int sl@G))) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                           (finite@Open@@pfun@@Int@@sl@G@Close s1)))"
    , "                   :pattern"
    , "                   ( (finite@Open@@pfun@@Int@@sl@G@Close s2)"
    , "                     (finite@Open@@pfun@@Int@@sl@G@Close s1) ))))"
    , "(assert (forall ( (s1 (set sl@G))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@G s2) (finite@@sl@G s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@G s2)"
    , "                     (finite@@sl@G s1) ))))"
    , "(assert (forall ( (s1 (set sl@Req))"
    , "                  (s2 (set sl@Req)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@Req s2) (finite@@sl@Req s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Req s2)"
    , "                     (finite@@sl@Req s1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (elem@@sl@Req r ppL))"
    , "; m0:sch0"
    , "(assert (elem@@sl@Req r ppL))"
    , "; m1:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m1:inv1"
    , "(assert (<= p q))"
    , "(assert (not (= (or (= p q) (not (= p q))) true)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/resp:pop:left/F_SCH/replace/eqv"
    ]
