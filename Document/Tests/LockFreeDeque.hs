module Document.Tests.LockFreeDeque 
    -- ( test_case, test, path4, result4 )
where

    -- Modules
import Document.Tests.Suite

    -- Libraries

import Tests.UnitTest

test_case :: TestCase
test_case = test

test :: TestCase
test = test_cases
            "Specification and refinement of a lock-free algorithm"
            [ (POCase "test 0, verification, specification with intervals" 
                (verify path0 0) result0)
            , (POCase "test 1, verification, failed proof with intervals" 
                (verify path1 0) result1)
            , (StringCase "test 2, error message name clash in guards" 
                case2 result2)
            , (POCase "test 3, verification, looking up function outside of domain" 
                (verify path3 0) result3)
            , (POCase "test 4, m1, liveness implemented with conditional behavior"
                (verify path4 1) result4)
            , (StringCase "test 5, transient, two branches, enablement of non-empty"
                (proof_obligation path4 "m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:non:empty/EN" 1)
                result5)
            , (StringCase "test 6, transient, two branches, enablement of empty"
                (proof_obligation path4 "m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:empty/EN" 1)
                result6)
            , (StringCase "test 7, transient, two branches, negation of empty"
                (proof_obligation path4 "m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:empty/NEG" 1)
                result7)
            , (StringCase "test 8, transient, two branches, negation of non-empty"
                (proof_obligation path4 "m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:empty/NEG" 1)
                result8)
            , (StringCase "test 9, transient, two branches, follow and disjunction"
                (proof_obligation path4 "m1/m1:prog3/REF/ensure/m1/TR/leadsto" 1)
                result9)
            , (StringCase "test 10, duplicate refinement of liveness properties"
                (find_errors path10)
                result10)
            , StringCase "test 11, missing witness"
                (find_errors path11)
                result11
            ]            

result0 :: String
result0 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/INIT/WD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/emp@prime"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/FIS/res@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/INV/m0:inv1"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act3"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act4"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , "  o  m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:right/FIS/emp@prime"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/FIS/res@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/INV/m0:inv1"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act3"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act4"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:push:left/FIS/emp@prime"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , "  o  m0/m0:push:left/FIS/res@prime"
    , "  o  m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/INV/m0:inv1"
    , "  o  m0/m0:push:left/SCH"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:right/FIS/emp@prime"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , "  o  m0/m0:push:right/FIS/res@prime"
    , "  o  m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/INV/m0:inv1"
    , "  o  m0/m0:push:right/SCH"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , "  o  m0/m0:push:right/WD/GRD"
    , "passed 63 / 63"
    ]

path0 :: FilePath
path0 = "tests/lock-free deque/main.tex"

path1 :: FilePath
path1 = "tests/lock-free deque/main2.tex"

result1 :: String
result1 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/WD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , "  o  m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , " xxx m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/SCH"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act2"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , " xxx m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/SCH"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act1"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , "  o  m0/m0:push:right/WD/GRD"
    , "passed 48 / 50"
    ]

path2 :: String
path2 = "tests/lock-free deque/main3.tex"

case2 :: IO String
case2 = find_errors path2


result2 :: String
result2 = unlines
    [ "error: Multiple expressions with the label m0:inv0"
    , "\tinvariant: (41,15)"
    , "\tinvariant: (44,3)"
    , ""
    , "error: Multiple expressions with the label m0:grd0"
    , "\tguard (event m0:pop:right): (86,3)"
    , "\tguard (event m0:pop:right): (87,3)"
    , ""
    ]

path3 :: String
path3 = "tests/lock-free deque/main4.tex"

result3 :: String
result3 = unlines
    [ "  o  m0/INIT/FIS/p"
    , "  o  m0/INIT/FIS/q"
    , "  o  m0/INIT/FIS/qe"
    , "  o  m0/INIT/INV/m0:inv0"
    , "  o  m0/INIT/INV/m0:inv1"
    , "  o  m0/INIT/WD"
    , "  o  m0/INV/WD"
    , "  o  m0/m0:pop:left/FIS/p@prime"
    , "  o  m0/m0:pop:left/FIS/q@prime"
    , "  o  m0/m0:pop:left/FIS/qe@prime"
    , "  o  m0/m0:pop:left/INV/m0:inv0"
    , "  o  m0/m0:pop:left/INV/m0:inv1"
    , "  o  m0/m0:pop:left/SCH"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:left/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:left/WD/C_SCH"
    , "  o  m0/m0:pop:left/WD/F_SCH"
    , " xxx m0/m0:pop:left/WD/GRD"
    , "  o  m0/m0:pop:right/FIS/p@prime"
    , "  o  m0/m0:pop:right/FIS/q@prime"
    , "  o  m0/m0:pop:right/FIS/qe@prime"
    , "  o  m0/m0:pop:right/INV/m0:inv0"
    , "  o  m0/m0:pop:right/INV/m0:inv1"
    , "  o  m0/m0:pop:right/SCH"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act0"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act1"
    , "  o  m0/m0:pop:right/WD/ACT/m0:act2"
    , "  o  m0/m0:pop:right/WD/C_SCH"
    , "  o  m0/m0:pop:right/WD/F_SCH"
    , "  o  m0/m0:pop:right/WD/GRD"
    , "  o  m0/m0:push:left/FIS/p@prime"
    , "  o  m0/m0:push:left/FIS/q@prime"
    , "  o  m0/m0:push:left/FIS/qe@prime"
    , "  o  m0/m0:push:left/INV/m0:inv0"
    , "  o  m0/m0:push:left/INV/m0:inv1"
    , "  o  m0/m0:push:left/SCH"
    , "  o  m0/m0:push:left/WD/ACT/m0:act0"
    , "  o  m0/m0:push:left/WD/ACT/m0:act1"
    , "  o  m0/m0:push:left/WD/ACT/m0:act2"
    , "  o  m0/m0:push:left/WD/C_SCH"
    , "  o  m0/m0:push:left/WD/F_SCH"
    , "  o  m0/m0:push:left/WD/GRD"
    , "  o  m0/m0:push:right/FIS/p@prime"
    , "  o  m0/m0:push:right/FIS/q@prime"
    , "  o  m0/m0:push:right/FIS/qe@prime"
    , "  o  m0/m0:push:right/INV/m0:inv0"
    , "  o  m0/m0:push:right/INV/m0:inv1"
    , "  o  m0/m0:push:right/SCH"
    , "  o  m0/m0:push:right/WD/ACT/m0:act0"
    , "  o  m0/m0:push:right/WD/ACT/m0:act1"
    , "  o  m0/m0:push:right/WD/ACT/m0:act2"
    , "  o  m0/m0:push:right/WD/C_SCH"
    , "  o  m0/m0:push:right/WD/F_SCH"
    , " xxx m0/m0:push:right/WD/GRD"
    , "passed 53 / 55"
    ]

path4 :: FilePath
path4 = "tests/lock-free deque/main6.tex"

result4 :: String
result4 = unlines
    [ "  o  m1/INIT/FIS/p"
    , "  o  m1/INIT/FIS/q"
    , "  o  m1/INIT/FIS/qe"
    , "  o  m1/INIT/FIS/resL"
    , "  o  m1/INIT/FIS/resR"
    , "  o  m1/INIT/INV/m1:inv0"
    , "  o  m1/INIT/INV/m1:inv1"
    , "  o  m1/INIT/WD"
    , "  o  m1/INV/WD"
    , "  o  m1/m0:pop:left:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:left:empty/FIS/p@prime"
    , "  o  m1/m0:pop:left:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:left:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:left:empty/FIS/q@prime"
    , "  o  m1/m0:pop:left:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:left:empty/FIS/res@prime"
    , "  o  m1/m0:pop:left:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:left:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:left:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:left:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:left:empty/SCH"
    , "  o  m1/m0:pop:left:empty/SCH/m1/0/REF/replace/prog/leadsto"
    , "  o  m1/m0:pop:left:empty/SCH/m1/0/REF/replace/str"
    , "  o  m1/m0:pop:left:empty/SCH/m1/1/REF/weaken"
    , "  o  m1/m0:pop:left:empty/WD/ACT/m1:a4"
    , "  o  m1/m0:pop:left:empty/WD/C_SCH"
    , "  o  m1/m0:pop:left:empty/WD/F_SCH"
    , "  o  m1/m0:pop:left:empty/WD/GRD"
    , "  o  m1/m0:pop:left:non:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/p@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/q@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/res@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:left:non:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:left:non:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:left:non:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:left:non:empty/SCH"
    , "  o  m1/m0:pop:left:non:empty/SCH/m1/0/REF/replace/prog/leadsto"
    , "  o  m1/m0:pop:left:non:empty/SCH/m1/0/REF/replace/str"
    , "  o  m1/m0:pop:left:non:empty/SCH/m1/1/REF/weaken"
    , "  o  m1/m0:pop:left:non:empty/WD/ACT/m1:a4"
    , "  o  m1/m0:pop:left:non:empty/WD/ACT/m1:a5"
    , "  o  m1/m0:pop:left:non:empty/WD/C_SCH"
    , "  o  m1/m0:pop:left:non:empty/WD/F_SCH"
    , "  o  m1/m0:pop:left:non:empty/WD/GRD"
    , "  o  m1/m0:pop:right:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:right:empty/FIS/p@prime"
    , "  o  m1/m0:pop:right:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:right:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:right:empty/FIS/q@prime"
    , "  o  m1/m0:pop:right:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:right:empty/FIS/res@prime"
    , "  o  m1/m0:pop:right:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:right:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:right:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:right:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:right:empty/SCH"
    , "  o  m1/m0:pop:right:empty/SCH/m1/0/REF/replace/prog/leadsto"
    , "  o  m1/m0:pop:right:empty/SCH/m1/0/REF/replace/str"
    , "  o  m1/m0:pop:right:empty/SCH/m1/1/REF/weaken"
    , "  o  m1/m0:pop:right:empty/WD/ACT/m1:a2"
    , "  o  m1/m0:pop:right:empty/WD/C_SCH"
    , "  o  m1/m0:pop:right:empty/WD/F_SCH"
    , "  o  m1/m0:pop:right:empty/WD/GRD"
    , "  o  m1/m0:pop:right:non:empty/FIS/emp@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/p@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/popL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/popR@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/pshL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/pshR@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/q@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/qe@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/res@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/resL@prime"
    , "  o  m1/m0:pop:right:non:empty/FIS/resR@prime"
    , "  o  m1/m0:pop:right:non:empty/INV/m1:inv0"
    , "  o  m1/m0:pop:right:non:empty/INV/m1:inv1"
    , "  o  m1/m0:pop:right:non:empty/SCH"
    , "  o  m1/m0:pop:right:non:empty/SCH/m1/0/REF/replace/prog/leadsto"
    , "  o  m1/m0:pop:right:non:empty/SCH/m1/0/REF/replace/str"
    , "  o  m1/m0:pop:right:non:empty/SCH/m1/1/REF/weaken"
    , "  o  m1/m0:pop:right:non:empty/WD/ACT/m1:a2"
    , "  o  m1/m0:pop:right:non:empty/WD/ACT/m1:a3"
    , "  o  m1/m0:pop:right:non:empty/WD/C_SCH"
    , "  o  m1/m0:pop:right:non:empty/WD/F_SCH"
    , "  o  m1/m0:pop:right:non:empty/WD/GRD"
    , "  o  m1/m0:push:left/FIS/emp@prime"
    , "  o  m1/m0:push:left/FIS/p@prime"
    , "  o  m1/m0:push:left/FIS/popL@prime"
    , "  o  m1/m0:push:left/FIS/popR@prime"
    , "  o  m1/m0:push:left/FIS/pshL@prime"
    , "  o  m1/m0:push:left/FIS/pshR@prime"
    , "  o  m1/m0:push:left/FIS/q@prime"
    , "  o  m1/m0:push:left/FIS/qe@prime"
    , "  o  m1/m0:push:left/FIS/res@prime"
    , "  o  m1/m0:push:left/FIS/resL@prime"
    , "  o  m1/m0:push:left/FIS/resR@prime"
    , "  o  m1/m0:push:left/INV/m1:inv0"
    , "  o  m1/m0:push:left/INV/m1:inv1"
    , "  o  m1/m0:push:left/SCH"
    , "  o  m1/m0:push:left/SCH/m1/0/REF/weaken"
    , "  o  m1/m0:push:left/WD/ACT/m1:a0"
    , "  o  m1/m0:push:left/WD/C_SCH"
    , "  o  m1/m0:push:left/WD/F_SCH"
    , "  o  m1/m0:push:left/WD/GRD"
    , "  o  m1/m0:push:right/FIS/emp@prime"
    , "  o  m1/m0:push:right/FIS/p@prime"
    , "  o  m1/m0:push:right/FIS/popL@prime"
    , "  o  m1/m0:push:right/FIS/popR@prime"
    , "  o  m1/m0:push:right/FIS/pshL@prime"
    , "  o  m1/m0:push:right/FIS/pshR@prime"
    , "  o  m1/m0:push:right/FIS/q@prime"
    , "  o  m1/m0:push:right/FIS/qe@prime"
    , "  o  m1/m0:push:right/FIS/res@prime"
    , "  o  m1/m0:push:right/FIS/resL@prime"
    , "  o  m1/m0:push:right/FIS/resR@prime"
    , "  o  m1/m0:push:right/INV/m1:inv0"
    , "  o  m1/m0:push:right/INV/m1:inv1"
    , "  o  m1/m0:push:right/SCH"
    , "  o  m1/m0:push:right/SCH/m1/0/REF/weaken"
    , "  o  m1/m0:push:right/WD/ACT/m1:a0"
    , "  o  m1/m0:push:right/WD/C_SCH"
    , "  o  m1/m0:push:right/WD/F_SCH"
    , "  o  m1/m0:push:right/WD/GRD"
    , "  o  m1/m1:prog0/PROG/WD/lhs"
    , "  o  m1/m1:prog0/PROG/WD/rhs"
    , "  o  m1/m1:prog0/REF/ensure/m1/SAF/WD/lhs"
    , "  o  m1/m1:prog0/REF/ensure/m1/SAF/WD/rhs"
    , "  o  m1/m1:prog0/REF/ensure/m1/TR/WD"
    , "  o  m1/m1:prog0/REF/ensure/m1/TR/WD/witness/r"
    , "  o  m1/m1:prog0/REF/ensure/m1/TR/WFIS/r/r@prime"
    , "  o  m1/m1:prog0/REF/ensure/m1/TR/m0:push:left/EN"
    , "  o  m1/m1:prog0/REF/ensure/m1/TR/m0:push:left/NEG"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:pop:left:empty/SAF"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:pop:left:non:empty/SAF"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:pop:right:empty/SAF"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:pop:right:non:empty/SAF"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:push:left/SAF"
    , "  o  m1/m1:prog0/REF/ensure/m1/m0:push:right/SAF"
    , "  o  m1/m1:prog1/PROG/WD/lhs"
    , "  o  m1/m1:prog1/PROG/WD/rhs"
    , "  o  m1/m1:prog1/REF/ensure/m1/SAF/WD/lhs"
    , "  o  m1/m1:prog1/REF/ensure/m1/SAF/WD/rhs"
    , "  o  m1/m1:prog1/REF/ensure/m1/TR/WD"
    , "  o  m1/m1:prog1/REF/ensure/m1/TR/WD/witness/r"
    , "  o  m1/m1:prog1/REF/ensure/m1/TR/WFIS/r/r@prime"
    , "  o  m1/m1:prog1/REF/ensure/m1/TR/m0:push:right/EN"
    , "  o  m1/m1:prog1/REF/ensure/m1/TR/m0:push:right/NEG"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:pop:left:empty/SAF"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:pop:left:non:empty/SAF"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:pop:right:empty/SAF"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:pop:right:non:empty/SAF"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:push:left/SAF"
    , "  o  m1/m1:prog1/REF/ensure/m1/m0:push:right/SAF"
    , "  o  m1/m1:prog2/PROG/WD/lhs"
    , "  o  m1/m1:prog2/PROG/WD/rhs"
    , "  o  m1/m1:prog2/REF/ensure/m1/SAF/WD/lhs"
    , "  o  m1/m1:prog2/REF/ensure/m1/SAF/WD/rhs"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/WD"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/WD/witness/r"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/WFIS/r/r@prime"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/leadsto"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/m0:pop:right:empty/EN"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/m0:pop:right:empty/NEG"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/m0:pop:right:non:empty/EN"
    , "  o  m1/m1:prog2/REF/ensure/m1/TR/m0:pop:right:non:empty/NEG"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:pop:left:empty/SAF"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:pop:left:non:empty/SAF"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:pop:right:empty/SAF"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:pop:right:non:empty/SAF"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:push:left/SAF"
    , "  o  m1/m1:prog2/REF/ensure/m1/m0:push:right/SAF"
    , "  o  m1/m1:prog3/PROG/WD/lhs"
    , "  o  m1/m1:prog3/PROG/WD/rhs"
    , "  o  m1/m1:prog3/REF/ensure/m1/SAF/WD/lhs"
    , "  o  m1/m1:prog3/REF/ensure/m1/SAF/WD/rhs"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/WD"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/WD/witness/r"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/WFIS/r/r@prime"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/leadsto"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:empty/EN"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:empty/NEG"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:non:empty/EN"
    , "  o  m1/m1:prog3/REF/ensure/m1/TR/m0:pop:left:non:empty/NEG"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:pop:left:empty/SAF"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:pop:left:non:empty/SAF"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:pop:right:empty/SAF"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:pop:right:non:empty/SAF"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:push:left/SAF"
    , "  o  m1/m1:prog3/REF/ensure/m1/m0:push:right/SAF"
    , "passed 199 / 199"
    ]

    -- enablement non-empty
result5 :: String
result5 = unlines 
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl@REQ))"
    , "(declare-const popL@prime (set sl@REQ))"
    , "(declare-const popR (set sl@REQ))"
    , "(declare-const popR@prime (set sl@REQ))"
    , "(declare-const pshL (pfun sl@REQ sl@G))"
    , "(declare-const pshL@prime (pfun sl@REQ sl@G))"
    , "(declare-const pshR (pfun sl@REQ sl@G))"
    , "(declare-const pshR@prime (pfun sl@REQ sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@REQ)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-const resL (pfun sl@REQ sl@G))"
    , "(declare-const resL@prime (pfun sl@REQ sl@G))"
    , "(declare-const resR (pfun sl@REQ sl@G))"
    , "(declare-const resR@prime (pfun sl@REQ sl@G))"
    , "(declare-fun apply@@Int@@sl@G ( (pfun Int sl@G) Int ) sl@G)"
    , "(declare-fun apply@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               sl@REQ )"
    , "             sl@G)"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-rest@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun dom@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G) )"
    , "             (set sl@REQ))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun empty-fun@@sl@REQ@@sl@G () (pfun sl@REQ sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@REQ ( (set sl@REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun injective@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl@G (Int sl@G) (pfun Int sl@G))"
    , "(declare-fun mk-fun@@sl@REQ@@sl@G"
    , "             (sl@REQ sl@G)"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@G (sl@G) (set sl@G))"
    , "(declare-fun mk-set@@sl@REQ (sl@REQ) (set sl@REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ovl@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun r@param () sl@REQ)"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun ran@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@sl@REQ"
    , "            ( (s1 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ((_ map not) s1))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@G"
    , "            ( (x sl@G)"
    , "              (s1 (set sl@G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@REQ"
    , "            ( (x sl@REQ)"
    , "              (s1 (set sl@REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                      (union (dom@@sl@REQ@@sl@G f1) (dom@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2)) ))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl@G f2))))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))"
    , "                      (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select empty-fun@@Int@@sl@G x)"
    , "                      (as Nothing (Maybe sl@G)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Int@@sl@G x) ))))"
    , "(assert (forall ( (x sl@REQ) )"
    , "                (! (= (select empty-fun@@sl@REQ@@sl@G x)"
    , "                      (as Nothing (Maybe sl@G)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@sl@REQ@@sl@G x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl@G) )"
    , "                (! (= (select (mk-fun@@Int@@sl@G x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe sl@G))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Int@@sl@G x y) x2) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (x2 sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (select (mk-fun@@sl@REQ@@sl@G x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe sl@G))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@sl@REQ@@sl@G x y) x2) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (select (ovl@@Int@@sl@G f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe sl@G)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (select (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe sl@G)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int sl@G)) )"
    , "                (! (= (select (dom@@Int@@sl@G f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe sl@G)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Int@@sl@G f1) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (select (dom@@sl@REQ@@sl@G f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe sl@G)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@sl@REQ@@sl@G f1) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G)"
    , "                  (f1 (pfun Int sl@G)) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                           (= (apply@@Int@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G)"
    , "                  (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                           (= (apply@@sl@REQ@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x2 Int)"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x2 sl@REQ)"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                               x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (= (ran@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@Int@@sl@G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                        (= (apply@@Int@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@sl@REQ@@sl@G f1))"
    , "                      (exists ( (x sl@REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                        (= (apply@@sl@REQ@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (subset (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                           (union (ran@@Int@@sl@G f1) (ran@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                             (union (ran@@Int@@sl@G f1) (ran@@Int@@sl@G f2))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (subset (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                           (union (ran@@sl@REQ@@sl@G f1) (ran@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                             (union (ran@@sl@REQ@@sl@G f1) (ran@@sl@REQ@@sl@G f2))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (injective@@Int@@sl@G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                                  (=> (= (apply@@Int@@sl@G f1 x) (apply@@Int@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (injective@@sl@REQ@@sl@G f1)"
    , "                      (forall ( (x sl@REQ)"
    , "                                (x2 sl@REQ) )"
    , "                              (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                       (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                                  (=> (= (apply@@sl@REQ@@sl@G f1 x)"
    , "                                         (apply@@sl@REQ@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl@REQ@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (injective@@Int@@sl@G f1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1))"
    , "                          (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                          (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (injective@@sl@REQ@@sl@G f1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1))"
    , "                          (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                          (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (x2 Int) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (x2 sl@REQ) )"
    , "                (! (=> (and (not (= x x2))"
    , "                            (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G (mk-set@@Int x) f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G (mk-set@@Int x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (not (elem@@Int x s1))"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (and (not (elem@@sl@REQ x s1))"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (elem@@sl@REQ x (intersect (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (injective@@Int@@sl@G f1))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (injective@@sl@REQ@@sl@G f1))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (ran@@Int@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (ran@@sl@REQ@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@G)"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G x (mk-set@@sl@G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G x (mk-set@@sl@G y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@REQ) )"
    , "                (! (= (elem@@sl@REQ x (mk-set@@sl@REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (mk-set@@sl@REQ y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resR) popR)"
    , "           empty-set@@sl@REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resL) popL)"
    , "           empty-set@@sl@REQ))"
    , "(assert (not (=> (and (elem@@sl@REQ r popL) (elem@@sl@REQ r popL))"
    , "                 (elem@@sl@REQ r@param popL))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

result6 :: String
result6 = unlines 
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl@REQ))"
    , "(declare-const popL@prime (set sl@REQ))"
    , "(declare-const popR (set sl@REQ))"
    , "(declare-const popR@prime (set sl@REQ))"
    , "(declare-const pshL (pfun sl@REQ sl@G))"
    , "(declare-const pshL@prime (pfun sl@REQ sl@G))"
    , "(declare-const pshR (pfun sl@REQ sl@G))"
    , "(declare-const pshR@prime (pfun sl@REQ sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@REQ)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-const resL (pfun sl@REQ sl@G))"
    , "(declare-const resL@prime (pfun sl@REQ sl@G))"
    , "(declare-const resR (pfun sl@REQ sl@G))"
    , "(declare-const resR@prime (pfun sl@REQ sl@G))"
    , "(declare-fun apply@@Int@@sl@G ( (pfun Int sl@G) Int ) sl@G)"
    , "(declare-fun apply@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               sl@REQ )"
    , "             sl@G)"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-rest@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun dom@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G) )"
    , "             (set sl@REQ))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun empty-fun@@sl@REQ@@sl@G () (pfun sl@REQ sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@REQ ( (set sl@REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun injective@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl@G (Int sl@G) (pfun Int sl@G))"
    , "(declare-fun mk-fun@@sl@REQ@@sl@G"
    , "             (sl@REQ sl@G)"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@G (sl@G) (set sl@G))"
    , "(declare-fun mk-set@@sl@REQ (sl@REQ) (set sl@REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ovl@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun r@param () sl@REQ)"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun ran@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@sl@REQ"
    , "            ( (s1 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ((_ map not) s1))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@G"
    , "            ( (x sl@G)"
    , "              (s1 (set sl@G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@REQ"
    , "            ( (x sl@REQ)"
    , "              (s1 (set sl@REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                      (union (dom@@sl@REQ@@sl@G f1) (dom@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2)) ))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl@G f2))))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))"
    , "                      (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select empty-fun@@Int@@sl@G x)"
    , "                      (as Nothing (Maybe sl@G)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Int@@sl@G x) ))))"
    , "(assert (forall ( (x sl@REQ) )"
    , "                (! (= (select empty-fun@@sl@REQ@@sl@G x)"
    , "                      (as Nothing (Maybe sl@G)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@sl@REQ@@sl@G x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl@G) )"
    , "                (! (= (select (mk-fun@@Int@@sl@G x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe sl@G))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Int@@sl@G x y) x2) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (x2 sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (select (mk-fun@@sl@REQ@@sl@G x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe sl@G))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@sl@REQ@@sl@G x y) x2) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (select (ovl@@Int@@sl@G f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe sl@G)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (select (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe sl@G)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int sl@G)) )"
    , "                (! (= (select (dom@@Int@@sl@G f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe sl@G)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Int@@sl@G f1) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (select (dom@@sl@REQ@@sl@G f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe sl@G)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@sl@REQ@@sl@G f1) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G)"
    , "                  (f1 (pfun Int sl@G)) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                           (= (apply@@Int@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G)"
    , "                  (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                           (= (apply@@sl@REQ@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x2 Int)"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x2 sl@REQ)"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                               x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (= (ran@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@Int@@sl@G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                        (= (apply@@Int@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@sl@REQ@@sl@G f1))"
    , "                      (exists ( (x sl@REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                        (= (apply@@sl@REQ@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (subset (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                           (union (ran@@Int@@sl@G f1) (ran@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                             (union (ran@@Int@@sl@G f1) (ran@@Int@@sl@G f2))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (subset (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                           (union (ran@@sl@REQ@@sl@G f1) (ran@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                             (union (ran@@sl@REQ@@sl@G f1) (ran@@sl@REQ@@sl@G f2))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (injective@@Int@@sl@G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                                  (=> (= (apply@@Int@@sl@G f1 x) (apply@@Int@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (injective@@sl@REQ@@sl@G f1)"
    , "                      (forall ( (x sl@REQ)"
    , "                                (x2 sl@REQ) )"
    , "                              (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                       (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                                  (=> (= (apply@@sl@REQ@@sl@G f1 x)"
    , "                                         (apply@@sl@REQ@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl@REQ@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (injective@@Int@@sl@G f1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1))"
    , "                          (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                          (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (injective@@sl@REQ@@sl@G f1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1))"
    , "                          (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                          (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (x2 Int) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (x2 sl@REQ) )"
    , "                (! (=> (and (not (= x x2))"
    , "                            (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G (mk-set@@Int x) f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G (mk-set@@Int x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (not (elem@@Int x s1))"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (and (not (elem@@sl@REQ x s1))"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (elem@@sl@REQ x (intersect (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (injective@@Int@@sl@G f1))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (injective@@sl@REQ@@sl@G f1))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (ran@@Int@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (ran@@sl@REQ@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@G)"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G x (mk-set@@sl@G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G x (mk-set@@sl@G y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@REQ) )"
    , "                (! (= (elem@@sl@REQ x (mk-set@@sl@REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (mk-set@@sl@REQ y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resR) popR)"
    , "           empty-set@@sl@REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resL) popL)"
    , "           empty-set@@sl@REQ))"
    , "(assert (not (=> (and (elem@@sl@REQ r popL) (elem@@sl@REQ r popL))"
    , "                 (elem@@sl@REQ r@param popL))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

result7 :: String
result7 = unlines 
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl@REQ))"
    , "(declare-const popL@prime (set sl@REQ))"
    , "(declare-const popR (set sl@REQ))"
    , "(declare-const popR@prime (set sl@REQ))"
    , "(declare-const pshL (pfun sl@REQ sl@G))"
    , "(declare-const pshL@prime (pfun sl@REQ sl@G))"
    , "(declare-const pshR (pfun sl@REQ sl@G))"
    , "(declare-const pshR@prime (pfun sl@REQ sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@REQ)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-const resL (pfun sl@REQ sl@G))"
    , "(declare-const resL@prime (pfun sl@REQ sl@G))"
    , "(declare-const resR (pfun sl@REQ sl@G))"
    , "(declare-const resR@prime (pfun sl@REQ sl@G))"
    , "(declare-fun apply@@Int@@sl@G ( (pfun Int sl@G) Int ) sl@G)"
    , "(declare-fun apply@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               sl@REQ )"
    , "             sl@G)"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-rest@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun dom@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G) )"
    , "             (set sl@REQ))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun empty-fun@@sl@REQ@@sl@G () (pfun sl@REQ sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@REQ ( (set sl@REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun injective@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl@G (Int sl@G) (pfun Int sl@G))"
    , "(declare-fun mk-fun@@sl@REQ@@sl@G"
    , "             (sl@REQ sl@G)"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@G (sl@G) (set sl@G))"
    , "(declare-fun mk-set@@sl@REQ (sl@REQ) (set sl@REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ovl@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun r@param () sl@REQ)"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun ran@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@sl@REQ"
    , "            ( (s1 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ((_ map not) s1))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@G"
    , "            ( (x sl@G)"
    , "              (s1 (set sl@G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@REQ"
    , "            ( (x sl@REQ)"
    , "              (s1 (set sl@REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                      (union (dom@@sl@REQ@@sl@G f1) (dom@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2)) ))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl@G f2))))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))"
    , "                      (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select empty-fun@@Int@@sl@G x)"
    , "                      (as Nothing (Maybe sl@G)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Int@@sl@G x) ))))"
    , "(assert (forall ( (x sl@REQ) )"
    , "                (! (= (select empty-fun@@sl@REQ@@sl@G x)"
    , "                      (as Nothing (Maybe sl@G)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@sl@REQ@@sl@G x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl@G) )"
    , "                (! (= (select (mk-fun@@Int@@sl@G x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe sl@G))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Int@@sl@G x y) x2) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (x2 sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (select (mk-fun@@sl@REQ@@sl@G x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe sl@G))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@sl@REQ@@sl@G x y) x2) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (select (ovl@@Int@@sl@G f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe sl@G)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (select (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe sl@G)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int sl@G)) )"
    , "                (! (= (select (dom@@Int@@sl@G f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe sl@G)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Int@@sl@G f1) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (select (dom@@sl@REQ@@sl@G f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe sl@G)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@sl@REQ@@sl@G f1) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G)"
    , "                  (f1 (pfun Int sl@G)) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                           (= (apply@@Int@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G)"
    , "                  (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                           (= (apply@@sl@REQ@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x2 Int)"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x2 sl@REQ)"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                               x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (= (ran@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@Int@@sl@G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                        (= (apply@@Int@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@sl@REQ@@sl@G f1))"
    , "                      (exists ( (x sl@REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                        (= (apply@@sl@REQ@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (subset (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                           (union (ran@@Int@@sl@G f1) (ran@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                             (union (ran@@Int@@sl@G f1) (ran@@Int@@sl@G f2))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (subset (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                           (union (ran@@sl@REQ@@sl@G f1) (ran@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                             (union (ran@@sl@REQ@@sl@G f1) (ran@@sl@REQ@@sl@G f2))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (injective@@Int@@sl@G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                                  (=> (= (apply@@Int@@sl@G f1 x) (apply@@Int@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (injective@@sl@REQ@@sl@G f1)"
    , "                      (forall ( (x sl@REQ)"
    , "                                (x2 sl@REQ) )"
    , "                              (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                       (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                                  (=> (= (apply@@sl@REQ@@sl@G f1 x)"
    , "                                         (apply@@sl@REQ@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl@REQ@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (injective@@Int@@sl@G f1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1))"
    , "                          (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                          (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (injective@@sl@REQ@@sl@G f1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1))"
    , "                          (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                          (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (x2 Int) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (x2 sl@REQ) )"
    , "                (! (=> (and (not (= x x2))"
    , "                            (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G (mk-set@@Int x) f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G (mk-set@@Int x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (not (elem@@Int x s1))"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (and (not (elem@@sl@REQ x s1))"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (elem@@sl@REQ x (intersect (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (injective@@Int@@sl@G f1))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (injective@@sl@REQ@@sl@G f1))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (ran@@Int@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (ran@@sl@REQ@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@G)"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G x (mk-set@@sl@G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G x (mk-set@@sl@G y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@REQ) )"
    , "                (! (= (elem@@sl@REQ x (mk-set@@sl@REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (mk-set@@sl@REQ y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; SKIP:p"
    , "(assert (= p@prime p))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:qe"
    , "(assert (= qe@prime qe))"
    , "; SKIP:res"
    , "(assert (= res@prime res))"
    , "; SKIP:resL"
    , "(assert (= resL@prime resL))"
    , "; SKIP:resR"
    , "(assert (= resR@prime resR))"
    , "; m0:act4"
    , "(assert (= emp@prime true))"
    , "; m0:grd0"
    , "(assert (= p q))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:a4"
    , "(assert (= popL@prime"
    , "           (set-diff@@sl@REQ popL (mk-set@@sl@REQ r@param))))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resR) popR)"
    , "           empty-set@@sl@REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resL) popL)"
    , "           empty-set@@sl@REQ))"
    , "; m1:sch0"
    , "(assert (elem@@sl@REQ r@param popL))"
    , "; m1:sch1"
    , "(assert (= p q))"
    , "(assert (not (=> (and (elem@@sl@REQ r popL) (elem@@sl@REQ r popL))"
    , "                 (not (and (elem@@sl@REQ r popL@prime)"
    , "                           (elem@@sl@REQ r popL@prime))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

result8 :: String
result8 = unlines 
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl@REQ))"
    , "(declare-const popL@prime (set sl@REQ))"
    , "(declare-const popR (set sl@REQ))"
    , "(declare-const popR@prime (set sl@REQ))"
    , "(declare-const pshL (pfun sl@REQ sl@G))"
    , "(declare-const pshL@prime (pfun sl@REQ sl@G))"
    , "(declare-const pshR (pfun sl@REQ sl@G))"
    , "(declare-const pshR@prime (pfun sl@REQ sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@REQ)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-const resL (pfun sl@REQ sl@G))"
    , "(declare-const resL@prime (pfun sl@REQ sl@G))"
    , "(declare-const resR (pfun sl@REQ sl@G))"
    , "(declare-const resR@prime (pfun sl@REQ sl@G))"
    , "(declare-fun apply@@Int@@sl@G ( (pfun Int sl@G) Int ) sl@G)"
    , "(declare-fun apply@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               sl@REQ )"
    , "             sl@G)"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-rest@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun dom@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G) )"
    , "             (set sl@REQ))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun empty-fun@@sl@REQ@@sl@G () (pfun sl@REQ sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@REQ ( (set sl@REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun injective@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl@G (Int sl@G) (pfun Int sl@G))"
    , "(declare-fun mk-fun@@sl@REQ@@sl@G"
    , "             (sl@REQ sl@G)"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@G (sl@G) (set sl@G))"
    , "(declare-fun mk-set@@sl@REQ (sl@REQ) (set sl@REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ovl@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun r@param () sl@REQ)"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun ran@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@sl@REQ"
    , "            ( (s1 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ((_ map not) s1))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@G"
    , "            ( (x sl@G)"
    , "              (s1 (set sl@G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@REQ"
    , "            ( (x sl@REQ)"
    , "              (s1 (set sl@REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                      (union (dom@@sl@REQ@@sl@G f1) (dom@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2)) ))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl@G f2))))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))"
    , "                      (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select empty-fun@@Int@@sl@G x)"
    , "                      (as Nothing (Maybe sl@G)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Int@@sl@G x) ))))"
    , "(assert (forall ( (x sl@REQ) )"
    , "                (! (= (select empty-fun@@sl@REQ@@sl@G x)"
    , "                      (as Nothing (Maybe sl@G)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@sl@REQ@@sl@G x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl@G) )"
    , "                (! (= (select (mk-fun@@Int@@sl@G x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe sl@G))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Int@@sl@G x y) x2) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (x2 sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (select (mk-fun@@sl@REQ@@sl@G x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe sl@G))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@sl@REQ@@sl@G x y) x2) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (select (ovl@@Int@@sl@G f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe sl@G)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (select (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe sl@G)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int sl@G)) )"
    , "                (! (= (select (dom@@Int@@sl@G f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe sl@G)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Int@@sl@G f1) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (select (dom@@sl@REQ@@sl@G f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe sl@G)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@sl@REQ@@sl@G f1) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G)"
    , "                  (f1 (pfun Int sl@G)) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                           (= (apply@@Int@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G)"
    , "                  (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                           (= (apply@@sl@REQ@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x2 Int)"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x2 sl@REQ)"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                               x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (= (ran@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@Int@@sl@G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                        (= (apply@@Int@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@sl@REQ@@sl@G f1))"
    , "                      (exists ( (x sl@REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                        (= (apply@@sl@REQ@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (subset (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                           (union (ran@@Int@@sl@G f1) (ran@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                             (union (ran@@Int@@sl@G f1) (ran@@Int@@sl@G f2))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (subset (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                           (union (ran@@sl@REQ@@sl@G f1) (ran@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                             (union (ran@@sl@REQ@@sl@G f1) (ran@@sl@REQ@@sl@G f2))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (injective@@Int@@sl@G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                                  (=> (= (apply@@Int@@sl@G f1 x) (apply@@Int@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (injective@@sl@REQ@@sl@G f1)"
    , "                      (forall ( (x sl@REQ)"
    , "                                (x2 sl@REQ) )"
    , "                              (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                       (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                                  (=> (= (apply@@sl@REQ@@sl@G f1 x)"
    , "                                         (apply@@sl@REQ@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl@REQ@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (injective@@Int@@sl@G f1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1))"
    , "                          (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                          (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (injective@@sl@REQ@@sl@G f1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1))"
    , "                          (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                          (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (x2 Int) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (x2 sl@REQ) )"
    , "                (! (=> (and (not (= x x2))"
    , "                            (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G (mk-set@@Int x) f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G (mk-set@@Int x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (not (elem@@Int x s1))"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (and (not (elem@@sl@REQ x s1))"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (elem@@sl@REQ x (intersect (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (injective@@Int@@sl@G f1))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (injective@@sl@REQ@@sl@G f1))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (ran@@Int@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (ran@@sl@REQ@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@G)"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G x (mk-set@@sl@G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G x (mk-set@@sl@G y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@REQ) )"
    , "                (! (= (elem@@sl@REQ x (mk-set@@sl@REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (mk-set@@sl@REQ y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (= r@param r))"
    , "; SKIP:p"
    , "(assert (= p@prime p))"
    , "; SKIP:popR"
    , "(assert (= popR@prime popR))"
    , "; SKIP:pshL"
    , "(assert (= pshL@prime pshL))"
    , "; SKIP:pshR"
    , "(assert (= pshR@prime pshR))"
    , "; SKIP:q"
    , "(assert (= q@prime q))"
    , "; SKIP:qe"
    , "(assert (= qe@prime qe))"
    , "; SKIP:res"
    , "(assert (= res@prime res))"
    , "; SKIP:resL"
    , "(assert (= resL@prime resL))"
    , "; SKIP:resR"
    , "(assert (= resR@prime resR))"
    , "; m0:act4"
    , "(assert (= emp@prime true))"
    , "; m0:grd0"
    , "(assert (= p q))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:a4"
    , "(assert (= popL@prime"
    , "           (set-diff@@sl@REQ popL (mk-set@@sl@REQ r@param))))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resR) popR)"
    , "           empty-set@@sl@REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resL) popL)"
    , "           empty-set@@sl@REQ))"
    , "; m1:sch0"
    , "(assert (elem@@sl@REQ r@param popL))"
    , "; m1:sch1"
    , "(assert (= p q))"
    , "(assert (not (=> (and (elem@@sl@REQ r popL) (elem@@sl@REQ r popL))"
    , "                 (not (and (elem@@sl@REQ r popL@prime)"
    , "                           (elem@@sl@REQ r popL@prime))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

result9 :: String
result9 = unlines
    [ "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "(declare-sort sl@G 0)"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@REQ 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const emp Bool)"
    , "(declare-const emp@prime Bool)"
    , "(declare-const p Int)"
    , "(declare-const p@prime Int)"
    , "(declare-const popL (set sl@REQ))"
    , "(declare-const popL@prime (set sl@REQ))"
    , "(declare-const popR (set sl@REQ))"
    , "(declare-const popR@prime (set sl@REQ))"
    , "(declare-const pshL (pfun sl@REQ sl@G))"
    , "(declare-const pshL@prime (pfun sl@REQ sl@G))"
    , "(declare-const pshR (pfun sl@REQ sl@G))"
    , "(declare-const pshR@prime (pfun sl@REQ sl@G))"
    , "(declare-const q Int)"
    , "(declare-const q@prime Int)"
    , "(declare-const qe (pfun Int sl@G))"
    , "(declare-const qe@prime (pfun Int sl@G))"
    , "(declare-const r sl@REQ)"
    , "(declare-const r0 sl@REQ)"
    , "(declare-const r@m0-pop-left-empty sl@REQ)"
    , "(declare-const r@m0-pop-left-non-empty sl@REQ)"
    , "(declare-const res sl@G)"
    , "(declare-const res@prime sl@G)"
    , "(declare-const resL (pfun sl@REQ sl@G))"
    , "(declare-const resL@prime (pfun sl@REQ sl@G))"
    , "(declare-const resR (pfun sl@REQ sl@G))"
    , "(declare-const resR@prime (pfun sl@REQ sl@G))"
    , "(declare-fun apply@@Int@@sl@G ( (pfun Int sl@G) Int ) sl@G)"
    , "(declare-fun apply@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               sl@REQ )"
    , "             sl@G)"
    , "(declare-fun dom-rest@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-rest@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom-subt@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun dom-subt@@sl@REQ@@sl@G"
    , "             ( (set sl@REQ)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun dom@@Int@@sl@G ( (pfun Int sl@G) ) (set Int))"
    , "(declare-fun dom@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G) )"
    , "             (set sl@REQ))"
    , "(declare-fun empty-fun@@Int@@sl@G () (pfun Int sl@G))"
    , "(declare-fun empty-fun@@sl@REQ@@sl@G () (pfun sl@REQ sl@G))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@G ( (set sl@G) ) Bool)"
    , "(declare-fun finite@@sl@REQ ( (set sl@REQ) ) Bool)"
    , "(declare-fun finite@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (set (pfun Int sl@G)) )"
    , "             Bool)"
    , "(declare-fun injective@@Int@@sl@G ( (pfun Int sl@G) ) Bool)"
    , "(declare-fun injective@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) Bool)"
    , "(declare-fun interval (Int Int) (set Int))"
    , "(declare-fun intervalL (Int Int) (set Int))"
    , "(declare-fun intervalLR (Int Int) (set Int))"
    , "(declare-fun intervalR (Int Int) (set Int))"
    , "(declare-fun mk-fun@@Int@@sl@G (Int sl@G) (pfun Int sl@G))"
    , "(declare-fun mk-fun@@sl@REQ@@sl@G"
    , "             (sl@REQ sl@G)"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@G (sl@G) (set sl@G))"
    , "(declare-fun mk-set@@sl@REQ (sl@REQ) (set sl@REQ))"
    , "(declare-fun mk-set@Open@@pfun@@Int@@sl@G@Close"
    , "             ( (pfun Int sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(declare-fun ovl@@Int@@sl@G"
    , "             ( (pfun Int sl@G)"
    , "               (pfun Int sl@G) )"
    , "             (pfun Int sl@G))"
    , "(declare-fun ovl@@sl@REQ@@sl@G"
    , "             ( (pfun sl@REQ sl@G)"
    , "               (pfun sl@REQ sl@G) )"
    , "             (pfun sl@REQ sl@G))"
    , "(declare-fun ran@@Int@@sl@G ( (pfun Int sl@G) ) (set sl@G))"
    , "(declare-fun ran@@sl@REQ@@sl@G ( (pfun sl@REQ sl@G) ) (set sl@G))"
    , "(declare-fun tfun@@Int@@sl@G"
    , "             ( (set Int)"
    , "               (set sl@G) )"
    , "             (set (pfun Int sl@G)))"
    , "(define-fun sl@G () (set sl@G) ( (as const (set sl@G)) true ))"
    , "(define-fun sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@sl@G"
    , "            ( (s1 (set sl@G)) )"
    , "            (set sl@G)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@@sl@REQ"
    , "            ( (s1 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            ((_ map not) s1))"
    , "(define-fun compl@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            ((_ map not) s1))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@G"
    , "            ( (x sl@G)"
    , "              (s1 (set sl@G)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@REQ"
    , "            ( (x sl@REQ)"
    , "              (s1 (set sl@REQ)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (x (pfun Int sl@G))"
    , "              (s1 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@G"
    , "            ()"
    , "            (set sl@G)"
    , "            ( (as const (set sl@G))"
    , "              false ))"
    , "(define-fun empty-set@@sl@REQ"
    , "            ()"
    , "            (set sl@REQ)"
    , "            ( (as const (set sl@REQ))"
    , "              false ))"
    , "(define-fun empty-set@Open@@pfun@@Int@@sl@G@Close"
    , "            ()"
    , "            (set (pfun Int sl@G))"
    , "            ( (as const (set (pfun Int sl@G)))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            (set sl@G)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            (set sl@REQ)"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun set-diff@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            (set (pfun Int sl@G))"
    , "            (intersect s1 ((_ map not) s2)))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@G"
    , "            ( (s1 (set sl@G))"
    , "              (s2 (set sl@G)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@REQ"
    , "            ( (s1 (set sl@REQ))"
    , "              (s2 (set sl@REQ)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@Open@@pfun@@Int@@sl@G@Close"
    , "            ( (s1 (set (pfun Int sl@G)))"
    , "              (s2 (set (pfun Int sl@G))) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                      (union (dom@@Int@@sl@G f1) (dom@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (ovl@@Int@@sl@G f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                      (union (dom@@sl@REQ@@sl@G f1) (dom@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2)) ))))"
    , "(assert (= (dom@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@Int))"
    , "(assert (= (dom@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@REQ))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@REQ x))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (not (elem@@Int x (dom@@Int@@sl@G f2))))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f2))))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (= (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))"
    , "                      (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (mk-fun@@Int@@sl@G x y) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (s1 (set sl@REQ))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (= (select empty-fun@@Int@@sl@G x)"
    , "                      (as Nothing (Maybe sl@G)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@Int@@sl@G x) ))))"
    , "(assert (forall ( (x sl@REQ) )"
    , "                (! (= (select empty-fun@@sl@REQ@@sl@G x)"
    , "                      (as Nothing (Maybe sl@G)))"
    , "                   :pattern"
    , "                   ( (select empty-fun@@sl@REQ@@sl@G x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (x2 Int)"
    , "                  (y sl@G) )"
    , "                (! (= (select (mk-fun@@Int@@sl@G x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe sl@G))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@Int@@sl@G x y) x2) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (x2 sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (select (mk-fun@@sl@REQ@@sl@G x y) x2)"
    , "                      (ite (= x x2) (Just y) (as Nothing (Maybe sl@G))))"
    , "                   :pattern"
    , "                   ( (select (mk-fun@@sl@REQ@@sl@G x y) x2) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (= (select (ovl@@Int@@sl@G f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe sl@G)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@Int@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (= (select (ovl@@sl@REQ@@sl@G f1 f2) x)"
    , "                      (ite (= (select f2 x) (as Nothing (Maybe sl@G)))"
    , "                           (select f1 x)"
    , "                           (select f2 x)))"
    , "                   :pattern"
    , "                   ( (select (ovl@@sl@REQ@@sl@G f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (f1 (pfun Int sl@G)) )"
    , "                (! (= (select (dom@@Int@@sl@G f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe sl@G)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@Int@@sl@G f1) x) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (select (dom@@sl@REQ@@sl@G f1) x)"
    , "                      (not (= (select f1 x) (as Nothing (Maybe sl@G)))))"
    , "                   :pattern"
    , "                   ( (select (dom@@sl@REQ@@sl@G f1) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G)"
    , "                  (f1 (pfun Int sl@G)) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                           (= (apply@@Int@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G)"
    , "                  (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                           (= (apply@@sl@REQ@@sl@G f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ())))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x2 Int)"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x2 sl@REQ)"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                               x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                           x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))"
    , "                                          x) ))))"
    , "(assert (= (ran@@Int@@sl@G empty-fun@@Int@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (= (ran@@sl@REQ@@sl@G empty-fun@@sl@REQ@@sl@G)"
    , "           empty-set@@sl@G))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@Int@@sl@G f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                        (= (apply@@Int@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G y (ran@@sl@REQ@@sl@G f1))"
    , "                      (exists ( (x sl@REQ) )"
    , "                              (and true"
    , "                                   (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                        (= (apply@@sl@REQ@@sl@G f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G y (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (mk-fun@@Int@@sl@G x y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (= (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y))"
    , "                      (mk-set@@sl@G y))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (mk-fun@@sl@REQ@@sl@G x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (f2 (pfun Int sl@G)) )"
    , "                (! (subset (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                           (union (ran@@Int@@sl@G f1) (ran@@Int@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 f2))"
    , "                             (union (ran@@Int@@sl@G f1) (ran@@Int@@sl@G f2))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (f2 (pfun sl@REQ sl@G)) )"
    , "                (! (subset (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                           (union (ran@@sl@REQ@@sl@G f1) (ran@@sl@REQ@@sl@G f2)))"
    , "                   :pattern"
    , "                   ( (subset (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 f2))"
    , "                             (union (ran@@sl@REQ@@sl@G f1) (ran@@sl@REQ@@sl@G f2))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (s1 (set Int))"
    , "                  (s2 (set sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2))"
    , "                      (and (= s1 (dom@@Int@@sl@G f1))"
    , "                           (subset (ran@@Int@@sl@G f1) s2)))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close f1 (tfun@@Int@@sl@G s1 s2)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G)) )"
    , "                (! (= (injective@@Int@@sl@G f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                                  (=> (= (apply@@Int@@sl@G f1 x) (apply@@Int@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G)) )"
    , "                (! (= (injective@@sl@REQ@@sl@G f1)"
    , "                      (forall ( (x sl@REQ)"
    , "                                (x2 sl@REQ) )"
    , "                              (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                                       (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                                  (=> (= (apply@@sl@REQ@@sl@G f1 x)"
    , "                                         (apply@@sl@REQ@@sl@G f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@sl@REQ@@sl@G f1) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (and (injective@@Int@@sl@G f1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1))"
    , "                          (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                          (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (and (injective@@sl@REQ@@sl@G f1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1))"
    , "                          (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                          (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (x2 Int) )"
    , "                (! (=> (and (not (= x x2)) (elem@@Int x2 (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1) x2)"
    , "                          (apply@@Int@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G (mk-set@@Int x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (x2 sl@REQ) )"
    , "                (! (=> (and (not (= x x2))"
    , "                            (elem@@sl@REQ x2 (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x2)"
    , "                          (apply@@sl@REQ@@sl@G f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G (mk-set@@Int x) f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G (mk-set@@Int x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G (mk-set@@sl@REQ x) f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (not (elem@@Int x s1))"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (and (not (elem@@sl@REQ x s1))"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (and (elem@@Int x s1)"
    , "                            (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x)"
    , "                          (apply@@Int@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (and (elem@@sl@REQ x s1)"
    , "                            (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x)"
    , "                          (apply@@sl@REQ@@sl@G f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x) (ran@@Int@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ) )"
    , "                (! (=> (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x) (ran@@sl@REQ@@sl@G f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-subt@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (elem@@sl@REQ x (set-diff@@sl@REQ (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-subt@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (s1 (set Int)) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                   (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@Int@@sl@G f1 x)"
    , "                                 (ran@@Int@@sl@G (dom-rest@@Int@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (s1 (set sl@REQ)) )"
    , "                (! (=> (elem@@sl@REQ x (intersect (dom@@sl@REQ@@sl@G f1) s1))"
    , "                       (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                   (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G (apply@@sl@REQ@@sl@G f1 x)"
    , "                                 (ran@@sl@REQ@@sl@G (dom-rest@@sl@REQ@@sl@G s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@sl@G f1))"
    , "                            (injective@@Int@@sl@G f1))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@Int@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@Int@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (and (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1))"
    , "                            (injective@@sl@REQ@@sl@G f1))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (set-diff@@sl@G (ran@@sl@REQ@@sl@G f1)"
    , "                                                 (mk-set@@sl@G (apply@@sl@REQ@@sl@G f1 x)))"
    , "                                 (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int sl@G))"
    , "                  (x Int)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@sl@G f1)))"
    , "                       (= (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y)))"
    , "                          (union (ran@@Int@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@sl@G (ovl@@Int@@sl@G f1 (mk-fun@@Int@@sl@G x y))) ))))"
    , "(assert (forall ( (f1 (pfun sl@REQ sl@G))"
    , "                  (x sl@REQ)"
    , "                  (y sl@G) )"
    , "                (! (=> (not (elem@@sl@REQ x (dom@@sl@REQ@@sl@G f1)))"
    , "                       (= (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y)))"
    , "                          (union (ran@@sl@REQ@@sl@G f1) (mk-set@@sl@G y))))"
    , "                   :pattern"
    , "                   ( (ran@@sl@REQ@@sl@G (ovl@@sl@REQ@@sl@G f1 (mk-fun@@sl@REQ@@sl@G x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x (pfun Int sl@G))"
    , "                  (y (pfun Int sl@G)) )"
    , "                (! (= (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y))"
    , "                      (= x y))"
    , "                   :pattern"
    , "                   ( (elem@Open@@pfun@@Int@@sl@G@Close x (mk-set@Open@@pfun@@Int@@sl@G@Close y)) ))))"
    , "(assert (forall ( (x sl@G)"
    , "                  (y sl@G) )"
    , "                (! (= (elem@@sl@G x (mk-set@@sl@G y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@G x (mk-set@@sl@G y)) ))))"
    , "(assert (forall ( (x sl@REQ)"
    , "                  (y sl@REQ) )"
    , "                (! (= (elem@@sl@REQ x (mk-set@@sl@REQ y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@REQ x (mk-set@@sl@REQ y)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (interval m n))"
    , "                      (and (<= m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (interval m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalR m n))"
    , "                      (and (<= m x) (< x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalR m n) (mk-set@@Int n))"
    , "                          (intervalR m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (mk-set@@Int n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (intervalL m n) (mk-set@@Int (+ n 1)))"
    , "                          (intervalL m (+ n 1))))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (mk-set@@Int (+ n 1))) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int (- m 1)) (intervalR m n))"
    , "                          (intervalR (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int (- m 1)) (intervalR m n)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int) )"
    , "                (! (=> (<= m n)"
    , "                       (= (union (mk-set@@Int m) (intervalL m n))"
    , "                          (intervalL (- m 1) n)))"
    , "                   :pattern"
    , "                   ( (union (mk-set@@Int m) (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (m Int)"
    , "                  (n Int) )"
    , "                (! (= (elem@@Int x (intervalL m n))"
    , "                      (and (< m x) (<= x n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (intervalL m n)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalR m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL m m) empty-set@@Int)"
    , "                   :pattern"
    , "                   ( (intervalL m m) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalR m (+ m 1)) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalR m (+ m 1)) ))))"
    , "(assert (forall ( (m Int) )"
    , "                (! (= (intervalL (- m 1) m) (mk-set@@Int m))"
    , "                   :pattern"
    , "                   ( (intervalL (- m 1) m) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalR m n) (intervalR n p))"
    , "                          (intervalR m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalR m n) (intervalR n p)) ))))"
    , "(assert (forall ( (m Int)"
    , "                  (n Int)"
    , "                  (p Int) )"
    , "                (! (=> (and (<= m n) (<= n p))"
    , "                       (= (union (intervalL m n) (intervalL n p))"
    , "                          (intervalL m p)))"
    , "                   :pattern"
    , "                   ( (union (intervalL m n) (intervalL n p)) ))))"
    , "(assert (not (forall ( (r sl@REQ)"
    , "                       (r@m0-pop-left-empty sl@REQ)"
    , "                       (r@m0-pop-left-non-empty sl@REQ) )"
    , "                     (=> (and (elem@@sl@REQ r popL)"
    , "                              (elem@@sl@REQ r popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "(assert (not (forall ( (r@m0-pop-left-empty sl@REQ)"
    , "                       (r@m0-pop-left-non-empty sl@REQ) )"
    , "                     (=> (and (elem@@sl@REQ r0 popL)"
    , "                              (elem@@sl@REQ r0 popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "(assert (not (forall ( (r@m0-pop-left-non-empty sl@REQ) )"
    , "                     (=> (and (elem@@sl@REQ r0 popL)"
    , "                              (elem@@sl@REQ r0 popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-empty popL)"
    , "                              (elem@@sl@REQ r@m0-pop-left-non-empty popL))"
    , "                         (or (= p q) (< p q))))))"
    , "; m0:inv0"
    , "(assert (elem@Open@@pfun@@Int@@sl@G@Close qe (tfun@@Int@@sl@G (intervalR p q) sl@G)))"
    , "; m0:inv1"
    , "(assert (<= p q))"
    , "; m1:inv0"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resR) popR)"
    , "           empty-set@@sl@REQ))"
    , "; m1:inv1"
    , "(assert (= (intersect (dom@@sl@REQ@@sl@G resL) popL)"
    , "           empty-set@@sl@REQ))"
    , "(assert (not (=> (and (elem@@sl@REQ r0 popL)"
    , "                      (elem@@sl@REQ r0 popL)"
    , "                      (elem@@sl@REQ r@m0-pop-left-empty popL)"
    , "                      (elem@@sl@REQ r@m0-pop-left-non-empty popL))"
    , "                 (or (= p q) (< p q)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

path10 :: FilePath 
path10 = "tests/lock-free deque/main6-err0.tex"

result10 :: String
result10 = unlines
    [ "error: Multiple refinement of progress property m1:prog3"
    , "\tm1:prog3: (223,4)"
    , "\tm1:prog3: (254,1)"
    , ""
    ]

path11 :: FilePath 
path11 = "tests/lock-free deque/main6-err1.tex"

result11 :: String
result11 = unlines
    [ "error (223,4): A witness is needed for r in event 'm0:pop:left:empty'"
    , "error (223,4): A witness is needed for r in event 'm0:pop:left:non:empty'"
    ]
