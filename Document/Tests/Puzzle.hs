module Document.Tests.Puzzle 
    ( test_case, path0 )
where

    -- Modules
import Document.Tests.Suite

import Documentation.SummaryGen

import Logic.Expr
import Logic.Proof

import UnitB.AST

    -- Library
import Control.Monad
import Control.Monad.Trans.Either

import Data.Map

import Tests.UnitTest

test_case :: TestCase
test_case = test_cases 
        "The king and his advisors puzzle"
        [ POCase "puzzle, m0" case0 result0
        , POCase "puzzle, m1" case1 result1
        , Case "puzzle, proof obligation" case2 result2
        , Case "puzzle, event visit" case3 result3
        , Case "puzzle, visit enablement, PO" case4 result4
        , Case "puzzle, visit negation, PO" case5 result5
        , Case "puzzle, remove default with weakento" case6 result6
        , POCase "puzzle, m2" case7 result7
        , POCase "puzzle, m3" case8 result8
        , Case "puzzle m3, wd of sums" case9 result9
        , Case "puzzle m3, proofs with sums" case10 result10
        ]

path0 :: FilePath
path0 = "Tests/puzzle/puzzle.tex"

case0 :: IO (String, Map Label Sequent)
case0 = verify path0 0

result0 :: String
result0 = unlines
    [ "  o  m0/INIT/FIS/b"
    , "  o  m0/INIT/WD"
    , "  o  m0/INV/WD"
    , "  o  m0/prog0/PROG/WD/lhs"
    , "  o  m0/prog0/PROG/WD/rhs"
    , "  o  m0/prog0/REF/ensure/m0/SAF/WD/lhs"
    , "  o  m0/prog0/REF/ensure/m0/SAF/WD/rhs"
    , "  o  m0/prog0/REF/ensure/m0/TR/WD"
    , "  o  m0/prog0/REF/ensure/m0/TR/term/EN"
    , "  o  m0/prog0/REF/ensure/m0/TR/term/NEG"
    , "  o  m0/prog0/REF/ensure/m0/term/SAF"
    , "  o  m0/term/FIS/b@prime"
    , "  o  m0/term/SCH"
    , "  o  m0/term/SCH/m0/0/REF/weaken"
    , "  o  m0/term/WD/ACT/act0"
    , "  o  m0/term/WD/C_SCH"
    , "  o  m0/term/WD/F_SCH"
    , "  o  m0/term/WD/GRD"
    , "passed 18 / 18"
    ]

case1 :: IO (String, Map Label Sequent)
case1 = verify path0 1

result1 :: String
result1 = unlines
    [ "  o  m1/INIT/FIS/b"
    , "  o  m1/INIT/INV/inv0"
    , "  o  m1/INIT/WD"
    , "  o  m1/INV/WD"
    , "  o  m1/prog1/PROG/WD/lhs"
    , "  o  m1/prog1/PROG/WD/rhs"
    , "  o  m1/prog1/REF/induction/lhs"
    , "  o  m1/prog1/REF/induction/rhs"
    , "  o  m1/prog2/PROG/WD/lhs"
    , "  o  m1/prog2/PROG/WD/rhs"
    , "  o  m1/prog2/REF/PSP/lhs"
    , "  o  m1/prog2/REF/PSP/rhs"
    , "  o  m1/prog3/PROG/WD/lhs"
    , "  o  m1/prog3/PROG/WD/rhs"
    , "  o  m1/prog3/REF/ensure/m1/SAF/WD/lhs"
    , "  o  m1/prog3/REF/ensure/m1/SAF/WD/rhs"
    , "  o  m1/prog3/REF/ensure/m1/TR/WD"
    , "  o  m1/prog3/REF/ensure/m1/TR/WD/witness/p"
    , "  o  m1/prog3/REF/ensure/m1/TR/WFIS/p/p@prime"
    , "  o  m1/prog3/REF/ensure/m1/TR/visit/EN"
    , "  o  m1/prog3/REF/ensure/m1/TR/visit/NEG"
    , "  o  m1/prog3/REF/ensure/m1/term/SAF"
    , "  o  m1/prog3/REF/ensure/m1/visit/SAF"
    , "  o  m1/saf1/SAF/WD/lhs"
    , "  o  m1/saf1/SAF/WD/rhs"
    , "  o  m1/saf2/SAF/WD/lhs"
    , "  o  m1/saf2/SAF/WD/rhs"
    , "  o  m1/term/FIS/b@prime"
    , "  o  m1/term/FIS/vs@prime"
    , "  o  m1/term/INV/inv0"
    , "  o  m1/term/SAF/saf1"
    , "  o  m1/term/SAF/saf2"
    , "  o  m1/term/SCH"
    , "  o  m1/term/SCH/m1/0/REF/delay/prog/lhs"
    , "  o  m1/term/SCH/m1/0/REF/delay/prog/rhs"
    , "  o  m1/term/SCH/m1/0/REF/delay/saf/lhs"
    , "  o  m1/term/SCH/m1/0/REF/delay/saf/rhs"
    , "  o  m1/term/WD/C_SCH"
    , "  o  m1/term/WD/F_SCH"
    , "  o  m1/term/WD/GRD"
    , "  o  m1/visit/FIS/b@prime"
    , "  o  m1/visit/FIS/vs@prime"
    , "  o  m1/visit/INV/inv0"
    , "  o  m1/visit/SAF/saf1"
    , "  o  m1/visit/SAF/saf2"
    , "  o  m1/visit/SCH"
    , "  o  m1/visit/SCH/m1/0/REF/weaken"
    , "  o  m1/visit/WD/ACT/act1"
    , "  o  m1/visit/WD/C_SCH"
    , "  o  m1/visit/WD/F_SCH"
    , "  o  m1/visit/WD/GRD"
    , "passed 51 / 51"
    ]

case2 :: IO String
case2 = proof_obligation path0 "m1/prog1/REF/induction/rhs" 1

result2 :: String
result2 = unlines
    [ "; m1/prog1/REF/induction/rhs"
    , "(set-option :auto-config false)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const V (set sl@Pcs))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-const vs@prime (set sl@Pcs))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (not (forall ( (V (set sl@Pcs)) )"
    , "                     (=> true"
    , "                         (=> (or (st-subset@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                                 (= vs sl@Pcs))"
    , "                             (or (and (subset (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                                      (subset empty-set@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs))"
    , "                                      (finite@@sl@Pcs (set-diff@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) empty-set@@sl@Pcs)))"
    , "                                 (= vs sl@Pcs)))))))"
    , "(assert (not (=> (or (st-subset@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                     (= vs sl@Pcs))"
    , "                 (or (and (subset (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                          (subset empty-set@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs))"
    , "                          (finite@@sl@Pcs (set-diff@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) empty-set@@sl@Pcs)))"
    , "                     (= vs sl@Pcs)))))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl@Pcs)))"
    , "(assert (not (=> (st-subset@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                 (and (subset (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                      (subset empty-set@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs))"
    , "                      (finite@@sl@Pcs (set-diff@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) empty-set@@sl@Pcs))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/prog1/REF/induction/rhs"
    ]

case3 :: IO String
case3 = liftM (either id id) $ runEitherT $ do
    s <- get_system path0
    let ms  = machines s
        m   = ms ! "m1"
        visit = label "visit"
        evt  = events m ! visit
    return $ getListing s $ event_summary' m visit evt

result3 :: String
result3 = unlines
    [ "\\noindent \\ref{visit} [p] \\textbf{event}"
    , "\\begin{block}"
    , "  \\item   \\textbf{begin}"
    , "  \\begin{block}"
    , "  \\item[ \\eqref{visitact1} ]$vs \\bcmeq vs \\bunion \\{ p \\} $ %"
    , "  \\end{block}"
    , "  \\item   \\textbf{end} \\\\"
    , "\\end{block}"
    ]

case4 :: IO String
case4 = proof_obligation path0 "m1/prog3/REF/ensure/m1/TR/visit/EN" 1

result4 :: String
result4 = unlines
    [ "; m1/prog3/REF/ensure/m1/TR/visit/EN"
    , "(set-option :auto-config false)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const V (set sl@Pcs))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-const vs@prime (set sl@Pcs))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(declare-fun mk-set@@sl@Pcs (sl@Pcs) (set sl@Pcs))"
    , "(declare-fun p@param () sl@Pcs)"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl@Pcs"
    , "            ( (x sl@Pcs)"
    , "              (s1 (set sl@Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (finite@@sl@Pcs (mk-set@@sl@Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (mk-set@@sl@Pcs x)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (not (elem@@sl@Pcs p@param vs)))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl@Pcs)))"
    , "(assert (not true))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/prog3/REF/ensure/m1/TR/visit/EN"
    ]

case5 :: IO String
case5 = proof_obligation path0 "m1/prog3/REF/ensure/m1/TR/visit/NEG" 1

result5 :: String
result5 = unlines
    [ "; m1/prog3/REF/ensure/m1/TR/visit/NEG"
    , "(set-option :auto-config false)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const V (set sl@Pcs))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-const vs@prime (set sl@Pcs))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(declare-fun mk-set@@sl@Pcs (sl@Pcs) (set sl@Pcs))"
    , "(declare-fun p@param () sl@Pcs)"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl@Pcs"
    , "            ( (x sl@Pcs)"
    , "              (s1 (set sl@Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (finite@@sl@Pcs (mk-set@@sl@Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (mk-set@@sl@Pcs x)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (not (elem@@sl@Pcs p@param vs)))"
    , "; SKIP:b"
    , "(assert (= b@prime b))"
    , "; act1"
    , "(assert (= vs@prime (union vs (mk-set@@sl@Pcs p@param))))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl@Pcs)))"
    , "(assert (not (=> (and (= (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                      (not (= vs sl@Pcs))"
    , "                      (= (set-diff@@sl@Pcs sl@Pcs vs) V))"
    , "                 (not (and (= (set-diff@@sl@Pcs sl@Pcs vs@prime) V)"
    , "                           (not (= vs@prime sl@Pcs))"
    , "                           (= (set-diff@@sl@Pcs sl@Pcs vs@prime) V))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/prog3/REF/ensure/m1/TR/visit/NEG"
    ]

case6 :: IO String
case6 = proof_obligation path0 "m1/visit/SCH/m1/0/REF/weaken" 1

result6 :: String
result6 = unlines
    [ "; m1/visit/SCH/m1/0/REF/weaken"
    , "(set-option :auto-config false)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-const vs@prime (set sl@Pcs))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl@Pcs)))"
    , "(assert (not true))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/visit/SCH/m1/0/REF/weaken"
    ]

case7 :: IO (String, Map Label Sequent)
case7 = verify path0 2

result7 :: String
result7 = unlines
    [ "  o  m2/INIT/FIS/b"
    , "  o  m2/INIT/FIS/cs"
    , "  o  m2/INIT/FIS/ts"
    , "  o  m2/INIT/INV/inv1"
    , "  o  m2/INIT/INV/inv2"
    , "  o  m2/INIT/WD"
    , "  o  m2/INV/WD"
    , "  o  m2/count/FIS/b@prime"
    , "  o  m2/count/FIS/cs@prime"
    , "  o  m2/count/FIS/ts@prime"
    , "  o  m2/count/FIS/vs@prime"
    , "  o  m2/count/INV/inv1"
    , "  o  m2/count/INV/inv2"
    , "  o  m2/count/SAF/saf3"
    , "  o  m2/count/SAF/saf8"
    , "  o  m2/count/SCH"
    , "  o  m2/count/SCH/m2/0/REF/weaken"
    , "  o  m2/count/WD/ACT/act0"
    , "  o  m2/count/WD/ACT/act1"
    , "  o  m2/count/WD/C_SCH"
    , "  o  m2/count/WD/F_SCH"
    , "  o  m2/count/WD/GRD"
    , "  o  m2/flick/FIS/b@prime"
    , "  o  m2/flick/FIS/cs@prime"
    , "  o  m2/flick/FIS/ts@prime"
    , "  o  m2/flick/FIS/vs@prime"
    , "  o  m2/flick/INV/inv1"
    , "  o  m2/flick/INV/inv2"
    , "  o  m2/flick/SAF/saf3"
    , "  o  m2/flick/SAF/saf8"
    , "  o  m2/flick/SCH"
    , "  o  m2/flick/SCH/m2/0/REF/weaken"
    , "  o  m2/flick/WD/ACT/act0"
    , "  o  m2/flick/WD/C_SCH"
    , "  o  m2/flick/WD/F_SCH"
    , "  o  m2/flick/WD/GRD"
    , "  o  m2/prog10/PROG/WD/lhs"
    , "  o  m2/prog10/PROG/WD/rhs"
    , "  o  m2/prog10/REF/ensure/m2/SAF/WD/lhs"
    , "  o  m2/prog10/REF/ensure/m2/SAF/WD/rhs"
    , "  o  m2/prog10/REF/ensure/m2/TR/WD"
    , "  o  m2/prog10/REF/ensure/m2/TR/count/EN"
    , "  o  m2/prog10/REF/ensure/m2/TR/count/NEG"
    , "  o  m2/prog10/REF/ensure/m2/count/SAF"
    , "  o  m2/prog10/REF/ensure/m2/flick/SAF"
    , "  o  m2/prog10/REF/ensure/m2/term/SAF"
    , "  o  m2/prog10/REF/ensure/m2/visit/SAF"
    , "  o  m2/prog11/PROG/WD/lhs"
    , "  o  m2/prog11/PROG/WD/rhs"
    , "  o  m2/prog11/REF/ensure/m2/SAF/WD/lhs"
    , "  o  m2/prog11/REF/ensure/m2/SAF/WD/rhs"
    , "  o  m2/prog11/REF/ensure/m2/TR/WD"
    , "  o  m2/prog11/REF/ensure/m2/TR/WD/witness/p"
    , "  o  m2/prog11/REF/ensure/m2/TR/WFIS/p/p@prime"
    , "  o  m2/prog11/REF/ensure/m2/TR/visit/EN"
    , "  o  m2/prog11/REF/ensure/m2/TR/visit/NEG"
    , "  o  m2/prog11/REF/ensure/m2/count/SAF"
    , "  o  m2/prog11/REF/ensure/m2/flick/SAF"
    , "  o  m2/prog11/REF/ensure/m2/term/SAF"
    , "  o  m2/prog11/REF/ensure/m2/visit/SAF"
    , "  o  m2/prog4/PROG/WD/lhs"
    , "  o  m2/prog4/PROG/WD/rhs"
    , "  o  m2/prog4/REF/transitivity/lhs"
    , "  o  m2/prog4/REF/transitivity/mhs/prog10/prog9"
    , "  o  m2/prog4/REF/transitivity/rhs"
    , "  o  m2/prog5/PROG/WD/lhs"
    , "  o  m2/prog5/PROG/WD/rhs"
    , "  o  m2/prog5/REF/PSP/lhs"
    , "  o  m2/prog5/REF/PSP/rhs"
    , "  o  m2/prog6/PROG/WD/lhs"
    , "  o  m2/prog6/PROG/WD/rhs"
    , "  o  m2/prog6/REF/ensure/m2/SAF/WD/lhs"
    , "  o  m2/prog6/REF/ensure/m2/SAF/WD/rhs"
    , "  o  m2/prog6/REF/ensure/m2/TR/WD"
    , "  o  m2/prog6/REF/ensure/m2/TR/WD/witness/p"
    , "  o  m2/prog6/REF/ensure/m2/TR/WFIS/p/p@prime"
    , "  o  m2/prog6/REF/ensure/m2/TR/flick/EN"
    , "  o  m2/prog6/REF/ensure/m2/TR/flick/NEG"
    , "  o  m2/prog6/REF/ensure/m2/count/SAF"
    , "  o  m2/prog6/REF/ensure/m2/flick/SAF"
    , "  o  m2/prog6/REF/ensure/m2/term/SAF"
    , "  o  m2/prog6/REF/ensure/m2/visit/SAF"
    , "  o  m2/prog7/PROG/WD/lhs"
    , "  o  m2/prog7/PROG/WD/rhs"
    , "  o  m2/prog7/REF/ensure/m2/SAF/WD/lhs"
    , "  o  m2/prog7/REF/ensure/m2/SAF/WD/rhs"
    , "  o  m2/prog7/REF/ensure/m2/TR/WD"
    , "  o  m2/prog7/REF/ensure/m2/TR/count/EN"
    , "  o  m2/prog7/REF/ensure/m2/TR/count/NEG"
    , "  o  m2/prog7/REF/ensure/m2/count/SAF"
    , "  o  m2/prog7/REF/ensure/m2/flick/SAF"
    , "  o  m2/prog7/REF/ensure/m2/term/SAF"
    , "  o  m2/prog7/REF/ensure/m2/visit/SAF"
    , "  o  m2/prog8/PROG/WD/lhs"
    , "  o  m2/prog8/PROG/WD/rhs"
    , "  o  m2/prog8/REF/transitivity/lhs"
    , "  o  m2/prog8/REF/transitivity/mhs/prog11/prog6"
    , "  o  m2/prog8/REF/transitivity/mhs/prog6/prog7"
    , "  o  m2/prog8/REF/transitivity/rhs"
    , "  o  m2/prog9/PROG/WD/lhs"
    , "  o  m2/prog9/PROG/WD/rhs"
    , "  o  m2/prog9/REF/induction/lhs"
    , "  o  m2/prog9/REF/induction/rhs"
    , "  o  m2/saf3/SAF/WD/lhs"
    , "  o  m2/saf3/SAF/WD/rhs"
    , "  o  m2/saf8/SAF/WD/lhs"
    , "  o  m2/saf8/SAF/WD/rhs"
    , "  o  m2/term/FIS/b@prime"
    , "  o  m2/term/FIS/cs@prime"
    , "  o  m2/term/FIS/ts@prime"
    , "  o  m2/term/FIS/vs@prime"
    , "  o  m2/term/INV/inv1"
    , "  o  m2/term/INV/inv2"
    , "  o  m2/term/SAF/saf3"
    , "  o  m2/term/SAF/saf8"
    , "  o  m2/term/SCH"
    , "  o  m2/term/SCH/m2/0/REF/delay/prog/lhs"
    , "  o  m2/term/SCH/m2/0/REF/delay/prog/rhs"
    , "  o  m2/term/SCH/m2/0/REF/delay/saf/lhs"
    , "  o  m2/term/SCH/m2/0/REF/delay/saf/rhs"
    , "  o  m2/term/WD/C_SCH"
    , "  o  m2/term/WD/F_SCH"
    , "  o  m2/term/WD/GRD"
    , "  o  m2/visit/FIS/b@prime"
    , "  o  m2/visit/FIS/cs@prime"
    , "  o  m2/visit/FIS/ts@prime"
    , "  o  m2/visit/FIS/vs@prime"
    , "  o  m2/visit/INV/inv1"
    , "  o  m2/visit/INV/inv2"
    , "  o  m2/visit/SAF/saf3"
    , "  o  m2/visit/SAF/saf8"
    , "  o  m2/visit/SCH"
    , "  o  m2/visit/WD/C_SCH"
    , "  o  m2/visit/WD/F_SCH"
    , "  o  m2/visit/WD/GRD"
    , "passed 135 / 135"
    ]

case8 :: IO (String, Map Label Sequent)
case8 = verify path0 3

result8 :: String
result8 = unlines 
    [ "  o  m3/INIT/FIS/b"
    , "  o  m3/INIT/FIS/c"
    , "  o  m3/INIT/FIS/cs"
    , "  o  m3/INIT/FIS/n"
    , "  o  m3/INIT/FIS/ts"
    , "  o  m3/INIT/INV/m3:inv0"
    , "  o  m3/INIT/INV/m3:inv1"
    , "  o  m3/INIT/INV/m3:inv2"
    , "  o  m3/INIT/INV/m3:inv3"
    , "  o  m3/INIT/INV/m3:inv5"
    , "  o  m3/INIT/INV/m3:inv6"
    , "  o  m3/INIT/WD"
    , "  o  m3/INV/WD"
    , "  o  m3/count/FIS/b@prime"
    , "  o  m3/count/FIS/c@prime"
    , "  o  m3/count/FIS/cs@prime"
    , "  o  m3/count/FIS/n@prime"
    , "  o  m3/count/FIS/ts@prime"
    , "  o  m3/count/FIS/vs@prime"
    , "  o  m3/count/INV/m3:inv0"
    , "  o  m3/count/INV/m3:inv1"
    , "  o  m3/count/INV/m3:inv2"
    , "  o  m3/count/INV/m3:inv3"
    , "  o  m3/count/INV/m3:inv5"
    , "  o  m3/count/INV/m3:inv6"
    , "  o  m3/count/SCH"
    , "  o  m3/count/WD/ACT/m3:act0"
    , "  o  m3/count/WD/ACT/m3:act1"
    , "  o  m3/count/WD/C_SCH"
    , "  o  m3/count/WD/F_SCH"
    , "  o  m3/count/WD/GRD"
    , "  o  m3/flick/FIS/b@prime"
    , "  o  m3/flick/FIS/c@prime"
    , "  o  m3/flick/FIS/cs@prime"
    , "  o  m3/flick/FIS/n@prime"
    , "  o  m3/flick/FIS/ts@prime"
    , "  o  m3/flick/FIS/vs@prime"
    , "  o  m3/flick/INV/m3:inv0"
    , "  o  m3/flick/INV/m3:inv1"
    , "  o  m3/flick/INV/m3:inv2"
    , "  o  m3/flick/INV/m3:inv3"
    , "  o  m3/flick/INV/m3:inv5"
    , "  o  m3/flick/INV/m3:inv6"
    , "  o  m3/flick/SCH"
    , "  o  m3/flick/WD/ACT/m3:act0"
    , "  o  m3/flick/WD/C_SCH"
    , "  o  m3/flick/WD/F_SCH"
    , "  o  m3/flick/WD/GRD"
    , "  o  m3/term/FIS/b@prime"
    , "  o  m3/term/FIS/c@prime"
    , "  o  m3/term/FIS/cs@prime"
    , "  o  m3/term/FIS/n@prime"
    , "  o  m3/term/FIS/ts@prime"
    , "  o  m3/term/FIS/vs@prime"
    , "  o  m3/term/INV/m3:inv0"
    , "  o  m3/term/INV/m3:inv1"
    , "  o  m3/term/INV/m3:inv2"
    , "  o  m3/term/INV/m3:inv3"
    , "  o  m3/term/INV/m3:inv5"
    , "  o  m3/term/INV/m3:inv6"
    , "  o  m3/term/SCH"
    , "  o  m3/term/WD/C_SCH"
    , "  o  m3/term/WD/F_SCH"
    , "  o  m3/term/WD/GRD"
    , "  o  m3/visit/FIS/b@prime"
    , "  o  m3/visit/FIS/c@prime"
    , "  o  m3/visit/FIS/cs@prime"
    , "  o  m3/visit/FIS/n@prime"
    , "  o  m3/visit/FIS/ts@prime"
    , "  o  m3/visit/FIS/vs@prime"
    , "  o  m3/visit/INV/m3:inv0"
    , "  o  m3/visit/INV/m3:inv1"
    , "  o  m3/visit/INV/m3:inv2"
    , "  o  m3/visit/INV/m3:inv3"
    , "  o  m3/visit/INV/m3:inv5"
    , "  o  m3/visit/INV/m3:inv6"
    , "  o  m3/visit/SCH"
    , "  o  m3/visit/WD/C_SCH"
    , "  o  m3/visit/WD/F_SCH"
    , "  o  m3/visit/WD/GRD"
    , "passed 80 / 80"
    ]

case9 :: IO String
case9 = proof_obligation path0 "m3/INV/WD" 3

result9 :: String
result9 = unlines
    [ "; m3/INV/WD"
    , "(set-option :auto-config false)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const c Int)"
    , "(declare-const cs (set sl@Pcs))"
    , "(declare-const n Int)"
    , "(declare-const ts (set sl@Pcs))"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-fun @@lambda@@_0 ( (set sl@Pcs) ) (set sl@Pcs))"
    , "(declare-fun const@@sl@Pcs@@Int (Int) (Array sl@Pcs Int))"
    , "(declare-fun const@@sl@Pcs@@sl@Pcs"
    , "             (sl@Pcs)"
    , "             (Array sl@Pcs sl@Pcs))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(declare-fun ident@@sl@Pcs () (Array sl@Pcs sl@Pcs))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@Pcs (sl@Pcs) (set sl@Pcs))"
    , "(declare-fun qsum@@sl@Pcs"
    , "             ( (set sl@Pcs)"
    , "               (Array sl@Pcs Int) )"
    , "             Int)"
    , "(declare-fun set@@sl@Pcs@@Int"
    , "             ( (set sl@Pcs)"
    , "               (Array sl@Pcs Int) )"
    , "             (set Int))"
    , "(declare-fun set@@sl@Pcs@@sl@Pcs"
    , "             ( (set sl@Pcs)"
    , "               (Array sl@Pcs sl@Pcs) )"
    , "             (set sl@Pcs))"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@Pcs"
    , "            ( (x sl@Pcs)"
    , "              (s1 (set sl@Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (term (Array sl@Pcs Int)) )"
    , "                (! (= (qsum@@sl@Pcs empty-set@@sl@Pcs term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs empty-set@@sl@Pcs term) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (x sl@Pcs) )"
    , "                (! (=> (not (elem@@sl@Pcs x r))"
    , "                       (= (qsum@@sl@Pcs (union r (mk-set@@sl@Pcs x)) term)"
    , "                          (+ (qsum@@sl@Pcs r term) (select term x))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r (mk-set@@sl@Pcs x)) term) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (r0 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl@Pcs)"
    , "                       (= (qsum@@sl@Pcs (union r r0) term)"
    , "                          (+ (qsum@@sl@Pcs r term) (qsum@@sl@Pcs r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r r0) term) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs r)"
    , "                       (<= 0 (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))))"
    , "                   :pattern"
    , "                   ( (<= 0 (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (= (= (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) 0)"
    , "                      (= r empty-set@@sl@Pcs))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (= (qsum@@sl@Pcs (mk-set@@sl@Pcs x) (const@@sl@Pcs@@Int 1))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (mk-set@@sl@Pcs x) (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (= (= (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) 1)"
    , "                      (exists ( (x sl@Pcs) ) (and true (= r (mk-set@@sl@Pcs x)))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (r0 (set sl@Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl@Pcs)"
    , "                       (= (qsum@@sl@Pcs (union r r0) (const@@sl@Pcs@@Int 1))"
    , "                          (+ (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))"
    , "                             (qsum@@sl@Pcs r0 (const@@sl@Pcs@@Int 1)))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r r0) (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (select (const@@sl@Pcs@@Int x) y) x)"
    , "                   :pattern"
    , "                   ( (select (const@@sl@Pcs@@Int x) y) ))))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (select (const@@sl@Pcs@@sl@Pcs x) y) x)"
    , "                   :pattern"
    , "                   ( (select (const@@sl@Pcs@@sl@Pcs x) y) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (= (select ident@@sl@Pcs x) x)"
    , "                   :pattern"
    , "                   ( (select ident@@sl@Pcs x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int y (set@@sl@Pcs@@Int r1 term))"
    , "                      (exists ( (x sl@Pcs) )"
    , "                              (and (elem@@sl@Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Int y (set@@sl@Pcs@@Int r1 term)) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs sl@Pcs))"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs y (set@@sl@Pcs@@sl@Pcs r1 term))"
    , "                      (exists ( (x sl@Pcs) )"
    , "                              (and (elem@@sl@Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs y (set@@sl@Pcs@@sl@Pcs r1 term)) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (y Int) )"
    , "                (! (= (= (set@@sl@Pcs@@Int r1 term) (mk-set@@Int y))"
    , "                      (forall ( (x sl@Pcs) )"
    , "                              (=> (elem@@sl@Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@@sl@Pcs@@Int r1 term)"
    , "                     (mk-set@@Int y) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs sl@Pcs))"
    , "                  (y sl@Pcs) )"
    , "                (! (= (= (set@@sl@Pcs@@sl@Pcs r1 term) (mk-set@@sl@Pcs y))"
    , "                      (forall ( (x sl@Pcs) )"
    , "                              (=> (elem@@sl@Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@@sl@Pcs@@sl@Pcs r1 term)"
    , "                     (mk-set@@sl@Pcs y) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (finite@@sl@Pcs (mk-set@@sl@Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (mk-set@@sl@Pcs x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (forall ( (r1 (set sl@Pcs)) )"
    , "                (! (= (set@@sl@Pcs@@sl@Pcs r1 ident@@sl@Pcs) r1)"
    , "                   :pattern"
    , "                   ( (set@@sl@Pcs@@sl@Pcs r1 ident@@sl@Pcs) ))))"
    , "(assert (forall ( (@@fv@@_0 (set sl@Pcs))"
    , "                  (@@bv@@_0 sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl@Pcs @@bv@@_0 @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl@Pcs)))"
    , "; inv1"
    , "(assert (subset ts vs))"
    , "; inv2"
    , "(assert (subset cs vs))"
    , "(assert (not (=> (and (=> b (= vs sl@Pcs))"
    , "                      (subset ts vs)"
    , "                      (subset cs vs)"
    , "                      (= c (qsum@@sl@Pcs cs (const@@sl@Pcs@@Int 1)))"
    , "                      (finite@@sl@Pcs ts)"
    , "                      (finite@@sl@Pcs cs)"
    , "                      (elem@@Int c (union (mk-set@@Int 0) (mk-set@@Int 1)))"
    , "                      (= (intersect ts cs) empty-set@@sl@Pcs))"
    , "                 (finite@@sl@Pcs (set@@sl@Pcs@@sl@Pcs (@@lambda@@_0 ts) ident@@sl@Pcs)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/INV/WD"
    ]

case10 :: IO String
case10 = proof_obligation path0 "m3/INIT/INV/m3:inv1" 3

result10 :: String
result10 = unlines
    [ "; m3/INIT/INV/m3:inv1"
    , "(set-option :auto-config false)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const c Int)"
    , "(declare-const cs (set sl@Pcs))"
    , "(declare-const n Int)"
    , "(declare-const ts (set sl@Pcs))"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-fun @@lambda@@_0 ( (set sl@Pcs) ) (set sl@Pcs))"
    , "(declare-fun const@@sl@Pcs@@Int (Int) (Array sl@Pcs Int))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(declare-fun mk-set@@sl@Pcs (sl@Pcs) (set sl@Pcs))"
    , "(declare-fun qsum@@sl@Pcs"
    , "             ( (set sl@Pcs)"
    , "               (Array sl@Pcs Int) )"
    , "             Int)"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl@Pcs"
    , "            ( (x sl@Pcs)"
    , "              (s1 (set sl@Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (term (Array sl@Pcs Int)) )"
    , "                (! (= (qsum@@sl@Pcs empty-set@@sl@Pcs term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs empty-set@@sl@Pcs term) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (x sl@Pcs) )"
    , "                (! (=> (not (elem@@sl@Pcs x r))"
    , "                       (= (qsum@@sl@Pcs (union r (mk-set@@sl@Pcs x)) term)"
    , "                          (+ (qsum@@sl@Pcs r term) (select term x))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r (mk-set@@sl@Pcs x)) term) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (r0 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl@Pcs)"
    , "                       (= (qsum@@sl@Pcs (union r r0) term)"
    , "                          (+ (qsum@@sl@Pcs r term) (qsum@@sl@Pcs r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r r0) term) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs r)"
    , "                       (<= 0 (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))))"
    , "                   :pattern"
    , "                   ( (<= 0 (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (= (= (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) 0)"
    , "                      (= r empty-set@@sl@Pcs))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (= (qsum@@sl@Pcs (mk-set@@sl@Pcs x) (const@@sl@Pcs@@Int 1))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (mk-set@@sl@Pcs x) (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (= (= (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) 1)"
    , "                      (exists ( (x sl@Pcs) ) (and true (= r (mk-set@@sl@Pcs x)))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (r0 (set sl@Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl@Pcs)"
    , "                       (= (qsum@@sl@Pcs (union r r0) (const@@sl@Pcs@@Int 1))"
    , "                          (+ (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))"
    , "                             (qsum@@sl@Pcs r0 (const@@sl@Pcs@@Int 1)))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r r0) (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (select (const@@sl@Pcs@@Int x) y) x)"
    , "                   :pattern"
    , "                   ( (select (const@@sl@Pcs@@Int x) y) ))))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (finite@@sl@Pcs (mk-set@@sl@Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (mk-set@@sl@Pcs x)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (forall ( (@@fv@@_0 (set sl@Pcs))"
    , "                  (@@bv@@_0 sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl@Pcs @@bv@@_0 @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; in0"
    , "(assert (= b false))"
    , "; in1"
    , "(assert (= ts empty-set@@sl@Pcs))"
    , "; in2"
    , "(assert (= cs empty-set@@sl@Pcs))"
    , "; m3:in0"
    , "(assert (= c 0))"
    , "; m3:in1"
    , "(assert (= n 0))"
    , "(assert (not (= n"
    , "                (qsum@@sl@Pcs (@@lambda@@_0 ts) (const@@sl@Pcs@@Int 1)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/INIT/INV/m3:inv1"
    ]
