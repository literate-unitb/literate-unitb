{-# LANGUAGE OverloadedStrings #-}
module Document.Tests.Puzzle where

    -- Modules
import Document.Tests.Suite

import Documentation.SummaryGen

import Logic.Expr
import Logic.Proof

    -- Library
import Control.Lens
import Control.Monad

import Data.List as L
import Data.Map
import Data.Set  as S (Set,fromList)

import Tests.UnitTest

test_case :: TestCase
test_case = test_cases 
        "The king and his advisors puzzle"
        [ POCase "puzzle, m0" case0 result0
        , POCase "puzzle, m1" case1 result1
        , Case "puzzle, proof obligation" case2 result2
        , Case "puzzle, event visit" case3 result3
        , Case "puzzle, visit enablement, PO" case4 result4
        , Case "puzzle, visit negation, PO" case5 result5
        -- , Case "puzzle, remove default with weakento" case6 result6
        , POCase "puzzle, m2" case7 result7
        , POCase "puzzle, m3" case8 result8
        , Case "puzzle m3, wd of sums" case9 result9
        , Case "puzzle m3, proofs with sums" case10 result10
        , POCase "puzzle, m4" case11 result11
        , Case "puzzle, deleted variables, m3" case12 result12
        , Case "puzzle, deleted variables, m4" case13 result13
        , StringCase "puzzle, error: invariant referring to deleted variable" case14 result14
        , StringCase "puzzle, error: assignment to deleted variable" case15 result15
        , Case "test 16, puzzle, removing actions, m3" case16 result16
        , Case "test 17, puzzle, removed actions, m4" case17 result17
        , StringCase "test 18, simulation proof obligation" case18 result18
        , StringCase "test 19, simulation proof obligation (init)" case19 result19
        , StringCase "test 20, crashing proof obligation of invariant with witness" case20 result20
        , StringCase "test 21, deleting non-existant action" case21 result21
        , StringCase "test 22, error providing a witness for non-deleted variable" case22 result22
        , StringCase "test 23, error deleting non-existant variable" case23 result23
        , Case "test 24, inherited vs local invariants" case24 result24
        , StringCase "test 25, error: schedules and guards refer to deleted variables" case25 result25
        , Case "test 27, old guards / new guards" case27 result27
        , StringCase "test 28, illegal type application" case28 result28
        ]

path0 :: FilePath
path0 = "Tests/puzzle/puzzle.tex"

case0 :: IO (String, Map Label Sequent)
case0 = verify path0 0

result0 :: String
result0 = unlines
    [ "  o  m0/INIT/FIS/b"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/LIVE/prog0/ensure/SAF/WD/lhs"
    , "  o  m0/LIVE/prog0/ensure/SAF/WD/rhs"
    , "  o  m0/LIVE/prog0/ensure/TR/WD"
    , "  o  m0/LIVE/prog0/ensure/TR/term/EN"
    , "  o  m0/LIVE/prog0/ensure/TR/term/NEG"
    , "  o  m0/prog0/PROG/WD/lhs"
    , "  o  m0/prog0/PROG/WD/rhs"
    , "  o  m0/term/FIS/b@prime"
    , "  o  m0/term/SAF/LIVE/prog0/ensure"
    , "  o  m0/term/WD/ACT/act0"
    , "  o  m0/term/WD/C_SCH"
    , "  o  m0/term/WD/F_SCH"
    , "  o  m0/term/WD/GRD"
    , "  o  m0/term/WWD"
    , "passed 18 / 18"
    ]

case1 :: IO (String, Map Label Sequent)
case1 = verify path0 1

result1 :: String
result1 = unlines
    [ "  o  m1/INIT/FIS/b"
    , "  o  m1/INIT/INV/inv0"
    , "  o  m1/INIT/WD"
    , "  o  m1/INIT/WWD"
    , "  o  m1/INV/WD"
    , "  o  m1/LIVE/prog3/ensure/SAF/WD/lhs"
    , "  o  m1/LIVE/prog3/ensure/SAF/WD/rhs"
    , "  o  m1/LIVE/prog3/ensure/TR/WD"
    , "  o  m1/LIVE/prog3/ensure/TR/WD/witness/p"
    , "  o  m1/LIVE/prog3/ensure/TR/WFIS/p/p@prime"
    , "  o  m1/LIVE/prog3/ensure/TR/visit/EN"
    , "  o  m1/LIVE/prog3/ensure/TR/visit/NEG"
    , "  o  m1/prog1/LIVE/induction/lhs"
    , "  o  m1/prog1/LIVE/induction/rhs"
    , "  o  m1/prog1/PROG/WD/lhs"
    , "  o  m1/prog1/PROG/WD/rhs"
    , "  o  m1/prog2/LIVE/PSP/lhs"
    , "  o  m1/prog2/LIVE/PSP/rhs"
    , "  o  m1/prog2/PROG/WD/lhs"
    , "  o  m1/prog2/PROG/WD/rhs"
    , "  o  m1/prog3/PROG/WD/lhs"
    , "  o  m1/prog3/PROG/WD/rhs"
    , "  o  m1/saf1/SAF/WD/lhs"
    , "  o  m1/saf1/SAF/WD/rhs"
    , "  o  m1/saf2/SAF/WD/lhs"
    , "  o  m1/saf2/SAF/WD/rhs"
    , "  o  m1/term/C_SCH/delay/0/prog/prog1/lhs"
    , "  o  m1/term/C_SCH/delay/0/prog/prog1/rhs/sch1"
    , "  o  m1/term/C_SCH/delay/0/saf/term/SAF/term"
    , "  o  m1/term/C_SCH/delay/0/saf/visit/SAF/term"
    , "  o  m1/term/FIS/b@prime"
    , "  o  m1/term/FIS/vs@prime"
    , "  o  m1/term/GRD/str/sch0"
    , "  o  m1/term/INV/inv0"
    , "  o  m1/term/SAF/LIVE/prog3/ensure"
    , "  o  m1/term/SAF/saf1"
    , "  o  m1/term/SAF/saf2"
    , "  o  m1/term/SCH/grd0"
    , "  o  m1/term/WD/C_SCH"
    , "  o  m1/term/WD/F_SCH"
    , "  o  m1/term/WD/GRD"
    , "  o  m1/term/WWD"
    , "  o  m1/visit/FIS/b@prime"
    , "  o  m1/visit/FIS/vs@prime"
    , "  o  m1/visit/INV/inv0"
    , "  o  m1/visit/SAF/LIVE/prog3/ensure"
    , "  o  m1/visit/SAF/saf1"
    , "  o  m1/visit/SAF/saf2"
    , "  o  m1/visit/WD/ACT/act1"
    , "  o  m1/visit/WD/C_SCH"
    , "  o  m1/visit/WD/F_SCH"
    , "  o  m1/visit/WD/GRD"
    , "  o  m1/visit/WWD"
    , "passed 53 / 53"
    ]

case2 :: IO String
case2 = proof_obligation path0 "m1/prog1/LIVE/induction/rhs" 1

result2 :: String
result2 = unlines
    [ "; m1/prog1/LIVE/induction/rhs"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const V (set sl@Pcs))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-const vs@prime (set sl@Pcs))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(define-fun all@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@Pcs s2) (finite@@sl@Pcs s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs s2)"
    , "                     (finite@@sl@Pcs s1) ))))"
    , "(assert (not (forall ( (V (set sl@Pcs)) )"
    , "                     (=> true"
    , "                         (=> (or (st-subset@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                                 (= vs sl@Pcs))"
    , "                             (or (and (subset (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                                      (subset empty-set@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs))"
    , "                                      (finite@@sl@Pcs (set-diff@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) empty-set@@sl@Pcs)))"
    , "                                 (= vs sl@Pcs)))))))"
    , "(assert (not (=> (or (st-subset@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                     (= vs sl@Pcs))"
    , "                 (or (and (subset (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                          (subset empty-set@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs))"
    , "                          (finite@@sl@Pcs (set-diff@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) empty-set@@sl@Pcs)))"
    , "                     (= vs sl@Pcs)))))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl@Pcs)))"
    , "(assert (not (=> (st-subset@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                 (and (subset (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                      (subset empty-set@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs))"
    , "                      (finite@@sl@Pcs (set-diff@@sl@Pcs (set-diff@@sl@Pcs sl@Pcs vs) empty-set@@sl@Pcs))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/prog1/LIVE/induction/rhs"
    ]

case3 :: IO String
case3 = liftM (either id id) $ runEitherT $ do
    s <- get_system path0
    let ms  = s!.machines
        m   = ms ! "m1"
        visit = "visit"
        evt   = nonSkipUpwards m ! visit
    return $ getListing $ event_summary' m visit evt

result3 :: String
result3 = unlines
    [ "\\noindent \\ref{visit} [p] \\textbf{event}"
    , "\\begin{block}"
    , "  \\item   \\textbf{during}"
    , "  \\begin{block}"
    , "  \\item[ (\\ref{visit}/default) ]\\sout{$\\false$} %"
    , "  \\end{block}"
    , "  \\item   \\textbf{begin}"
    , "  \\begin{block}"
    , "  \\item[ \\eqref{visitact1} ]{$vs \\bcmeq vs \\bunion \\{ p \\}$} %"
    , "  \\end{block}"
    , "  \\item   \\textbf{end} \\\\"
    , "\\end{block}"
    ]

case4 :: IO String
case4 = proof_obligation path0 "m1/LIVE/prog3/ensure/TR/visit/EN" 1

result4 :: String
result4 = unlines
    [ "; m1/LIVE/prog3/ensure/TR/visit/EN"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const V (set sl@Pcs))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-const vs@prime (set sl@Pcs))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(declare-fun mk-set@@sl@Pcs (sl@Pcs) (set sl@Pcs))"
    , "(declare-fun p@param () sl@Pcs)"
    , "(define-fun all@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl@Pcs"
    , "            ( (x sl@Pcs)"
    , "              (s1 (set sl@Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (finite@@sl@Pcs (mk-set@@sl@Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (mk-set@@sl@Pcs x)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@Pcs s2) (finite@@sl@Pcs s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs s2)"
    , "                     (finite@@sl@Pcs s1) ))))"
    , "(assert (not (elem@@sl@Pcs p@param vs)))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl@Pcs)))"
    , "(assert (not true))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/prog3/ensure/TR/visit/EN"
    ]

case5 :: IO String
case5 = proof_obligation path0 "m1/LIVE/prog3/ensure/TR/visit/NEG" 1

result5 :: String
result5 = unlines
    [ "; m1/LIVE/prog3/ensure/TR/visit/NEG"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const V (set sl@Pcs))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-const vs@prime (set sl@Pcs))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(declare-fun mk-set@@sl@Pcs (sl@Pcs) (set sl@Pcs))"
    , "(declare-fun p@param () sl@Pcs)"
    , "(define-fun all@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl@Pcs"
    , "            ( (x sl@Pcs)"
    , "              (s1 (set sl@Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (finite@@sl@Pcs (mk-set@@sl@Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (mk-set@@sl@Pcs x)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@Pcs s2) (finite@@sl@Pcs s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs s2)"
    , "                     (finite@@sl@Pcs s1) ))))"
    , "(assert (not (elem@@sl@Pcs p@param vs)))"
    , "; SKIP:b"
    , "(assert (= b@prime b))"
    , "; act1"
    , "(assert (= vs@prime (union vs (mk-set@@sl@Pcs p@param))))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl@Pcs)))"
    , "(assert (not (=> (and (= (set-diff@@sl@Pcs sl@Pcs vs) V)"
    , "                      (not (= vs sl@Pcs))"
    , "                      (= (set-diff@@sl@Pcs sl@Pcs vs) V))"
    , "                 (not (and (= (set-diff@@sl@Pcs sl@Pcs vs@prime) V)"
    , "                           (not (= vs@prime sl@Pcs))"
    , "                           (= (set-diff@@sl@Pcs sl@Pcs vs@prime) V))))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m1/LIVE/prog3/ensure/TR/visit/NEG"
    ]

-- case6 :: IO String
-- case6 = proof_obligation path0 "m1/visit/SCH/0/REF/weaken" 1

-- result6 :: String
-- result6 = unlines
    -- [ "; m1/visit/SCH/0/REF/weaken"
    -- , "(set-option :auto-config false)"
    -- , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    -- , "(declare-datatypes () ( (Null null) ))"
    -- , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    -- , "; comment: we don't need to declare the sort Bool"
    -- , "; comment: we don't need to declare the sort Int"
    -- , "(declare-sort sl@Pcs 0)"
    -- , "; comment: we don't need to declare the sort Real"
    -- , "(define-sort set (a) (Array a Bool))"
    -- , "(declare-const b Bool)"
    -- , "(declare-const b@prime Bool)"
    -- , "(declare-const vs (set sl@Pcs))"
    -- , "(declare-const vs@prime (set sl@Pcs))"
    -- , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    -- , "(define-fun sl@Pcs"
    -- , "            ()"
    -- , "            (set sl@Pcs)"
    -- , "            ( (as const (set sl@Pcs))"
    -- , "              true ))"
    -- , "(define-fun compl@@sl@Pcs"
    -- , "            ( (s1 (set sl@Pcs)) )"
    -- , "            (set sl@Pcs)"
    -- , "            ( (_ map not)"
    -- , "              s1 ))"
    -- , "(define-fun empty-set@@sl@Pcs"
    -- , "            ()"
    -- , "            (set sl@Pcs)"
    -- , "            ( (as const (set sl@Pcs))"
    -- , "              false ))"
    -- , "(define-fun set-diff@@sl@Pcs"
    -- , "            ( (s1 (set sl@Pcs))"
    -- , "              (s2 (set sl@Pcs)) )"
    -- , "            (set sl@Pcs)"
    -- , "            (intersect s1 ( (_ map not) s2 )))"
    -- , "(define-fun st-subset@@sl@Pcs"
    -- , "            ( (s1 (set sl@Pcs))"
    -- , "              (s2 (set sl@Pcs)) )"
    -- , "            Bool"
    -- , "            (and (subset s1 s2) (not (= s1 s2))))"
    -- , "(assert (forall ( (s1 (set sl@Pcs))"
    -- , "                  (s2 (set sl@Pcs)) )"
    -- , "                (! (=> (finite@@sl@Pcs s1)"
    -- , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    -- , "                   :pattern"
    -- , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    -- , "(assert (forall ( (s1 (set sl@Pcs))"
    -- , "                  (s2 (set sl@Pcs)) )"
    -- , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    -- , "                       (finite@@sl@Pcs (union s1 s2)))"
    -- , "                   :pattern"
    -- , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    -- , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    -- , "; asm0"
    -- , "(assert (finite@@sl@Pcs sl@Pcs))"
    -- , "; inv0"
    -- , "(assert (=> b (= vs sl@Pcs)))"
    -- , "(assert (not true))"
    -- , "(check-sat-using (or-else (then qe smt)"
    -- , "                          (then simplify smt)"
    -- , "                          (then skip smt)"
    -- , "                          (then (using-params simplify :expand-power true) smt)))"
    -- , "; m1/visit/SCH/0/REF/weaken"
    -- ]

case7 :: IO (String, Map Label Sequent)
case7 = verify path0 2

result7 :: String
result7 = unlines
    [ "  o  m2/INIT/FIS/b"
    , "  o  m2/INIT/FIS/cs"
    , "  o  m2/INIT/FIS/ts"
    , "  o  m2/INIT/INV/inv1"
    , "  o  m2/INIT/INV/inv2"
    , "  o  m2/INIT/WD"
    , "  o  m2/INIT/WWD"
    , "  o  m2/INV/WD"
    , "  o  m2/LIVE/prog10/ensure/SAF/WD/lhs"
    , "  o  m2/LIVE/prog10/ensure/SAF/WD/rhs"
    , "  o  m2/LIVE/prog10/ensure/TR/WD"
    , "  o  m2/LIVE/prog10/ensure/TR/count/EN"
    , "  o  m2/LIVE/prog10/ensure/TR/count/NEG"
    , "  o  m2/LIVE/prog11/ensure/SAF/WD/lhs"
    , "  o  m2/LIVE/prog11/ensure/SAF/WD/rhs"
    , "  o  m2/LIVE/prog11/ensure/TR/WD"
    , "  o  m2/LIVE/prog11/ensure/TR/WD/witness/p"
    , "  o  m2/LIVE/prog11/ensure/TR/WFIS/p/p@prime"
    , "  o  m2/LIVE/prog11/ensure/TR/visit/EN"
    , "  o  m2/LIVE/prog11/ensure/TR/visit/NEG"
    , "  o  m2/LIVE/prog6/ensure/SAF/WD/lhs"
    , "  o  m2/LIVE/prog6/ensure/SAF/WD/rhs"
    , "  o  m2/LIVE/prog6/ensure/TR/WD"
    , "  o  m2/LIVE/prog6/ensure/TR/WD/witness/p"
    , "  o  m2/LIVE/prog6/ensure/TR/WFIS/p/p@prime"
    , "  o  m2/LIVE/prog6/ensure/TR/flick/EN"
    , "  o  m2/LIVE/prog6/ensure/TR/flick/NEG"
    , "  o  m2/LIVE/prog7/ensure/SAF/WD/lhs"
    , "  o  m2/LIVE/prog7/ensure/SAF/WD/rhs"
    , "  o  m2/LIVE/prog7/ensure/TR/WD"
    , "  o  m2/LIVE/prog7/ensure/TR/count/EN"
    , "  o  m2/LIVE/prog7/ensure/TR/count/NEG"
    , "  o  m2/count/FIS/b@prime"
    , "  o  m2/count/FIS/cs@prime"
    , "  o  m2/count/FIS/ts@prime"
    , "  o  m2/count/FIS/vs@prime"
    , "  o  m2/count/INV/inv1"
    , "  o  m2/count/INV/inv2"
    , "  o  m2/count/SAF/LIVE/prog10/ensure"
    , "  o  m2/count/SAF/LIVE/prog11/ensure"
    , "  o  m2/count/SAF/LIVE/prog6/ensure"
    , "  o  m2/count/SAF/LIVE/prog7/ensure"
    , "  o  m2/count/SAF/saf3"
    , "  o  m2/count/SAF/saf8"
    , "  o  m2/count/WD/ACT/act0"
    , "  o  m2/count/WD/ACT/act1"
    , "  o  m2/count/WD/C_SCH"
    , "  o  m2/count/WD/F_SCH"
    , "  o  m2/count/WD/GRD"
    , "  o  m2/count/WWD"
    , "  o  m2/flick/FIS/b@prime"
    , "  o  m2/flick/FIS/cs@prime"
    , "  o  m2/flick/FIS/ts@prime"
    , "  o  m2/flick/FIS/vs@prime"
    , "  o  m2/flick/INV/inv1"
    , "  o  m2/flick/INV/inv2"
    , "  o  m2/flick/SAF/LIVE/prog10/ensure"
    , "  o  m2/flick/SAF/LIVE/prog11/ensure"
    , "  o  m2/flick/SAF/LIVE/prog6/ensure"
    , "  o  m2/flick/SAF/LIVE/prog7/ensure"
    , "  o  m2/flick/SAF/saf3"
    , "  o  m2/flick/SAF/saf8"
    , "  o  m2/flick/SCH/grd0"
    , "  o  m2/flick/SCH/grd1"
    , "  o  m2/flick/WD/ACT/act0"
    , "  o  m2/flick/WD/C_SCH"
    , "  o  m2/flick/WD/F_SCH"
    , "  o  m2/flick/WD/GRD"
    , "  o  m2/flick/WWD"
    , "  o  m2/prog10/PROG/WD/lhs"
    , "  o  m2/prog10/PROG/WD/rhs"
    , "  o  m2/prog11/PROG/WD/lhs"
    , "  o  m2/prog11/PROG/WD/rhs"
    , "  o  m2/prog4/LIVE/transitivity/lhs"
    , "  o  m2/prog4/LIVE/transitivity/mhs/0/1"
    , "  o  m2/prog4/LIVE/transitivity/rhs"
    , "  o  m2/prog4/PROG/WD/lhs"
    , "  o  m2/prog4/PROG/WD/rhs"
    , "  o  m2/prog5/LIVE/PSP/lhs"
    , "  o  m2/prog5/LIVE/PSP/rhs"
    , "  o  m2/prog5/PROG/WD/lhs"
    , "  o  m2/prog5/PROG/WD/rhs"
    , "  o  m2/prog6/PROG/WD/lhs"
    , "  o  m2/prog6/PROG/WD/rhs"
    , "  o  m2/prog7/PROG/WD/lhs"
    , "  o  m2/prog7/PROG/WD/rhs"
    , "  o  m2/prog8/LIVE/transitivity/lhs"
    , "  o  m2/prog8/LIVE/transitivity/mhs/0/1"
    , "  o  m2/prog8/LIVE/transitivity/mhs/1/2"
    , "  o  m2/prog8/LIVE/transitivity/rhs"
    , "  o  m2/prog8/PROG/WD/lhs"
    , "  o  m2/prog8/PROG/WD/rhs"
    , "  o  m2/prog9/LIVE/induction/lhs"
    , "  o  m2/prog9/LIVE/induction/rhs"
    , "  o  m2/prog9/PROG/WD/lhs"
    , "  o  m2/prog9/PROG/WD/rhs"
    , "  o  m2/saf3/SAF/WD/lhs"
    , "  o  m2/saf3/SAF/WD/rhs"
    , "  o  m2/saf8/SAF/WD/lhs"
    , "  o  m2/saf8/SAF/WD/rhs"
    , "  o  m2/term/C_SCH/delay/0/prog/prog4/lhs"
    , "  o  m2/term/C_SCH/delay/0/prog/prog4/rhs/sch2"
    , "  o  m2/term/C_SCH/delay/0/saf/count/SAF/term"
    , "  o  m2/term/C_SCH/delay/0/saf/flick/SAF/term"
    , "  o  m2/term/C_SCH/delay/0/saf/term/SAF/term"
    , "  o  m2/term/C_SCH/delay/0/saf/visit/SAF/term"
    , "  o  m2/term/FIS/b@prime"
    , "  o  m2/term/FIS/cs@prime"
    , "  o  m2/term/FIS/ts@prime"
    , "  o  m2/term/FIS/vs@prime"
    , "  o  m2/term/GRD/str/sch1"
    , "  o  m2/term/INV/inv1"
    , "  o  m2/term/INV/inv2"
    , "  o  m2/term/SAF/LIVE/prog10/ensure"
    , "  o  m2/term/SAF/LIVE/prog11/ensure"
    , "  o  m2/term/SAF/LIVE/prog6/ensure"
    , "  o  m2/term/SAF/LIVE/prog7/ensure"
    , "  o  m2/term/SAF/saf3"
    , "  o  m2/term/SAF/saf8"
    , "  o  m2/term/SCH/grd0"
    , "  o  m2/term/WD/C_SCH"
    , "  o  m2/term/WD/F_SCH"
    , "  o  m2/term/WD/GRD"
    , "  o  m2/term/WWD"
    , "  o  m2/visit/FIS/b@prime"
    , "  o  m2/visit/FIS/cs@prime"
    , "  o  m2/visit/FIS/ts@prime"
    , "  o  m2/visit/FIS/vs@prime"
    , "  o  m2/visit/INV/inv1"
    , "  o  m2/visit/INV/inv2"
    , "  o  m2/visit/SAF/LIVE/prog10/ensure"
    , "  o  m2/visit/SAF/LIVE/prog11/ensure"
    , "  o  m2/visit/SAF/LIVE/prog6/ensure"
    , "  o  m2/visit/SAF/LIVE/prog7/ensure"
    , "  o  m2/visit/SAF/saf3"
    , "  o  m2/visit/SAF/saf8"
    , "  o  m2/visit/WD/C_SCH"
    , "  o  m2/visit/WD/F_SCH"
    , "  o  m2/visit/WD/GRD"
    , "  o  m2/visit/WWD"
    , "passed 140 / 140"
    ]

case8 :: IO (String, Map Label Sequent)
case8 = verify path0 3

result8 :: String
result8 = unlines 
    [ "  o  m3/INIT/FIS/b"
    , "  o  m3/INIT/FIS/c"
    , "  o  m3/INIT/FIS/fs"
    , "  o  m3/INIT/FIS/n"
    , "  o  m3/INIT/INV/m3:inv0"
    , "  o  m3/INIT/INV/m3:inv1"
    , "  o  m3/INIT/INV/m3:inv2"
    , "  o  m3/INIT/INV/m3:inv5"
    , "  o  m3/INIT/INV/m3:inv6"
    , "  o  m3/INIT/INV/m3:inv7"
    , "  o  m3/INIT/SIM/in1"
    , "  o  m3/INIT/SIM/in2"
    , "  o  m3/INIT/WD"
    , "  o  m3/INIT/WFIS/cs"
    , "  o  m3/INIT/WFIS/ts"
    , "  o  m3/INIT/WWD"
    , "  o  m3/INV/WD"
    , "  o  m3/THM/thm0/goal"
    , "  o  m3/THM/thm0/hypotheses"
    , "  o  m3/THM/thm0/relation"
    , "  o  m3/THM/thm0/step 1"
    , "  o  m3/THM/thm0/step 2"
    , "  o  m3/THM/thm0/step 3"
    , "  o  m3/THM/thm0/step 4"
    , "  o  m3/THM/thm0/step 5"
    , "  o  m3/THM/thm0/step 6"
    , "  o  m3/count/C_SCH/weaken/sch1"
    , "  o  m3/count/FIS/b@prime"
    , "  o  m3/count/FIS/c@prime"
    , "  o  m3/count/FIS/fs@prime"
    , "  o  m3/count/FIS/n@prime"
    , "  o  m3/count/FIS/vs@prime"
    , "  o  m3/count/GRD/str/sch0"
    , "  o  m3/count/INV/m3:inv0"
    , "  o  m3/count/INV/m3:inv1"
    , "  o  m3/count/INV/m3:inv2"
    , "  o  m3/count/INV/m3:inv5"
    , "  o  m3/count/INV/m3:inv6"
    , "  o  m3/count/INV/m3:inv7"
    , "  o  m3/count/SCH/m3:grd0"
    , "  o  m3/count/SIM/act0"
    , "  o  m3/count/SIM/act1"
    , "  o  m3/count/WD/ACT/m3:act0"
    , "  o  m3/count/WD/ACT/m3:act1"
    , "  o  m3/count/WD/C_SCH"
    , "  o  m3/count/WD/F_SCH"
    , "  o  m3/count/WD/GRD"
    , "  o  m3/count/WFIS/cs@prime"
    , "  o  m3/count/WFIS/ts@prime"
    , "  o  m3/count/WWD"
    , "  o  m3/flick/C_SCH/weaken/m3:csch1"
    , "  o  m3/flick/C_SCH/weaken/m3:csch2"
    , "  o  m3/flick/FIS/b@prime"
    , "  o  m3/flick/FIS/c@prime"
    , "  o  m3/flick/FIS/fs@prime"
    , "  o  m3/flick/FIS/n@prime"
    , "  o  m3/flick/FIS/vs@prime"
    , "  o  m3/flick/GRD/str/grd0"
    , "  o  m3/flick/GRD/str/sch0"
    , "  o  m3/flick/GRD/str/sch1"
    , "  o  m3/flick/INV/m3:inv0"
    , "  o  m3/flick/INV/m3:inv1"
    , "  o  m3/flick/INV/m3:inv2"
    , "  o  m3/flick/INV/m3:inv5"
    , "  o  m3/flick/INV/m3:inv6"
    , "  o  m3/flick/INV/m3:inv7"
    , "  o  m3/flick/SCH/grd1"
    , "  o  m3/flick/SCH/m3:grd1"
    , "  o  m3/flick/SCH/m3:grd2"
    , "  o  m3/flick/SIM/act0"
    , "  o  m3/flick/WD/ACT/m3:act0"
    , "  o  m3/flick/WD/ACT/m3:act2"
    , "  o  m3/flick/WD/C_SCH"
    , "  o  m3/flick/WD/F_SCH"
    , "  o  m3/flick/WD/GRD"
    , "  o  m3/flick/WFIS/cs@prime"
    , "  o  m3/flick/WWD"
    , "  o  m3/term/C_SCH/weaken/sch3"
    , "  o  m3/term/FIS/b@prime"
    , "  o  m3/term/FIS/c@prime"
    , "  o  m3/term/FIS/fs@prime"
    , "  o  m3/term/FIS/n@prime"
    , "  o  m3/term/FIS/vs@prime"
    , "  o  m3/term/GRD/str/sch2"
    , "  o  m3/term/INV/m3:inv0"
    , "  o  m3/term/INV/m3:inv1"
    , "  o  m3/term/INV/m3:inv2"
    , "  o  m3/term/INV/m3:inv5"
    , "  o  m3/term/INV/m3:inv6"
    , "  o  m3/term/INV/m3:inv7"
    , "  o  m3/term/SCH/grd0"
    , "  o  m3/term/WD/C_SCH"
    , "  o  m3/term/WD/F_SCH"
    , "  o  m3/term/WD/GRD"
    , "  o  m3/term/WWD"
    , "  o  m3/visit/FIS/b@prime"
    , "  o  m3/visit/FIS/c@prime"
    , "  o  m3/visit/FIS/fs@prime"
    , "  o  m3/visit/FIS/n@prime"
    , "  o  m3/visit/FIS/vs@prime"
    , "  o  m3/visit/INV/m3:inv0"
    , "  o  m3/visit/INV/m3:inv1"
    , "  o  m3/visit/INV/m3:inv2"
    , "  o  m3/visit/INV/m3:inv5"
    , "  o  m3/visit/INV/m3:inv6"
    , "  o  m3/visit/INV/m3:inv7"
    , "  o  m3/visit/WD/C_SCH"
    , "  o  m3/visit/WD/F_SCH"
    , "  o  m3/visit/WD/GRD"
    , "  o  m3/visit/WWD"
    , "passed 110 / 110"
    ]

case9 :: IO String
case9 = proof_obligation path0 "m3/INV/WD" 3

result9 :: String
result9 = unlines
    [ "; m3/INV/WD"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const c Int)"
    , "(declare-const cs (set sl@Pcs))"
    , "(declare-const fs (set sl@Pcs))"
    , "(declare-const n Int)"
    , "(declare-const ts (set sl@Pcs))"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-fun const@@sl@Pcs@@Int (Int) (Array sl@Pcs Int))"
    , "(declare-fun const@@sl@Pcs@@sl@Pcs"
    , "             (sl@Pcs)"
    , "             (Array sl@Pcs sl@Pcs))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(declare-fun ident@@sl@Pcs () (Array sl@Pcs sl@Pcs))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@Pcs (sl@Pcs) (set sl@Pcs))"
    , "(declare-fun qsum@@sl@Pcs"
    , "             ( (set sl@Pcs)"
    , "               (Array sl@Pcs Int) )"
    , "             Int)"
    , "(declare-fun set@@sl@Pcs@@Int"
    , "             ( (set sl@Pcs)"
    , "               (Array sl@Pcs Int) )"
    , "             (set Int))"
    , "(declare-fun set@@sl@Pcs@@sl@Pcs"
    , "             ( (set sl@Pcs)"
    , "               (Array sl@Pcs sl@Pcs) )"
    , "             (set sl@Pcs))"
    , "(declare-fun @@lambda@@_0 ( (set sl@Pcs) ) (set sl@Pcs))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@Pcs"
    , "            ( (x sl@Pcs)"
    , "              (s1 (set sl@Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(assert (forall ( (term (Array sl@Pcs Int)) )"
    , "                (! (= (qsum@@sl@Pcs empty-set@@sl@Pcs term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs empty-set@@sl@Pcs term) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (x sl@Pcs) )"
    , "                (! (=> (not (elem@@sl@Pcs x r))"
    , "                       (= (qsum@@sl@Pcs (union r (mk-set@@sl@Pcs x)) term)"
    , "                          (+ (qsum@@sl@Pcs r term) (select term x))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r (mk-set@@sl@Pcs x)) term) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (r0 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl@Pcs)"
    , "                       (= (qsum@@sl@Pcs (union r r0) term)"
    , "                          (+ (qsum@@sl@Pcs r term) (qsum@@sl@Pcs r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r r0) term) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs r)"
    , "                       (<= 0 (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))))"
    , "                   :pattern"
    , "                   ( (<= 0 (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (= (= (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) 0)"
    , "                      (= r empty-set@@sl@Pcs))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (= (qsum@@sl@Pcs (mk-set@@sl@Pcs x) (const@@sl@Pcs@@Int 1))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (mk-set@@sl@Pcs x) (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (= (= (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) 1)"
    , "                      (exists ( (x sl@Pcs) ) (and true (= r (mk-set@@sl@Pcs x)))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (r0 (set sl@Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl@Pcs)"
    , "                       (= (qsum@@sl@Pcs (union r r0) (const@@sl@Pcs@@Int 1))"
    , "                          (+ (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))"
    , "                             (qsum@@sl@Pcs r0 (const@@sl@Pcs@@Int 1)))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r r0) (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (select (const@@sl@Pcs@@Int x) y) x)"
    , "                   :pattern"
    , "                   ( (select (const@@sl@Pcs@@Int x) y) ))))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (select (const@@sl@Pcs@@sl@Pcs x) y) x)"
    , "                   :pattern"
    , "                   ( (select (const@@sl@Pcs@@sl@Pcs x) y) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (= (select ident@@sl@Pcs x) x)"
    , "                   :pattern"
    , "                   ( (select ident@@sl@Pcs x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int y (set@@sl@Pcs@@Int r1 term))"
    , "                      (exists ( (x sl@Pcs) )"
    , "                              (and (elem@@sl@Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Int y (set@@sl@Pcs@@Int r1 term)) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs sl@Pcs))"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs y (set@@sl@Pcs@@sl@Pcs r1 term))"
    , "                      (exists ( (x sl@Pcs) )"
    , "                              (and (elem@@sl@Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs y (set@@sl@Pcs@@sl@Pcs r1 term)) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (y Int) )"
    , "                (! (= (= (set@@sl@Pcs@@Int r1 term) (mk-set@@Int y))"
    , "                      (forall ( (x sl@Pcs) )"
    , "                              (=> (elem@@sl@Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@@sl@Pcs@@Int r1 term)"
    , "                     (mk-set@@Int y) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs sl@Pcs))"
    , "                  (y sl@Pcs) )"
    , "                (! (= (= (set@@sl@Pcs@@sl@Pcs r1 term) (mk-set@@sl@Pcs y))"
    , "                      (forall ( (x sl@Pcs) )"
    , "                              (=> (elem@@sl@Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@@sl@Pcs@@sl@Pcs r1 term)"
    , "                     (mk-set@@sl@Pcs y) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (finite@@sl@Pcs (mk-set@@sl@Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (mk-set@@sl@Pcs x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@Pcs s2) (finite@@sl@Pcs s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs s2)"
    , "                     (finite@@sl@Pcs s1) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs)) )"
    , "                (! (= (set@@sl@Pcs@@sl@Pcs r1 ident@@sl@Pcs) r1)"
    , "                   :pattern"
    , "                   ( (set@@sl@Pcs@@sl@Pcs r1 ident@@sl@Pcs) ))))"
    , "(assert (forall ( (@@fv@@_0 (set sl@Pcs))"
    , "                  (@@bv@@_0 sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl@Pcs @@bv@@_0 @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl@Pcs)))"
    , "; inv1"
    , "(assert (subset ts vs))"
    , "; inv2"
    , "(assert (subset cs vs))"
    , "(assert (not (=> (and (= c (qsum@@sl@Pcs cs (const@@sl@Pcs@@Int 1)))"
    , "                      (finite@@sl@Pcs ts)"
    , "                      (elem@@Int c (union (mk-set@@Int 0) (mk-set@@Int 1)))"
    , "                      (= (intersect ts cs) empty-set@@sl@Pcs)"
    , "                      (= fs (union ts cs)))"
    , "                 (finite@@sl@Pcs (set@@sl@Pcs@@sl@Pcs (@@lambda@@_0 ts) ident@@sl@Pcs)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/INV/WD"
    ]

case10 :: IO String
case10 = proof_obligation path0 "m3/INIT/INV/m3:inv1" 3

result10 :: String
result10 = unlines
    [ "; m3/INIT/INV/m3:inv1"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const c Int)"
    , "(declare-const cs (set sl@Pcs))"
    , "(declare-const fs (set sl@Pcs))"
    , "(declare-const n Int)"
    , "(declare-const ts (set sl@Pcs))"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-fun const@@sl@Pcs@@Int (Int) (Array sl@Pcs Int))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(declare-fun mk-set@@sl@Pcs (sl@Pcs) (set sl@Pcs))"
    , "(declare-fun qsum@@sl@Pcs"
    , "             ( (set sl@Pcs)"
    , "               (Array sl@Pcs Int) )"
    , "             Int)"
    , "(declare-fun @@lambda@@_0 ( (set sl@Pcs) ) (set sl@Pcs))"
    , "(define-fun all@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@sl@Pcs"
    , "            ( (x sl@Pcs)"
    , "              (s1 (set sl@Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(assert (forall ( (term (Array sl@Pcs Int)) )"
    , "                (! (= (qsum@@sl@Pcs empty-set@@sl@Pcs term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs empty-set@@sl@Pcs term) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (x sl@Pcs) )"
    , "                (! (=> (not (elem@@sl@Pcs x r))"
    , "                       (= (qsum@@sl@Pcs (union r (mk-set@@sl@Pcs x)) term)"
    , "                          (+ (qsum@@sl@Pcs r term) (select term x))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r (mk-set@@sl@Pcs x)) term) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (r0 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl@Pcs)"
    , "                       (= (qsum@@sl@Pcs (union r r0) term)"
    , "                          (+ (qsum@@sl@Pcs r term) (qsum@@sl@Pcs r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r r0) term) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs r)"
    , "                       (<= 0 (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))))"
    , "                   :pattern"
    , "                   ( (<= 0 (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (= (= (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) 0)"
    , "                      (= r empty-set@@sl@Pcs))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (= (qsum@@sl@Pcs (mk-set@@sl@Pcs x) (const@@sl@Pcs@@Int 1))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (mk-set@@sl@Pcs x) (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (= (= (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) 1)"
    , "                      (exists ( (x sl@Pcs) ) (and true (= r (mk-set@@sl@Pcs x)))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (r0 (set sl@Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl@Pcs)"
    , "                       (= (qsum@@sl@Pcs (union r r0) (const@@sl@Pcs@@Int 1))"
    , "                          (+ (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))"
    , "                             (qsum@@sl@Pcs r0 (const@@sl@Pcs@@Int 1)))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r r0) (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (select (const@@sl@Pcs@@Int x) y) x)"
    , "                   :pattern"
    , "                   ( (select (const@@sl@Pcs@@Int x) y) ))))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (finite@@sl@Pcs (mk-set@@sl@Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (mk-set@@sl@Pcs x)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@Pcs s2) (finite@@sl@Pcs s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs s2)"
    , "                     (finite@@sl@Pcs s1) ))))"
    , "(assert (forall ( (@@fv@@_0 (set sl@Pcs))"
    , "                  (@@bv@@_0 sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl@Pcs @@bv@@_0 @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; cs"
    , "(assert (= cs empty-set@@sl@Pcs))"
    , "; in0"
    , "(assert (= b false))"
    , "; m3:in0"
    , "(assert (= c 0))"
    , "; m3:in1"
    , "(assert (= n 0))"
    , "; m3:in2"
    , "(assert (= fs empty-set@@sl@Pcs))"
    , "; ts"
    , "(assert (= ts empty-set@@sl@Pcs))"
    , "(assert (not (= n"
    , "                (qsum@@sl@Pcs (@@lambda@@_0 ts) (const@@sl@Pcs@@Int 1)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/INIT/INV/m3:inv1"
    ]

case11 :: IO (String, Map Label Sequent)
case11 = verify path0 4

result11 :: String
result11 = unlines
    [ "  o  m4/INIT/FIS/b"
    , "  o  m4/INIT/FIS/c"
    , "  o  m4/INIT/FIS/fs"
    , "  o  m4/INIT/FIS/n"
    , "  o  m4/INIT/WD"
    , "  o  m4/INIT/WWD"
    , "  o  m4/INV/WD"
    , "  o  m4/count/FIS/b@prime"
    , "  o  m4/count/FIS/c@prime"
    , "  o  m4/count/FIS/fs@prime"
    , "  o  m4/count/FIS/n@prime"
    , "  o  m4/count/FIS/vs@prime"
    , "  o  m4/count/WD/C_SCH"
    , "  o  m4/count/WD/F_SCH"
    , "  o  m4/count/WD/GRD"
    , "  o  m4/count/WWD"
    , "  o  m4/flick/FIS/b@prime"
    , "  o  m4/flick/FIS/c@prime"
    , "  o  m4/flick/FIS/fs@prime"
    , "  o  m4/flick/FIS/n@prime"
    , "  o  m4/flick/FIS/vs@prime"
    , "  o  m4/flick/WD/C_SCH"
    , "  o  m4/flick/WD/F_SCH"
    , "  o  m4/flick/WD/GRD"
    , "  o  m4/flick/WWD"
    , "  o  m4/term/FIS/b@prime"
    , "  o  m4/term/FIS/c@prime"
    , "  o  m4/term/FIS/fs@prime"
    , "  o  m4/term/FIS/n@prime"
    , "  o  m4/term/FIS/vs@prime"
    , "  o  m4/term/WD/C_SCH"
    , "  o  m4/term/WD/F_SCH"
    , "  o  m4/term/WD/GRD"
    , "  o  m4/term/WWD"
    , "  o  m4/visit/FIS/b@prime"
    , "  o  m4/visit/FIS/c@prime"
    , "  o  m4/visit/FIS/fs@prime"
    , "  o  m4/visit/FIS/n@prime"
    , "  o  m4/visit/FIS/vs@prime"
    , "  o  m4/visit/WD/C_SCH"
    , "  o  m4/visit/WD/F_SCH"
    , "  o  m4/visit/WD/GRD"
    , "  o  m4/visit/WWD"
    , "passed 43 / 43"
    ]

case12 :: IO (Either [Error] (Set Name,Set Name,Set Name))
case12 = runEitherT $ do
    m <- EitherT $ parse_machine path0 3
    return ( keysSet $ m!.abs_vars
           , keysSet $ m!.del_vars
           , keysSet $ m!.variables)

result12 :: Either [Error] (Set Name,Set Name,Set Name)
result12 = Right $ ( ["b","cs","ts","vs"]
                   , ["cs","ts"]
                   , ["b","vs","n","c","fs"])
                 & each %~ (S.fromList . L.map fromString'')

case13 :: IO (Either [Error] (Set Name,Set Name,Set Name))
case13 = runEitherT $ do
    m <- EitherT $ parse_machine path0 4
    return ( keysSet $ m!.abs_vars
           , keysSet $ m!.del_vars
           , keysSet $ m!.variables)

result13 :: Either [Error] (Set Name,Set Name,Set Name)
result13 = Right $ ( ["b","vs","n","c","fs"]
                   , ["cs","ts"]
                   , ["b","vs","n","c","fs"])
                 & each %~ (S.fromList . L.map fromString'')

path14 :: FilePath
path14 = "Tests/puzzle/puzzle-err0.tex"

case14 :: IO String
case14 = find_errors path14

result14 :: String
result14 = unlines
        [ "error 225:24:"
        , "    unrecognized term: cs"
        , "Perhaps you meant:"
        , "c (variable)"
        , "ts (variable)"
        , "vs (variable)"
        , "\\Pcs (variable)"
        , "" ]

path15 :: FilePath
path15 = "Tests/puzzle/puzzle-err1.tex"

case15 :: IO String
case15 = find_errors path15

result15 :: String
result15 = unlines
    [ "event 'count', action 'act0' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 179:2:"
    , "\taction 'act0'"
    , ""
    , ""
    , "event 'count', action 'act1' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 180:2:"
    , "\taction 'act1'"
    , ""
    , ""
    , "event 'count', coarse schedule 'sch0' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 176:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    , "event 'flick', action 'act0' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 163:2:"
    , "\taction 'act0'"
    , ""
    , ""
    , "event 'flick', coarse schedule 'sch0' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 160:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    , "initialization predicate 'in2' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable cs"
    , ""
    , "error 175:2:"
    , "\tpredicate in2"
    , ""
    , ""
    ]

case16 :: IO (Either [Error] (Set Label,Set Label,Set Label))
case16 = runEitherT $ do
    m <- EitherT $ parse_machine path0 3
    let evt = all_upwards m ! "count"
    return ( keysSet $ evt^.evt_pairs.traverse.old.actions
           , keysSet $ evt^.evt_pairs.traverse.deleted.actions
           , keysSet $ evt^.new.actions)

result16 :: Either [Error] (Set Label,Set Label,Set Label)
result16 = Right ( S.fromList ["act0","act1"]
                 , S.fromList ["act0","act1"]
                 , S.fromList ["m3:act0","m3:act1"])

case17 :: IO (Either [Error] (Set Label,Set Label,Set Label))
case17 = runEitherT $ do
    m <- EitherT $ parse_machine path0 4
    let evt = all_upwards m ! "count"
    return ( keysSet $ evt^.evt_pairs.traverse.old.actions
           , keysSet $ evt^.evt_pairs.traverse.deleted.actions
           , keysSet $ evt^.new.actions)

result17 :: Either [Error] (Set Label,Set Label,Set Label)
result17 = Right ( S.fromList ["m3:act0","m3:act1"]
                 , S.fromList []
                 , S.fromList ["m3:act0","m3:act1"])

case18 :: IO String
case18 = proof_obligation path0 "m3/count/SIM/act0" 3

result18 :: String
result18 = unlines
    [ "; m3/count/SIM/act0"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const c Int)"
    , "(declare-const c@prime Int)"
    , "(declare-const cs (set sl@Pcs))"
    , "(declare-const cs@prime (set sl@Pcs))"
    , "(declare-const fs (set sl@Pcs))"
    , "(declare-const fs@prime (set sl@Pcs))"
    , "(declare-const n Int)"
    , "(declare-const n@prime Int)"
    , "(declare-const ts (set sl@Pcs))"
    , "(declare-const ts@prime (set sl@Pcs))"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-const vs@prime (set sl@Pcs))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(define-fun all@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@Pcs s2) (finite@@sl@Pcs s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs s2)"
    , "                     (finite@@sl@Pcs s1) ))))"
    , "; SKIP:b"
    , "(assert (= b@prime b))"
    , "; SKIP:fs"
    , "(assert (= fs@prime fs))"
    , "; SKIP:vs"
    , "(assert (= vs@prime vs))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; cs"
    , "(assert (= cs@prime empty-set@@sl@Pcs))"
    , "; m3:act0"
    , "(assert (= c@prime 0))"
    , "; m3:act1"
    , "(assert (= n@prime (+ n 1)))"
    , "; m3:grd0"
    , "(assert (= c 1))"
    , "; sch1"
    , "(assert (= c 1))"
    , "; ts"
    , "(assert (= ts@prime (union ts cs)))"
    , "(assert (not (= cs@prime empty-set@@sl@Pcs)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/count/SIM/act0"
    ]

case20 :: IO String
case20 = proof_obligation path0 "m3/visit/INV/m3:inv0" 3

result20 :: String
result20 = unlines
    [ "; m3/visit/INV/m3:inv0"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const b@prime Bool)"
    , "(declare-const c Int)"
    , "(declare-const c@prime Int)"
    , "(declare-const cs (set sl@Pcs))"
    , "(declare-const cs@prime (set sl@Pcs))"
    , "(declare-const fs (set sl@Pcs))"
    , "(declare-const fs@prime (set sl@Pcs))"
    , "(declare-const n Int)"
    , "(declare-const n@prime Int)"
    , "(declare-const p sl@Pcs)"
    , "(declare-const ts (set sl@Pcs))"
    , "(declare-const ts@prime (set sl@Pcs))"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-const vs@prime (set sl@Pcs))"
    , "(declare-fun const@@sl@Pcs@@Int (Int) (Array sl@Pcs Int))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun mk-set@@sl@Pcs (sl@Pcs) (set sl@Pcs))"
    , "(declare-fun qsum@@sl@Pcs"
    , "             ( (set sl@Pcs)"
    , "               (Array sl@Pcs Int) )"
    , "             Int)"
    , "(declare-fun set@@sl@Pcs@@Int"
    , "             ( (set sl@Pcs)"
    , "               (Array sl@Pcs Int) )"
    , "             (set Int))"
    , "(declare-fun @@lambda@@_0 ( (set sl@Pcs) ) (set sl@Pcs))"
    , "(define-fun all@@Int () (set Int) ( (as const (set Int)) true ))"
    , "(define-fun all@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun elem@@sl@Pcs"
    , "            ( (x sl@Pcs)"
    , "              (s1 (set sl@Pcs)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(assert (forall ( (term (Array sl@Pcs Int)) )"
    , "                (! (= (qsum@@sl@Pcs empty-set@@sl@Pcs term) 0)"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs empty-set@@sl@Pcs term) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (x sl@Pcs) )"
    , "                (! (=> (not (elem@@sl@Pcs x r))"
    , "                       (= (qsum@@sl@Pcs (union r (mk-set@@sl@Pcs x)) term)"
    , "                          (+ (qsum@@sl@Pcs r term) (select term x))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r (mk-set@@sl@Pcs x)) term) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (r0 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl@Pcs)"
    , "                       (= (qsum@@sl@Pcs (union r r0) term)"
    , "                          (+ (qsum@@sl@Pcs r term) (qsum@@sl@Pcs r0 term))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r r0) term) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs r)"
    , "                       (<= 0 (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))))"
    , "                   :pattern"
    , "                   ( (<= 0 (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (= (= (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) 0)"
    , "                      (= r empty-set@@sl@Pcs))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (= (qsum@@sl@Pcs (mk-set@@sl@Pcs x) (const@@sl@Pcs@@Int 1))"
    , "                      1)"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (mk-set@@sl@Pcs x) (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (r (set sl@Pcs)) )"
    , "                (! (= (= (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) 1)"
    , "                      (exists ( (x sl@Pcs) ) (and true (= r (mk-set@@sl@Pcs x)))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (r (set sl@Pcs))"
    , "                  (r0 (set sl@Pcs)) )"
    , "                (! (=> (= (intersect r r0) empty-set@@sl@Pcs)"
    , "                       (= (qsum@@sl@Pcs (union r r0) (const@@sl@Pcs@@Int 1))"
    , "                          (+ (qsum@@sl@Pcs r (const@@sl@Pcs@@Int 1))"
    , "                             (qsum@@sl@Pcs r0 (const@@sl@Pcs@@Int 1)))))"
    , "                   :pattern"
    , "                   ( (qsum@@sl@Pcs (union r r0) (const@@sl@Pcs@@Int 1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (select (const@@sl@Pcs@@Int x) y) x)"
    , "                   :pattern"
    , "                   ( (select (const@@sl@Pcs@@Int x) y) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (x sl@Pcs)"
    , "                  (y sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs x (mk-set@@sl@Pcs y)) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int y (set@@sl@Pcs@@Int r1 term))"
    , "                      (exists ( (x sl@Pcs) )"
    , "                              (and (elem@@sl@Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (elem@@Int y (set@@sl@Pcs@@Int r1 term)) ))))"
    , "(assert (forall ( (r1 (set sl@Pcs))"
    , "                  (term (Array sl@Pcs Int))"
    , "                  (y Int) )"
    , "                (! (= (= (set@@sl@Pcs@@Int r1 term) (mk-set@@Int y))"
    , "                      (forall ( (x sl@Pcs) )"
    , "                              (=> (elem@@sl@Pcs x r1) (= (select term x) y))))"
    , "                   :pattern"
    , "                   ( (set@@sl@Pcs@@Int r1 term)"
    , "                     (mk-set@@Int y) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (forall ( (x sl@Pcs) )"
    , "                (! (finite@@sl@Pcs (mk-set@@sl@Pcs x))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (mk-set@@sl@Pcs x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@Int s2) (finite@@Int s1)))"
    , "                   :pattern"
    , "                   ( (finite@@Int s2)"
    , "                     (finite@@Int s1) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@Pcs s2) (finite@@sl@Pcs s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs s2)"
    , "                     (finite@@sl@Pcs s1) ))))"
    , "(assert (forall ( (@@fv@@_0 (set sl@Pcs))"
    , "                  (@@bv@@_0 sl@Pcs) )"
    , "                (! (= (elem@@sl@Pcs @@bv@@_0 (@@lambda@@_0 @@fv@@_0))"
    , "                      (elem@@sl@Pcs @@bv@@_0 @@fv@@_0))"
    , "                   :pattern"
    , "                   ( (elem@@sl@Pcs @@bv@@_0 (@@lambda@@_0 @@fv@@_0)) ))))"
    , "; SKIP:b"
    , "(assert (= b@prime b))"
    , "; SKIP:c"
    , "(assert (= c@prime c))"
    , "; SKIP:cs"
    , "(assert (= cs@prime cs))"
    , "; SKIP:fs"
    , "(assert (= fs@prime fs))"
    , "; SKIP:n"
    , "(assert (= n@prime n))"
    , "; SKIP:ts"
    , "(assert (= ts@prime ts))"
    , "; act1"
    , "(assert (= vs@prime (union vs (mk-set@@sl@Pcs p))))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; inv0"
    , "(assert (=> b (= vs sl@Pcs)))"
    , "; inv1"
    , "(assert (subset ts vs))"
    , "; inv2"
    , "(assert (subset cs vs))"
    , "; m3:inv0"
    , "(assert (= c (qsum@@sl@Pcs cs (const@@sl@Pcs@@Int 1))))"
    , "; m3:inv1"
    , "(assert (= n"
    , "           (qsum@@sl@Pcs (@@lambda@@_0 ts) (const@@sl@Pcs@@Int 1))))"
    , "; m3:inv2"
    , "(assert (finite@@sl@Pcs ts))"
    , "; m3:inv5"
    , "(assert (elem@@Int c (union (mk-set@@Int 0) (mk-set@@Int 1))))"
    , "; m3:inv6"
    , "(assert (= (intersect ts cs) empty-set@@sl@Pcs))"
    , "; m3:inv7"
    , "(assert (= fs (union ts cs)))"
    , "; thm0"
    , "(assert (= (= n (qsum@@sl@Pcs sl@Pcs (const@@sl@Pcs@@Int 1)))"
    , "           (= ts sl@Pcs)))"
    , "(assert (not (= c@prime"
    , "                (qsum@@sl@Pcs cs@prime (const@@sl@Pcs@@Int 1)))))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/visit/INV/m3:inv0"
    ]

case19 :: IO String
case19 = proof_obligation path0 "m3/INIT/SIM/in2" 3

result19 :: String
result19 = unlines
    [ "; m3/INIT/SIM/in2"
    , "(set-option :auto-config false)"
    , "(set-option :smt.timeout 3000)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "(declare-sort sl@Pcs 0)"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const b Bool)"
    , "(declare-const c Int)"
    , "(declare-const cs (set sl@Pcs))"
    , "(declare-const fs (set sl@Pcs))"
    , "(declare-const n Int)"
    , "(declare-const ts (set sl@Pcs))"
    , "(declare-const vs (set sl@Pcs))"
    , "(declare-fun finite@@sl@Pcs ( (set sl@Pcs) ) Bool)"
    , "(define-fun all@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(define-fun compl@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun empty-set@@sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              false ))"
    , "(define-fun set-diff@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            (set sl@Pcs)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@sl@Pcs"
    , "            ( (s1 (set sl@Pcs))"
    , "              (s2 (set sl@Pcs)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(define-fun sl@Pcs"
    , "            ()"
    , "            (set sl@Pcs)"
    , "            ( (as const (set sl@Pcs))"
    , "              true ))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (finite@@sl@Pcs s1)"
    , "                       (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (set-diff@@sl@Pcs s1 s2)) ))))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (and (finite@@sl@Pcs s1) (finite@@sl@Pcs s2))"
    , "                       (finite@@sl@Pcs (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs (union s1 s2)) ))))"
    , "(assert (finite@@sl@Pcs empty-set@@sl@Pcs))"
    , "(assert (forall ( (s1 (set sl@Pcs))"
    , "                  (s2 (set sl@Pcs)) )"
    , "                (! (=> (subset s1 s2)"
    , "                       (=> (finite@@sl@Pcs s2) (finite@@sl@Pcs s1)))"
    , "                   :pattern"
    , "                   ( (finite@@sl@Pcs s2)"
    , "                     (finite@@sl@Pcs s1) ))))"
    , "; asm0"
    , "(assert (finite@@sl@Pcs sl@Pcs))"
    , "; cs"
    , "(assert (= cs empty-set@@sl@Pcs))"
    , "; in0"
    , "(assert (= b false))"
    , "; m3:in0"
    , "(assert (= c 0))"
    , "; m3:in1"
    , "(assert (= n 0))"
    , "; m3:in2"
    , "(assert (= fs empty-set@@sl@Pcs))"
    , "; ts"
    , "(assert (= ts empty-set@@sl@Pcs))"
    , "(assert (not (= cs empty-set@@sl@Pcs)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    , "; m3/INIT/SIM/in2"
    ]

path21 :: FilePath
path21 = "Tests/puzzle/puzzle-err2.tex"

case21 :: IO String
case21 = find_errors path21

result21 :: String
result21 = unlines
    [ "event 'flick', coarse schedule 'sch1' refers to deleted variables"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 161:2:"
    , "\tcoarse schedule 'sch1'"
    , ""
    , ""
    , "event 'flick', guard 'grd0' refers to deleted variables"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 162:2:"
    , "\tguard 'grd0'"
    , ""
    , ""
    , "event 'term', coarse schedule 'sch2' refers to deleted variables"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 104:2:"
    , "\tcoarse schedule 'sch2'"
    , ""
    , ""
    , "event 'count', coarse schedule 'sch0' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 176:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    , "event 'flick', action 'act0' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 163:2:"
    , "\taction 'act0'"
    , ""
    , ""
    , "event 'flick', coarse schedule 'sch0' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 160:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    , "initialization predicate 'in2' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable cs"
    , ""
    , "error 175:2:"
    , "\tpredicate in2"
    , ""
    , ""
    , "error 204:2:"
    , "    event 'flick', action 'act' was deleted but does not exist"
    , "error 205:2:"
    , "    initialization predicate 'in' was deleted but does not exist"
    ]

path22 :: FilePath
path22 = "Tests/puzzle/puzzle-err3.tex"

case22 :: IO String
case22 = find_errors path22

result22 :: String
result22 = unlines
    [ "error 227:2:\n    'c' is not a disappearing variable or a new index"
    ]

path23 :: FilePath
path23 = "Tests/puzzle/puzzle-err4.tex"

case23 :: IO String
case23 = find_errors path23

result23 :: String
result23 = unlines
    [ "error 227:2:\n    deleted variable \'xyz\' does not exist"
    ]

case24 :: IO (Either [Error] (Set Label,Set Label))
case24 = runEitherT $ do
    m <- EitherT $ parse_machine path0 4
    return ( keysSet $ m!.inh_props.inv
           , keysSet $ m!.props.inv)

result24 :: Either [Error] (Set Label,Set Label)
result24 = Right ( S.fromList ["inv0","inv1","inv2","m3:inv0","m3:inv1"
                              ,"m3:inv2","m3:inv5","m3:inv6"
                              ,"m3:inv7"]
                 , S.fromList [])

path25 :: FilePath
path25 = "Tests/puzzle/puzzle-err5.tex"

case25 :: IO String
case25 = find_errors path25

result25 :: String
result25 = unlines
    [ "event 'flick', coarse schedule 'sch1' refers to deleted variables"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 161:2:"
    , "\tcoarse schedule 'sch1'"
    , ""
    , ""
    , "event 'flick', guard 'grd0' refers to deleted variables"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 162:2:"
    , "\tguard 'grd0'"
    , ""
    , ""
    , "event 'term', coarse schedule 'sch2' refers to deleted variables"
    , "error 101:4:"
    , "\tdeleted variable 'ts'"
    , ""
    , "error 104:2:"
    , "\tcoarse schedule 'sch2'"
    , ""
    , ""
    , "event 'count', coarse schedule 'sch0' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 176:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    , "event 'flick', coarse schedule 'sch0' refers to deleted variables"
    , "error 116:4:"
    , "\tdeleted variable 'cs'"
    , ""
    , "error 160:2:"
    , "\tcoarse schedule 'sch0'"
    , ""
    , ""
    ]

case27 :: IO (Either [Error] (Set Label,Set Label))
case27 = runEitherT $ do
    m <- EitherT $ parse_machine path0 3
    let evt = nonSkipUpwards m ! "flick"
    return ( keysSet $ evt^.evt_pairs.traverse.old.guards
           , keysSet $ evt^.new.guards)

result27 :: Either [Error] (Set Label,Set Label)
result27 = Right ( S.fromList ["grd0","grd1","sch0","sch1","sch2"]
                 , S.fromList ["grd1","m3:grd1","m3:grd2","m3:csch1","m3:csch2","sch2"])

case28 :: IO String
case28 = find_errors "Tests/puzzle/puzzle-err7.tex"

result28 :: String
result28 = unlines
    [ "error 238:24:"
    , "    Parameter mismatch. Expecting 1 type parameters, received 0."
    ]
