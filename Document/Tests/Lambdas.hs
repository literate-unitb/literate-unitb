module Document.Tests.Lambdas where

    -- Modules
import Document.Document
import Document.Tests.Suite

import Logic.Expr
import Logic.Proof

import Theories.FunctionTheory

import UnitB.AST

import Z3.Z3 hiding ( verify )

    -- Libraries
import Control.Monad.Trans.Either

import Data.Map hiding ( map )

import Tests.UnitTest

import Utilities.Syntactic

test_case :: TestCase
test_case = test

test :: TestCase
test = test_cases
            "lambda expressions in the cube example"
            [ part0
            , part1
            , part2
            , part3
            ]            
part0 :: TestCase
part0 = test_cases
            "part 0"
            [ (POCase "test 0, verification, lambda vs empty-fun" 
                (verify path0 0) result0)
            , (POCase "test 1, verification, lambda vs ovl, mk-fun" 
                (verify path1 0) result1)
            , (POCase "test 2, verification, lambda vs apply" 
                (verify path2 0) result2)
            ]            
part1 :: TestCase
part1 = test_cases
            "part 1"
            [ (POCase "test 3, verification, set comprehension, failed proof" 
                (verify path3 0) result3)
            , (Case "test 4, adding a progress property" case4 result4)
            , (Case "test 5, unless properties" case5 result5)
            ]            
part2 :: TestCase
part2 = test_cases
            "part 2"
            [ (POCase "test 6, verify progress refinement" case6 result6)
            , (POCase "test 7, verify refinement rules" case7 result7)
            , (POCase "test 8, verify refinement rules" case8 result8)
            ]            
part3 :: TestCase
part3 = test_cases
            "part 3"
            [ (POCase "test 9, verify disjunction rule" (verify path9 0) result9)
            , (StringCase "test 10, error: cyclic proof" (find_errors path10) result10)
            , (StringCase   "test 11, intermediate goals of monotonic \
                              \simplification" case11 result11)
            , (Case "test 12, bound variable with ambiguous type"
                case12 result12)
            ]

result0 :: String
result0 = unlines 
    [ "  o  m0/INIT/FIS/a"
    , "  o  m0/INIT/FIS/b"
    , "  o  m0/INIT/FIS/c"
    , "  o  m0/INIT/FIS/f"
    , "  o  m0/INIT/FIS/n"
    , "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal (221,1)"
    , "  o  m0/INIT/INV/inv3/hypotheses (221,1)"
    , "  o  m0/INIT/INV/inv3/relation (221,1)"
    , "  o  m0/INIT/INV/inv3/step (223,1)"
    , "  o  m0/INIT/INV/inv3/step (225,1)"
    , "  o  m0/INIT/INV/inv3/step (229,1)"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal (63,1)"
    , "  o  m0/evt/INV/inv0/hypotheses (63,1)"
    , "  o  m0/evt/INV/inv0/relation (63,1)"
    , "  o  m0/evt/INV/inv0/step (65,1)"
    , "  o  m0/evt/INV/inv0/step (67,1)"
    , "  o  m0/evt/INV/inv0/step (69,1)"
    , "  o  m0/evt/INV/inv0/step (71,1)"
    , "  o  m0/evt/INV/inv0/step (73,1)"
    , "  o  m0/evt/INV/inv1/goal (141,1)"
    , "  o  m0/evt/INV/inv1/hypotheses (141,1)"
    , "  o  m0/evt/INV/inv1/relation (141,1)"
    , "  o  m0/evt/INV/inv1/step (143,1)"
    , "  o  m0/evt/INV/inv1/step (145,1)"
    , "  o  m0/evt/INV/inv1/step (147,1)"
    , "  o  m0/evt/INV/inv1/step (149,1)"
    , "  o  m0/evt/INV/inv1/step (151,1)"
    , "  o  m0/evt/INV/inv1/step (153,1)"
    , "  o  m0/evt/INV/inv1/step (155,1)"
    , "  o  m0/evt/INV/inv2/easy (190,1)"
    , " xxx m0/evt/INV/inv3"
    , "  o  m0/evt/SCH"
    , "  o  m0/evt/WD/ACT/a0"
    , "  o  m0/evt/WD/ACT/a1"
    , "  o  m0/evt/WD/ACT/a2"
    , "  o  m0/evt/WD/ACT/a3"
    , "  o  m0/evt/WD/C_SCH"
    , "  o  m0/evt/WD/F_SCH"
    , "  o  m0/evt/WD/GRD"
    , "  o  m0/evt/WWD"
    , "passed 49 / 50"
    ]

path0 :: String
path0 = "tests/cubes-t0.tex"

result1 :: String
result1 = unlines
    [ "  o  m0/INIT/FIS/a"
    , "  o  m0/INIT/FIS/b"
    , "  o  m0/INIT/FIS/c"
    , "  o  m0/INIT/FIS/f"
    , "  o  m0/INIT/FIS/n"
    , "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal (221,1)"
    , "  o  m0/INIT/INV/inv3/hypotheses (221,1)"
    , "  o  m0/INIT/INV/inv3/relation (221,1)"
    , "  o  m0/INIT/INV/inv3/step (223,1)"
    , "  o  m0/INIT/INV/inv3/step (225,1)"
    , "  o  m0/INIT/INV/inv3/step (229,1)"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal (63,1)"
    , "  o  m0/evt/INV/inv0/hypotheses (63,1)"
    , "  o  m0/evt/INV/inv0/relation (63,1)"
    , "  o  m0/evt/INV/inv0/step (65,1)"
    , "  o  m0/evt/INV/inv0/step (67,1)"
    , "  o  m0/evt/INV/inv0/step (69,1)"
    , "  o  m0/evt/INV/inv0/step (71,1)"
    , "  o  m0/evt/INV/inv0/step (73,1)"
    , "  o  m0/evt/INV/inv1/goal (141,1)"
    , "  o  m0/evt/INV/inv1/hypotheses (141,1)"
    , "  o  m0/evt/INV/inv1/relation (141,1)"
    , "  o  m0/evt/INV/inv1/step (143,1)"
    , "  o  m0/evt/INV/inv1/step (145,1)"
    , "  o  m0/evt/INV/inv1/step (147,1)"
    , "  o  m0/evt/INV/inv1/step (149,1)"
    , "  o  m0/evt/INV/inv1/step (151,1)"
    , "  o  m0/evt/INV/inv1/step (153,1)"
    , "  o  m0/evt/INV/inv1/step (155,1)"
    , "  o  m0/evt/INV/inv2/easy (190,1)"
    , "  o  m0/evt/INV/inv3/goal (240,1)"
    , "  o  m0/evt/INV/inv3/hypotheses (240,1)"
    , "  o  m0/evt/INV/inv3/relation (240,1)"
    , "  o  m0/evt/INV/inv3/step (242,1)"
    , "  o  m0/evt/INV/inv3/step (244,1)"
    , "  o  m0/evt/INV/inv3/step (246,1)"
    , "  o  m0/evt/INV/inv3/step (248,1)"
    , "  o  m0/evt/INV/inv3/step (250,1)"
    , "  o  m0/evt/INV/inv3/step (252,1)"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/SCH"
    , "  o  m0/evt/WD/ACT/a0"
    , "  o  m0/evt/WD/ACT/a1"
    , "  o  m0/evt/WD/ACT/a2"
    , "  o  m0/evt/WD/ACT/a3"
    , "  o  m0/evt/WD/ACT/a4"
    , "  o  m0/evt/WD/C_SCH"
    , "  o  m0/evt/WD/F_SCH"
    , "  o  m0/evt/WD/GRD"
    , "  o  m0/evt/WWD"
    , "passed 62 / 62"
    ]

path1 :: String
path1 = "tests/cubes-t1.tex"

result2 :: String
result2 = unlines
    [ "  o  m0/INIT/FIS/a"
    , "  o  m0/INIT/FIS/b"
    , "  o  m0/INIT/FIS/c"
    , "  o  m0/INIT/FIS/f"
    , "  o  m0/INIT/FIS/n"
    , "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal (222,1)"
    , "  o  m0/INIT/INV/inv3/hypotheses (222,1)"
    , "  o  m0/INIT/INV/inv3/relation (222,1)"
    , "  o  m0/INIT/INV/inv3/step (224,1)"
    , "  o  m0/INIT/INV/inv3/step (226,1)"
    , "  o  m0/INIT/INV/inv3/step (230,1)"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal (64,1)"
    , "  o  m0/evt/INV/inv0/hypotheses (64,1)"
    , "  o  m0/evt/INV/inv0/relation (64,1)"
    , "  o  m0/evt/INV/inv0/step (66,1)"
    , "  o  m0/evt/INV/inv0/step (68,1)"
    , "  o  m0/evt/INV/inv0/step (70,1)"
    , "  o  m0/evt/INV/inv0/step (72,1)"
    , "  o  m0/evt/INV/inv0/step (74,1)"
    , "  o  m0/evt/INV/inv1/goal (142,1)"
    , "  o  m0/evt/INV/inv1/hypotheses (142,1)"
    , "  o  m0/evt/INV/inv1/relation (142,1)"
    , "  o  m0/evt/INV/inv1/step (144,1)"
    , "  o  m0/evt/INV/inv1/step (146,1)"
    , "  o  m0/evt/INV/inv1/step (148,1)"
    , "  o  m0/evt/INV/inv1/step (150,1)"
    , "  o  m0/evt/INV/inv1/step (152,1)"
    , "  o  m0/evt/INV/inv1/step (154,1)"
    , "  o  m0/evt/INV/inv1/step (156,1)"
    , "  o  m0/evt/INV/inv2/easy (191,1)"
    , "  o  m0/evt/INV/inv3/goal (241,1)"
    , "  o  m0/evt/INV/inv3/hypotheses (241,1)"
    , "  o  m0/evt/INV/inv3/relation (241,1)"
    , "  o  m0/evt/INV/inv3/step (243,1)"
    , "  o  m0/evt/INV/inv3/step (245,1)"
    , "  o  m0/evt/INV/inv3/step (247,1)"
    , "  o  m0/evt/INV/inv3/step (253,1)"
    , "  o  m0/evt/INV/inv3/step (255,1)"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/assertion/asm0/easy (298,1)"
    , "  o  m0/evt/INV/inv5/main goal/goal (279,1)"
    , "  o  m0/evt/INV/inv5/main goal/hypotheses (279,1)"
    , "  o  m0/evt/INV/inv5/main goal/relation (279,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (281,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (283,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (285,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (287,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (290,1)"
    , "  o  m0/evt/SCH"
    , "  o  m0/evt/WD/ACT/a0"
    , "  o  m0/evt/WD/ACT/a1"
    , "  o  m0/evt/WD/ACT/a2"
    , "  o  m0/evt/WD/ACT/a3"
    , "  o  m0/evt/WD/ACT/a4"
    , "  o  m0/evt/WD/C_SCH"
    , "  o  m0/evt/WD/F_SCH"
    , "  o  m0/evt/WD/GRD"
    , "  o  m0/evt/WWD"
    , "passed 71 / 71"
    ]

path2 :: String
path2 = "tests/cubes-t2.tex"

result3 :: String
result3 = unlines
    [ "  o  m0/INIT/FIS/a"
    , "  o  m0/INIT/FIS/b"
    , "  o  m0/INIT/FIS/c"
    , "  o  m0/INIT/FIS/f"
    , "  o  m0/INIT/FIS/n"
    , "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal (222,1)"
    , "  o  m0/INIT/INV/inv3/hypotheses (222,1)"
    , "  o  m0/INIT/INV/inv3/relation (222,1)"
    , "  o  m0/INIT/INV/inv3/step (224,1)"
    , "  o  m0/INIT/INV/inv3/step (226,1)"
    , "  o  m0/INIT/INV/inv3/step (230,1)"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/INV/inv6"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal (64,1)"
    , "  o  m0/evt/INV/inv0/hypotheses (64,1)"
    , "  o  m0/evt/INV/inv0/relation (64,1)"
    , "  o  m0/evt/INV/inv0/step (66,1)"
    , "  o  m0/evt/INV/inv0/step (68,1)"
    , "  o  m0/evt/INV/inv0/step (70,1)"
    , "  o  m0/evt/INV/inv0/step (72,1)"
    , "  o  m0/evt/INV/inv0/step (74,1)"
    , "  o  m0/evt/INV/inv1/goal (142,1)"
    , "  o  m0/evt/INV/inv1/hypotheses (142,1)"
    , "  o  m0/evt/INV/inv1/relation (142,1)"
    , "  o  m0/evt/INV/inv1/step (144,1)"
    , "  o  m0/evt/INV/inv1/step (146,1)"
    , "  o  m0/evt/INV/inv1/step (148,1)"
    , "  o  m0/evt/INV/inv1/step (150,1)"
    , "  o  m0/evt/INV/inv1/step (152,1)"
    , "  o  m0/evt/INV/inv1/step (154,1)"
    , "  o  m0/evt/INV/inv1/step (156,1)"
    , "  o  m0/evt/INV/inv2/easy (191,1)"
    , "  o  m0/evt/INV/inv3/goal (241,1)"
    , "  o  m0/evt/INV/inv3/hypotheses (241,1)"
    , "  o  m0/evt/INV/inv3/relation (241,1)"
    , "  o  m0/evt/INV/inv3/step (243,1)"
    , "  o  m0/evt/INV/inv3/step (245,1)"
    , "  o  m0/evt/INV/inv3/step (247,1)"
    , "  o  m0/evt/INV/inv3/step (253,1)"
    , "  o  m0/evt/INV/inv3/step (255,1)"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/assertion/asm0/easy (298,1)"
    , "  o  m0/evt/INV/inv5/main goal/goal (279,1)"
    , "  o  m0/evt/INV/inv5/main goal/hypotheses (279,1)"
    , "  o  m0/evt/INV/inv5/main goal/relation (279,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (281,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (283,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (285,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (287,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (290,1)"
    , "  o  m0/evt/INV/inv6"
    , "  o  m0/evt/SCH"
    , "  o  m0/evt/WD/ACT/a0"
    , "  o  m0/evt/WD/ACT/a1"
    , "  o  m0/evt/WD/ACT/a2"
    , "  o  m0/evt/WD/ACT/a3"
    , "  o  m0/evt/WD/ACT/a4"
    , "  o  m0/evt/WD/C_SCH"
    , "  o  m0/evt/WD/F_SCH"
    , "  o  m0/evt/WD/GRD"
    , "  o  m0/evt/WWD"
    , "passed 73 / 73"
    ]

path3 :: String
path3 = "tests/cubes-t3.tex"

result4 :: Either [Error] (Map Label ProgressProp)
result4 = either g Right (do
        q0 <- f `mzeq` zlambda [i_decl] 
            (mzle (mzint 0) i `mzand` mzless i bigN) 
            (mzpow i $ mzint 3)
        q1 <- bigN `mzeq` n
        q2 <- (k `mzless` n) `mzor` (n `mzeq` bigN)
        p1  <- (n `mzeq` k)
        p2  <- mzall [k `mzle` n, n `mzeq` k, mznot (n `mzeq` bigN)]
        p3 <-  mzall [n `mzeq` k, mznot (n `mzeq` bigN)]
        q3 <- mzor 
                (mzle k n `mzand` mznot (k `mzeq` n)) 
                (n `mzeq` bigN)
        q4 <- mznot (n `mzeq` k)
        return $ fromList 
            [   (label "prog0", LeadsTo [] ztrue q0)
            ,   (label "prog1", LeadsTo [] ztrue q1)
            ,   (label "prog2", LeadsTo [] p1 q2)
            ,   (label "prog3", LeadsTo [] p2 q3)
            ,   (label "prog4", LeadsTo [] p3 q4)
            ])
    where
        (k,_)      = var "k" int
        (i,i_decl) = var "i" int
        (f,_)      = var "f" (fun_type int int)
        (n,_)      = var "n" int
        (bigN,_)   = var "N" int
        li         = LI path4 0 0
        g xs = Left $ map (`Error` li) xs

path4 :: String
path4 = "tests/cubes-t6.tex"

case4 :: IO (Either [Error] (Map Label ProgressProp))
case4 = runEitherT (do
    ms <- EitherT $ parse path4 :: EitherT [Error] IO [Machine]
    case ms of
        [m] -> right $ progress $ props $ m
        _   -> left [Error "a single machine is expected" (LI "" 0 0)])

result5 :: Either [Error] (Map Label SafetyProp)
result5 = either g Right (do
        q0  <- bigN `mzeq` n
        p0  <- (k `mzle` n)
        q1  <- mznot (n `mzeq` k)
        p1  <- mzall
                [ n `mzeq` k
                , mznot (n `mzeq` bigN)
                ]
        return $ fromList 
            [   (label "saf0", Unless [k_decl] p0 q0 Nothing)
            ,   (label "saf1", Unless [k_decl] p1 q1 Nothing)
            ])
    where
        (k,k_decl) = var "k" int
        (n,_)      = var "n" int
        (bigN,_)   = var "N" int
        li         = LI path4 0 0
        g xs = Left $ map (`Error` li) xs

case5 :: IO (Either [Error] (Map Label SafetyProp))
case5 = runEitherT (do
    ms <- EitherT $ parse path4 :: EitherT [Error] IO [Machine]
    case ms of
        [m] -> right $ safety $ props $ m
        _   -> left [Error "a single machine is expected" (LI "" 0 0)])

case6 :: IO (String, Map Label Sequent)
case6 = verify path6 0

result6 :: String
result6 = unlines
    [ "  o  m0/INIT/FIS/a"
    , "  o  m0/INIT/FIS/b"
    , "  o  m0/INIT/FIS/c"
    , "  o  m0/INIT/FIS/f"
    , "  o  m0/INIT/FIS/n"
    , "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal (222,1)"
    , "  o  m0/INIT/INV/inv3/hypotheses (222,1)"
    , "  o  m0/INIT/INV/inv3/relation (222,1)"
    , "  o  m0/INIT/INV/inv3/step (224,1)"
    , "  o  m0/INIT/INV/inv3/step (226,1)"
    , "  o  m0/INIT/INV/inv3/step (230,1)"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/INV/inv6"
    , " xxx m0/INIT/INV/inv8"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/TR/tr0/evt/EN"
    , "  o  m0/TR/tr0/evt/NEG"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal (66,1)"
    , "  o  m0/evt/INV/inv0/hypotheses (66,1)"
    , "  o  m0/evt/INV/inv0/relation (66,1)"
    , "  o  m0/evt/INV/inv0/step (68,1)"
    , "  o  m0/evt/INV/inv0/step (70,1)"
    , "  o  m0/evt/INV/inv0/step (72,1)"
    , "  o  m0/evt/INV/inv0/step (74,1)"
    , "  o  m0/evt/INV/inv0/step (76,1)"
    , "  o  m0/evt/INV/inv1/goal (144,1)"
    , "  o  m0/evt/INV/inv1/hypotheses (144,1)"
    , "  o  m0/evt/INV/inv1/relation (144,1)"
    , "  o  m0/evt/INV/inv1/step (146,1)"
    , "  o  m0/evt/INV/inv1/step (148,1)"
    , "  o  m0/evt/INV/inv1/step (150,1)"
    , "  o  m0/evt/INV/inv1/step (152,1)"
    , "  o  m0/evt/INV/inv1/step (154,1)"
    , "  o  m0/evt/INV/inv1/step (156,1)"
    , "  o  m0/evt/INV/inv1/step (158,1)"
    , "  o  m0/evt/INV/inv2/easy (191,1)"
    , "  o  m0/evt/INV/inv3/goal (241,1)"
    , "  o  m0/evt/INV/inv3/hypotheses (241,1)"
    , "  o  m0/evt/INV/inv3/relation (241,1)"
    , "  o  m0/evt/INV/inv3/step (243,1)"
    , "  o  m0/evt/INV/inv3/step (245,1)"
    , "  o  m0/evt/INV/inv3/step (247,1)"
    , "  o  m0/evt/INV/inv3/step (253,1)"
    , "  o  m0/evt/INV/inv3/step (255,1)"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/assertion/asm0/easy (298,1)"
    , "  o  m0/evt/INV/inv5/main goal/goal (279,1)"
    , "  o  m0/evt/INV/inv5/main goal/hypotheses (279,1)"
    , "  o  m0/evt/INV/inv5/main goal/relation (279,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (281,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (283,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (285,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (287,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (290,1)"
    , "  o  m0/evt/INV/inv6/goal (308,1)"
    , "  o  m0/evt/INV/inv6/hypotheses (308,1)"
    , "  o  m0/evt/INV/inv6/relation (308,1)"
    , "  o  m0/evt/INV/inv6/step (310,1)"
    , "  o  m0/evt/INV/inv6/step (312,1)"
    , "  o  m0/evt/INV/inv6/step (314,1)"
    , "  o  m0/evt/INV/inv6/step (316,1)"
    , " xxx m0/evt/INV/inv6/step (318,1)"
    , "  o  m0/evt/INV/inv8"
    , "  o  m0/evt/SAF/saf0"
    , "  o  m0/evt/SCH"
    , "  o  m0/evt/SCH/m0/0/REF/weaken"
    , "  o  m0/evt/WD/ACT/a0"
    , "  o  m0/evt/WD/ACT/a1"
    , "  o  m0/evt/WD/ACT/a2"
    , "  o  m0/evt/WD/ACT/a3"
    , "  o  m0/evt/WD/ACT/a4"
    , "  o  m0/evt/WD/C_SCH"
    , "  o  m0/evt/WD/F_SCH"
    , "  o  m0/evt/WD/GRD"
    , "  o  m0/evt/WWD"
    , "  o  m0/prog0/PROG/WD/lhs"
    , "  o  m0/prog0/PROG/WD/rhs"
    , "  o  m0/prog0/REF/monotonicity/lhs"
    , "  o  m0/prog0/REF/monotonicity/rhs"
    , "  o  m0/prog1/PROG/WD/lhs"
    , "  o  m0/prog1/PROG/WD/rhs"
    , " xxx m0/prog1/REF/add"
    , "  o  m0/prog2/PROG/WD/lhs"
    , "  o  m0/prog2/PROG/WD/rhs"
    , "  o  m0/prog2/REF/trading/lhs"
    , "  o  m0/prog2/REF/trading/rhs"
    , "  o  m0/prog3/PROG/WD/lhs"
    , "  o  m0/prog3/PROG/WD/rhs"
    , "  o  m0/prog3/REF/PSP/lhs"
    , "  o  m0/prog3/REF/PSP/rhs"
    , "  o  m0/prog4/PROG/WD/lhs"
    , "  o  m0/prog4/PROG/WD/rhs"
    , "  o  m0/prog4/REF/discharge/tr/lhs"
    , " xxx m0/prog4/REF/discharge/tr/rhs"
    , "  o  m0/saf0/SAF/WD/lhs"
    , "  o  m0/saf0/SAF/WD/rhs"
    , "  o  m0/tr0/TR/WD"
    , "passed 104 / 108"
    ]

path6 :: String
path6 = "tests/cubes-t5.tex"

case7 :: IO (String, Map Label Sequent)
case7 = verify path7 0

result7 :: String
result7 = unlines
    [ "  o  m0/INIT/FIS/a"
    , "  o  m0/INIT/FIS/b"
    , "  o  m0/INIT/FIS/c"
    , "  o  m0/INIT/FIS/f"
    , "  o  m0/INIT/FIS/n"
    , "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal (224,1)"
    , "  o  m0/INIT/INV/inv3/hypotheses (224,1)"
    , "  o  m0/INIT/INV/inv3/relation (224,1)"
    , "  o  m0/INIT/INV/inv3/step (226,1)"
    , "  o  m0/INIT/INV/inv3/step (228,1)"
    , "  o  m0/INIT/INV/inv3/step (232,1)"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/INV/inv6"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal (66,1)"
    , "  o  m0/evt/INV/inv0/hypotheses (66,1)"
    , "  o  m0/evt/INV/inv0/relation (66,1)"
    , "  o  m0/evt/INV/inv0/step (68,1)"
    , "  o  m0/evt/INV/inv0/step (70,1)"
    , "  o  m0/evt/INV/inv0/step (72,1)"
    , "  o  m0/evt/INV/inv0/step (74,1)"
    , "  o  m0/evt/INV/inv0/step (76,1)"
    , "  o  m0/evt/INV/inv1/goal (144,1)"
    , "  o  m0/evt/INV/inv1/hypotheses (144,1)"
    , "  o  m0/evt/INV/inv1/relation (144,1)"
    , "  o  m0/evt/INV/inv1/step (146,1)"
    , "  o  m0/evt/INV/inv1/step (148,1)"
    , "  o  m0/evt/INV/inv1/step (150,1)"
    , "  o  m0/evt/INV/inv1/step (152,1)"
    , "  o  m0/evt/INV/inv1/step (154,1)"
    , "  o  m0/evt/INV/inv1/step (156,1)"
    , "  o  m0/evt/INV/inv1/step (158,1)"
    , "  o  m0/evt/INV/inv2/easy (193,1)"
    , "  o  m0/evt/INV/inv3/goal (243,1)"
    , "  o  m0/evt/INV/inv3/hypotheses (243,1)"
    , "  o  m0/evt/INV/inv3/relation (243,1)"
    , "  o  m0/evt/INV/inv3/step (245,1)"
    , "  o  m0/evt/INV/inv3/step (247,1)"
    , "  o  m0/evt/INV/inv3/step (249,1)"
    , "  o  m0/evt/INV/inv3/step (255,1)"
    , "  o  m0/evt/INV/inv3/step (257,1)"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/assertion/asm0/easy (300,1)"
    , "  o  m0/evt/INV/inv5/main goal/goal (281,1)"
    , "  o  m0/evt/INV/inv5/main goal/hypotheses (281,1)"
    , "  o  m0/evt/INV/inv5/main goal/relation (281,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (283,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (285,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (287,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (289,1)"
    , "  o  m0/evt/INV/inv5/main goal/step (292,1)"
    , "  o  m0/evt/INV/inv6/goal (310,1)"
    , "  o  m0/evt/INV/inv6/hypotheses (310,1)"
    , "  o  m0/evt/INV/inv6/relation (310,1)"
    , "  o  m0/evt/INV/inv6/step (312,1)"
    , "  o  m0/evt/INV/inv6/step (314,1)"
    , "  o  m0/evt/INV/inv6/step (316,1)"
    , "  o  m0/evt/INV/inv6/step (318,1)"
    , " xxx m0/evt/INV/inv6/step (320,1)"
    , "  o  m0/evt/SAF/saf0"
    , "  o  m0/evt/SCH"
    , "  o  m0/evt/WD/ACT/a0"
    , "  o  m0/evt/WD/ACT/a1"
    , "  o  m0/evt/WD/ACT/a2"
    , "  o  m0/evt/WD/ACT/a3"
    , "  o  m0/evt/WD/ACT/a4"
    , "  o  m0/evt/WD/C_SCH"
    , "  o  m0/evt/WD/F_SCH"
    , "  o  m0/evt/WD/GRD"
    , "  o  m0/evt/WWD"
    , "  o  m0/prog0/PROG/WD/lhs"
    , "  o  m0/prog0/PROG/WD/rhs"
    , "  o  m0/prog0/REF/monotonicity/lhs"
    , "  o  m0/prog0/REF/monotonicity/rhs"
    , "  o  m0/prog1/PROG/WD/lhs"
    , "  o  m0/prog1/PROG/WD/rhs"
    , " xxx m0/prog1/REF/add"
    , "  o  m0/prog10/PROG/WD/lhs"
    , "  o  m0/prog10/PROG/WD/rhs"
    , " xxx m0/prog10/REF/add"
    , "  o  m0/prog2/PROG/WD/lhs"
    , "  o  m0/prog2/PROG/WD/rhs"
    , " xxx m0/prog2/REF/trading/lhs"
    , "  o  m0/prog2/REF/trading/rhs"
    , "  o  m0/prog3/PROG/WD/lhs"
    , "  o  m0/prog3/PROG/WD/rhs"
    , " xxx m0/prog3/REF/PSP/lhs"
    , " xxx m0/prog3/REF/PSP/rhs"
    , "  o  m0/prog4/PROG/WD/lhs"
    , "  o  m0/prog4/PROG/WD/rhs"
    , " xxx m0/prog4/REF/add"
    , "  o  m0/prog5/PROG/WD/lhs"
    , "  o  m0/prog5/PROG/WD/rhs"
    , " xxx m0/prog5/REF/transitivity/lhs"
    , "  o  m0/prog5/REF/transitivity/mhs/prog6/prog7"
    , "  o  m0/prog5/REF/transitivity/rhs"
    , "  o  m0/prog6/PROG/WD/lhs"
    , "  o  m0/prog6/PROG/WD/rhs"
    , " xxx m0/prog6/REF/add"
    , "  o  m0/prog7/PROG/WD/lhs"
    , "  o  m0/prog7/PROG/WD/rhs"
    , " xxx m0/prog7/REF/add"
    , "  o  m0/prog8/PROG/WD/lhs"
    , "  o  m0/prog8/PROG/WD/rhs"
    , "  o  m0/prog8/REF/transitivity/lhs"
    , "  o  m0/prog8/REF/transitivity/mhs/prog9/prog10"
    , "  o  m0/prog8/REF/transitivity/rhs"
    , "  o  m0/prog9/PROG/WD/lhs"
    , "  o  m0/prog9/PROG/WD/rhs"
    , " xxx m0/prog9/REF/add"
    , "  o  m0/saf0/SAF/WD/lhs"
    , "  o  m0/saf0/SAF/WD/rhs"
    , "passed 112 / 123"
    ]

path7 :: String
path7 = "tests/cubes-t4.tex"

case8 :: IO (String, Map Label Sequent)
case8 = verify path8 0

result8 :: String
result8 = unlines
    [ "  o  m0/INIT/FIS/a"
    , "  o  m0/INIT/FIS/b"
    , "  o  m0/INIT/FIS/c"
    , "  o  m0/INIT/FIS/f"
    , "  o  m0/INIT/FIS/n"
    , "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal (224,1)"
    , "  o  m0/INIT/INV/inv3/hypotheses (224,1)"
    , "  o  m0/INIT/INV/inv3/relation (224,1)"
    , "  o  m0/INIT/INV/inv3/step (226,1)"
    , "  o  m0/INIT/INV/inv3/step (228,1)"
    , "  o  m0/INIT/INV/inv3/step (232,1)"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/INV/inv6"
    , "  o  m0/INIT/INV/inv7"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/TR/tr0/evt/EN"
    , "  o  m0/TR/tr0/evt/NEG"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal (66,1)"
    , "  o  m0/evt/INV/inv0/hypotheses (66,1)"
    , "  o  m0/evt/INV/inv0/relation (66,1)"
    , "  o  m0/evt/INV/inv0/step (68,1)"
    , "  o  m0/evt/INV/inv0/step (70,1)"
    , "  o  m0/evt/INV/inv0/step (72,1)"
    , "  o  m0/evt/INV/inv0/step (74,1)"
    , "  o  m0/evt/INV/inv0/step (76,1)"
    , "  o  m0/evt/INV/inv1/goal (144,1)"
    , "  o  m0/evt/INV/inv1/hypotheses (144,1)"
    , "  o  m0/evt/INV/inv1/relation (144,1)"
    , "  o  m0/evt/INV/inv1/step (146,1)"
    , "  o  m0/evt/INV/inv1/step (148,1)"
    , "  o  m0/evt/INV/inv1/step (150,1)"
    , "  o  m0/evt/INV/inv1/step (152,1)"
    , "  o  m0/evt/INV/inv1/step (154,1)"
    , "  o  m0/evt/INV/inv1/step (156,1)"
    , "  o  m0/evt/INV/inv1/step (158,1)"
    , "  o  m0/evt/INV/inv2/easy (193,1)"
    , "  o  m0/evt/INV/inv3/goal (243,1)"
    , "  o  m0/evt/INV/inv3/hypotheses (243,1)"
    , "  o  m0/evt/INV/inv3/relation (243,1)"
    , "  o  m0/evt/INV/inv3/step (245,1)"
    , "  o  m0/evt/INV/inv3/step (247,1)"
    , "  o  m0/evt/INV/inv3/step (249,1)"
    , "  o  m0/evt/INV/inv3/step (255,1)"
    , "  o  m0/evt/INV/inv3/step (257,1)"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/goal (281,1)"
    , "  o  m0/evt/INV/inv5/hypotheses (281,1)"
    , "  o  m0/evt/INV/inv5/relation (281,1)"
    , "  o  m0/evt/INV/inv5/step (283,1)"
    , "  o  m0/evt/INV/inv5/step (285,1)"
    , "  o  m0/evt/INV/inv5/step (287,1)"
    , "  o  m0/evt/INV/inv5/step (289,1)"
    , "  o  m0/evt/INV/inv5/step (292,1)"
    , "  o  m0/evt/INV/inv6/goal (310,1)"
    , "  o  m0/evt/INV/inv6/hypotheses (310,1)"
    , "  o  m0/evt/INV/inv6/relation (310,1)"
    , "  o  m0/evt/INV/inv6/step (312,1)"
    , "  o  m0/evt/INV/inv6/step (314,1)"
    , "  o  m0/evt/INV/inv6/step (316,1)"
    , "  o  m0/evt/INV/inv6/step (318,1)"
    , " xxx m0/evt/INV/inv6/step (320,1)"
    , "  o  m0/evt/INV/inv7"
    , "  o  m0/evt/SAF/saf0"
    , "  o  m0/evt/SAF/saf1"
    , "  o  m0/evt/SCH"
    , "  o  m0/evt/SCH/m0/0/REF/weaken"
    , "  o  m0/evt/WD/ACT/a0"
    , "  o  m0/evt/WD/ACT/a1"
    , "  o  m0/evt/WD/ACT/a2"
    , "  o  m0/evt/WD/ACT/a3"
    , "  o  m0/evt/WD/ACT/a4"
    , "  o  m0/evt/WD/C_SCH"
    , "  o  m0/evt/WD/F_SCH"
    , "  o  m0/evt/WD/GRD"
    , "  o  m0/evt/WWD"
    , "  o  m0/prog0/PROG/WD/lhs"
    , "  o  m0/prog0/PROG/WD/rhs"
    , "  o  m0/prog0/REF/monotonicity/lhs"
    , "  o  m0/prog0/REF/monotonicity/rhs"
    , "  o  m0/prog1/PROG/WD/lhs"
    , "  o  m0/prog1/PROG/WD/rhs"
    , "  o  m0/prog1/REF/induction/lhs"
    , "  o  m0/prog1/REF/induction/rhs"
    , "  o  m0/prog2/PROG/WD/lhs"
    , "  o  m0/prog2/PROG/WD/rhs"
    , "  o  m0/prog2/REF/trading/lhs"
    , "  o  m0/prog2/REF/trading/rhs"
    , "  o  m0/prog3/PROG/WD/lhs"
    , "  o  m0/prog3/PROG/WD/rhs"
    , "  o  m0/prog3/REF/PSP/lhs"
    , "  o  m0/prog3/REF/PSP/rhs"
    , "  o  m0/prog4/PROG/WD/lhs"
    , "  o  m0/prog4/PROG/WD/rhs"
    , "  o  m0/prog4/REF/discharge/saf/lhs"
    , "  o  m0/prog4/REF/discharge/saf/rhs"
    , "  o  m0/prog4/REF/discharge/tr"
    , "  o  m0/saf0/SAF/WD/lhs"
    , "  o  m0/saf0/SAF/WD/rhs"
    , "  o  m0/saf1/SAF/WD/lhs"
    , "  o  m0/saf1/SAF/WD/rhs"
    , "  o  m0/tr0/TR/WD"
    , "passed 111 / 112"
    ]
  
path8 :: String
path8 = "tests/cubes-t7.tex"

result9 :: String
result9 = unlines
    [ "  o  m0/INIT/FIS/a"
    , "  o  m0/INIT/FIS/b"
    , "  o  m0/INIT/FIS/c"
    , "  o  m0/INIT/FIS/f"
    , "  o  m0/INIT/FIS/n"
    , "  o  m0/INIT/INV/inv0"
    , "  o  m0/INIT/INV/inv1"
    , "  o  m0/INIT/INV/inv2"
    , "  o  m0/INIT/INV/inv3/goal (223,1)"
    , "  o  m0/INIT/INV/inv3/hypotheses (223,1)"
    , "  o  m0/INIT/INV/inv3/relation (223,1)"
    , "  o  m0/INIT/INV/inv3/step (225,1)"
    , "  o  m0/INIT/INV/inv3/step (227,1)"
    , "  o  m0/INIT/INV/inv3/step (231,1)"
    , "  o  m0/INIT/INV/inv4"
    , "  o  m0/INIT/INV/inv5"
    , "  o  m0/INIT/INV/inv6"
    , "  o  m0/INIT/INV/inv7"
    , "  o  m0/INIT/WD"
    , "  o  m0/INIT/WWD"
    , "  o  m0/INV/WD"
    , "  o  m0/TR/tr0/evt/EN"
    , "  o  m0/TR/tr0/evt/NEG"
    , "  o  m0/evt/FIS/a@prime"
    , "  o  m0/evt/FIS/b@prime"
    , "  o  m0/evt/FIS/c@prime"
    , "  o  m0/evt/FIS/f@prime"
    , "  o  m0/evt/FIS/n@prime"
    , "  o  m0/evt/INV/inv0/goal (66,1)"
    , "  o  m0/evt/INV/inv0/hypotheses (66,1)"
    , "  o  m0/evt/INV/inv0/relation (66,1)"
    , "  o  m0/evt/INV/inv0/step (68,1)"
    , "  o  m0/evt/INV/inv0/step (70,1)"
    , "  o  m0/evt/INV/inv0/step (72,1)"
    , "  o  m0/evt/INV/inv0/step (74,1)"
    , "  o  m0/evt/INV/inv0/step (76,1)"
    , "  o  m0/evt/INV/inv1/goal (144,1)"
    , "  o  m0/evt/INV/inv1/hypotheses (144,1)"
    , "  o  m0/evt/INV/inv1/relation (144,1)"
    , "  o  m0/evt/INV/inv1/step (146,1)"
    , "  o  m0/evt/INV/inv1/step (148,1)"
    , "  o  m0/evt/INV/inv1/step (150,1)"
    , "  o  m0/evt/INV/inv1/step (152,1)"
    , "  o  m0/evt/INV/inv1/step (154,1)"
    , "  o  m0/evt/INV/inv1/step (156,1)"
    , "  o  m0/evt/INV/inv1/step (158,1)"
    , "  o  m0/evt/INV/inv2/easy (192,1)"
    , "  o  m0/evt/INV/inv3/goal (242,1)"
    , "  o  m0/evt/INV/inv3/hypotheses (242,1)"
    , "  o  m0/evt/INV/inv3/relation (242,1)"
    , "  o  m0/evt/INV/inv3/step (244,1)"
    , "  o  m0/evt/INV/inv3/step (246,1)"
    , "  o  m0/evt/INV/inv3/step (248,1)"
    , "  o  m0/evt/INV/inv3/step (254,1)"
    , "  o  m0/evt/INV/inv3/step (256,1)"
    , "  o  m0/evt/INV/inv4"
    , "  o  m0/evt/INV/inv5/goal (280,1)"
    , "  o  m0/evt/INV/inv5/hypotheses (280,1)"
    , "  o  m0/evt/INV/inv5/relation (280,1)"
    , "  o  m0/evt/INV/inv5/step (282,1)"
    , "  o  m0/evt/INV/inv5/step (284,1)"
    , "  o  m0/evt/INV/inv5/step (286,1)"
    , "  o  m0/evt/INV/inv5/step (288,1)"
    , "  o  m0/evt/INV/inv5/step (291,1)"
    , "  o  m0/evt/INV/inv6/goal (309,1)"
    , "  o  m0/evt/INV/inv6/hypotheses (309,1)"
    , "  o  m0/evt/INV/inv6/relation (309,1)"
    , "  o  m0/evt/INV/inv6/step (311,1)"
    , "  o  m0/evt/INV/inv6/step (313,1)"
    , "  o  m0/evt/INV/inv6/step (315,1)"
    , "  o  m0/evt/INV/inv6/step (317,1)"
    , " xxx m0/evt/INV/inv6/step (319,1)"
    , "  o  m0/evt/INV/inv7"
    , "  o  m0/evt/SAF/saf0"
    , "  o  m0/evt/SAF/saf1"
    , "  o  m0/evt/SCH"
    , "  o  m0/evt/SCH/m0/0/REF/weaken"
    , "  o  m0/evt/WD/ACT/a0"
    , "  o  m0/evt/WD/ACT/a1"
    , "  o  m0/evt/WD/ACT/a2"
    , "  o  m0/evt/WD/ACT/a3"
    , "  o  m0/evt/WD/ACT/a4"
    , "  o  m0/evt/WD/C_SCH"
    , "  o  m0/evt/WD/F_SCH"
    , "  o  m0/evt/WD/GRD"
    , "  o  m0/evt/WWD"
    , "  o  m0/prog0/PROG/WD/lhs"
    , "  o  m0/prog0/PROG/WD/rhs"
    , "  o  m0/prog0/REF/monotonicity/lhs"
    , "  o  m0/prog0/REF/monotonicity/rhs"
    , "  o  m0/prog1/PROG/WD/lhs"
    , "  o  m0/prog1/PROG/WD/rhs"
    , "  o  m0/prog1/REF/induction/lhs"
    , "  o  m0/prog1/REF/induction/rhs"
    , "  o  m0/prog2/PROG/WD/lhs"
    , "  o  m0/prog2/PROG/WD/rhs"
    , "  o  m0/prog2/REF/trading/lhs"
    , "  o  m0/prog2/REF/trading/rhs"
    , "  o  m0/prog3/PROG/WD/lhs"
    , "  o  m0/prog3/PROG/WD/rhs"
    , "  o  m0/prog3/REF/PSP/lhs"
    , "  o  m0/prog3/REF/PSP/rhs"
    , "  o  m0/prog4/PROG/WD/lhs"
    , "  o  m0/prog4/PROG/WD/rhs"
    , "  o  m0/prog4/REF/discharge/saf/lhs"
    , "  o  m0/prog4/REF/discharge/saf/rhs"
    , "  o  m0/prog4/REF/discharge/tr"
    , "  o  m0/prog5/PROG/WD/lhs"
    , "  o  m0/prog5/PROG/WD/rhs"
    , "  o  m0/prog5/REF/disjunction/lhs"
    , "  o  m0/prog5/REF/disjunction/rhs"
    , "  o  m0/prog6/PROG/WD/lhs"
    , "  o  m0/prog6/PROG/WD/rhs"
    , " xxx m0/prog6/REF/add"
    , "  o  m0/prog7/PROG/WD/lhs"
    , "  o  m0/prog7/PROG/WD/rhs"
    , " xxx m0/prog7/REF/add"
    , "  o  m0/prog8/PROG/WD/lhs"
    , "  o  m0/prog8/PROG/WD/rhs"
    , " xxx m0/prog8/REF/add"
    , "  o  m0/saf0/SAF/WD/lhs"
    , "  o  m0/saf0/SAF/WD/rhs"
    , "  o  m0/saf1/SAF/WD/lhs"
    , "  o  m0/saf1/SAF/WD/rhs"
    , "  o  m0/tr0/TR/WD"
    , "passed 121 / 125"
    ]

path9 :: String
path9 = "tests/cubes-t8.tex"
     
path10 :: String
path10 = "tests/cubes-t9.tex"

result10 :: String
result10 = unlines
    [ "error: A cycle exists in the liveness proof"
    , "\tProgress property prog0 (refined in m0): (338,68)"
    , "\tProgress property prog1 (refined in m0): (340,36)"
    , "\tProgress property prog2 (refined in m0): (342,49)"
    , "\tProgress property prog3 (refined in m0): (346,26)"
    , ""
    ]

case11 :: IO String
case11 = do
        pos <- list_file_obligations path2
        case pos of
            Right [(_,pos)] -> do
                let po = pos ! label "m0/evt/INV/inv5/main goal/step (287,1)"
                    cmd = unlines $ map pretty_print' $ z3_code po
                return cmd
            x -> return $ show x

result11 :: String
result11 = unlines 
    [ "(set-option :auto-config false)"
    , "(declare-datatypes (a) ( (Maybe (Just (fromJust a)) Nothing) ))"
    , "(declare-datatypes () ( (Null null) ))"
    , "(declare-datatypes (a b) ( (Pair (pair (first a) (second b))) ))"
    , "; comment: we don't need to declare the sort Bool"
    , "; comment: we don't need to declare the sort Int"
    , "; comment: we don't need to declare the sort Real"
    , "(define-sort pfun (a b) (Array a (Maybe b)))"
    , "(define-sort set (a) (Array a Bool))"
    , "(declare-const a Int)"
    , "(declare-const a@prime Int)"
    , "(declare-const b Int)"
    , "(declare-const b@prime Int)"
    , "(declare-const c Int)"
    , "(declare-const c@prime Int)"
    , "(declare-const f (pfun Int Int))"
    , "(declare-const f@prime (pfun Int Int))"
    , "(declare-const i Int)"
    , "(declare-const n Int)"
    , "(declare-const n@prime Int)"
    , "(declare-fun apply@@Int@@Int ( (pfun Int Int) Int ) Int)"
    , "(declare-fun dom-rest@@Int@@Int"
    , "             ( (set Int)"
    , "               (pfun Int Int) )"
    , "             (pfun Int Int))"
    , "(declare-fun dom-subt@@Int@@Int"
    , "             ( (set Int)"
    , "               (pfun Int Int) )"
    , "             (pfun Int Int))"
    , "(declare-fun dom@@Int@@Int ( (pfun Int Int) ) (set Int))"
    , "(declare-fun empty-fun@@Int@@Int () (pfun Int Int))"
    , "(declare-fun finite@@Int ( (set Int) ) Bool)"
    , "(declare-fun injective@@Int@@Int ( (pfun Int Int) ) Bool)"
    , "(declare-fun mk-fun@@Int@@Int (Int Int) (pfun Int Int))"
    , "(declare-fun mk-set@@Int (Int) (set Int))"
    , "(declare-fun ovl@@Int@@Int"
    , "             ( (pfun Int Int)"
    , "               (pfun Int Int) )"
    , "             (pfun Int Int))"
    , "(declare-fun ran@@Int@@Int ( (pfun Int Int) ) (set Int))"
    , "(define-fun compl@@Int"
    , "            ( (s1 (set Int)) )"
    , "            (set Int)"
    , "            ( (_ map not)"
    , "              s1 ))"
    , "(define-fun elem@@Int"
    , "            ( (x Int)"
    , "              (s1 (set Int)) )"
    , "            Bool"
    , "            (select s1 x))"
    , "(define-fun empty-set@@Int"
    , "            ()"
    , "            (set Int)"
    , "            ( (as const (set Int))"
    , "              false ))"
    , "(define-fun set-diff@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            (set Int)"
    , "            (intersect s1 ( (_ map not) s2 )))"
    , "(define-fun st-subset@@Int"
    , "            ( (s1 (set Int))"
    , "              (s2 (set Int)) )"
    , "            Bool"
    , "            (and (subset s1 s2) (not (= s1 s2))))"
    , "(assert (forall ( (i Int) )"
    , "                (! (= (elem@@Int i (dom@@Int@@Int f))"
    , "                      (and (<= 0 i) (< i n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int i (dom@@Int@@Int f)) ))))"
    , "(assert (= f@prime (ovl@@Int@@Int f (mk-fun@@Int@@Int n a))))"
    , "(assert (= (dom@@Int@@Int empty-fun@@Int@@Int)"
    , "           empty-set@@Int))"
    , "(assert (forall ( (f1 (pfun Int Int)) )"
    , "                (! (= (ovl@@Int@@Int f1 empty-fun@@Int@@Int) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@Int f1 empty-fun@@Int@@Int) ))))"
    , "(assert (forall ( (f1 (pfun Int Int)) )"
    , "                (! (= (ovl@@Int@@Int empty-fun@@Int@@Int f1) f1)"
    , "                   :pattern"
    , "                   ( (ovl@@Int@@Int empty-fun@@Int@@Int f1) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (dom@@Int@@Int (mk-fun@@Int@@Int x y))"
    , "                      (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (mk-fun@@Int@@Int x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (f2 (pfun Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Int f2))"
    , "                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x)"
    , "                          (apply@@Int@@Int f2 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (f2 (pfun Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                            (not (elem@@Int x (dom@@Int@@Int f2))))"
    , "                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x)"
    , "                          (apply@@Int@@Int f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 f2) x) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (apply@@Int@@Int (mk-fun@@Int@@Int x y) x) y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (mk-fun@@Int@@Int x y) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (and (elem@@Int x s1) (elem@@Int x (dom@@Int@@Int f1)))"
    , "                       (= (apply@@Int@@Int (dom-rest@@Int@@Int s1 f1) x)"
    , "                          (apply@@Int@@Int f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (dom-rest@@Int@@Int s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Int f1) s1))"
    , "                       (= (apply@@Int@@Int (dom-subt@@Int@@Int s1 f1) x)"
    , "                          (apply@@Int@@Int f1 x)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (dom-subt@@Int@@Int s1 f1) x) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (f2 (pfun Int Int)) )"
    , "                (! (= (dom@@Int@@Int (ovl@@Int@@Int f1 f2))"
    , "                      (union (dom@@Int@@Int f1) (dom@@Int@@Int f2)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (ovl@@Int@@Int f1 f2)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Int (dom-rest@@Int@@Int s1 f1))"
    , "                      (intersect s1 (dom@@Int@@Int f1)))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (dom-rest@@Int@@Int s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int)) )"
    , "                (! (= (dom@@Int@@Int (dom-subt@@Int@@Int s1 f1))"
    , "                      (set-diff@@Int (dom@@Int@@Int f1) s1))"
    , "                   :pattern"
    , "                   ( (dom@@Int@@Int (dom-subt@@Int@@Int s1 f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (= (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                           (= (apply@@Int@@Int f1 x) y))"
    , "                      (= (select f1 x) (Just y)))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (dom@@Int@@Int f1))"
    , "                     (apply@@Int@@Int f1 x)"
    , "                     (select f1 x)"
    , "                     (Just y) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (x2 Int)"
    , "                  (y Int) )"
    , "                (! (=> (not (= x x2))"
    , "                       (= (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x2)"
    , "                          (apply@@Int@@Int f1 x2)))"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x2) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (= (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x)"
    , "                      y)"
    , "                   :pattern"
    , "                   ( (apply@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)) x) ))))"
    , "(assert (= (ran@@Int@@Int empty-fun@@Int@@Int)"
    , "           empty-set@@Int))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int y (ran@@Int@@Int f1))"
    , "                      (exists ( (x Int) )"
    , "                              (and true"
    , "                                   (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                                        (= (apply@@Int@@Int f1 x) y)))))"
    , "                   :pattern"
    , "                   ( (elem@@Int y (ran@@Int@@Int f1)) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (ran@@Int@@Int (mk-fun@@Int@@Int x y))"
    , "                      (mk-set@@Int y))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Int (mk-fun@@Int@@Int x y)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int)) )"
    , "                (! (= (injective@@Int@@Int f1)"
    , "                      (forall ( (x Int)"
    , "                                (x2 Int) )"
    , "                              (=> (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                                       (elem@@Int x2 (dom@@Int@@Int f1)))"
    , "                                  (=> (= (apply@@Int@@Int f1 x) (apply@@Int@@Int f1 x2))"
    , "                                      (= x x2)))))"
    , "                   :pattern"
    , "                   ( (injective@@Int@@Int f1) ))))"
    , "(assert (injective@@Int@@Int empty-fun@@Int@@Int))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (dom@@Int@@Int f1))"
    , "                       (elem@@Int (apply@@Int@@Int f1 x) (ran@@Int@@Int f1)))"
    , "                   :pattern"
    , "                   ( (elem@@Int (apply@@Int@@Int f1 x) (ran@@Int@@Int f1)) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (set-diff@@Int (dom@@Int@@Int f1) s1))"
    , "                       (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                  (ran@@Int@@Int (dom-subt@@Int@@Int s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                (ran@@Int@@Int (dom-subt@@Int@@Int s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (s1 (set Int))"
    , "                  (x Int) )"
    , "                (! (=> (elem@@Int x (intersect (dom@@Int@@Int f1) s1))"
    , "                       (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                  (ran@@Int@@Int (dom-rest@@Int@@Int s1 f1))))"
    , "                   :pattern"
    , "                   ( (elem@@Int (apply@@Int@@Int f1 x)"
    , "                                (ran@@Int@@Int (dom-rest@@Int@@Int s1 f1))) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (=> (and (elem@@Int x (dom@@Int@@Int f1))"
    , "                            (injective@@Int@@Int f1))"
    , "                       (= (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)))"
    , "                          (union (set-diff@@Int (ran@@Int@@Int f1)"
    , "                                                (mk-set@@Int (apply@@Int@@Int f1 x)))"
    , "                                 (mk-set@@Int y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y))) ))))"
    , "(assert (forall ( (f1 (pfun Int Int))"
    , "                  (x Int)"
    , "                  (y Int) )"
    , "                (! (=> (not (elem@@Int x (dom@@Int@@Int f1)))"
    , "                       (= (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y)))"
    , "                          (union (ran@@Int@@Int f1) (mk-set@@Int y))))"
    , "                   :pattern"
    , "                   ( (ran@@Int@@Int (ovl@@Int@@Int f1 (mk-fun@@Int@@Int x y))) ))))"
    , "(assert (forall ( (x Int)"
    , "                  (y Int) )"
    , "                (! (= (elem@@Int x (mk-set@@Int y)) (= x y))"
    , "                   :pattern"
    , "                   ( (elem@@Int x (mk-set@@Int y)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (finite@@Int s1)"
    , "                       (finite@@Int (set-diff@@Int s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (set-diff@@Int s1 s2)) ))))"
    , "(assert (forall ( (s1 (set Int))"
    , "                  (s2 (set Int)) )"
    , "                (! (=> (and (finite@@Int s1) (finite@@Int s2))"
    , "                       (finite@@Int (union s1 s2)))"
    , "                   :pattern"
    , "                   ( (finite@@Int (union s1 s2)) ))))"
    , "(assert (forall ( (x Int) )"
    , "                (! (finite@@Int (mk-set@@Int x))"
    , "                   :pattern"
    , "                   ( (finite@@Int (mk-set@@Int x)) ))))"
    , "(assert (finite@@Int empty-set@@Int))"
    , "(assert (forall ( (i Int) )"
    , "                (! (= (elem@@Int i (dom@@Int@@Int f))"
    , "                      (and (<= 0 i) (< i n)))"
    , "                   :pattern"
    , "                   ( (elem@@Int i (dom@@Int@@Int f)) ))))"
    , "(assert (not (= (forall ( (i Int) )"
    , "                        (=> (and (<= 0 i) (< i n))"
    , "                            (= (apply@@Int@@Int f@prime i) (^ i 3))))"
    , "                (forall ( (i Int) )"
    , "                        (=> (and (<= 0 i) (< i n))"
    , "                            (= (apply@@Int@@Int f i) (^ i 3)))))))"
    , "(assert (not (forall ( (i Int) )"
    , "                     (=> true"
    , "                         (= (=> (and (<= 0 i) (< i n))"
    , "                                (= (apply@@Int@@Int f@prime i) (^ i 3)))"
    , "                            (=> (and (<= 0 i) (< i n))"
    , "                                (= (apply@@Int@@Int f i) (^ i 3))))))))"
    , "(assert (not (= (=> (and (<= 0 i) (< i n))"
    , "                    (= (apply@@Int@@Int f@prime i) (^ i 3)))"
    , "                (=> (and (<= 0 i) (< i n))"
    , "                    (= (apply@@Int@@Int f i) (^ i 3))))))"
    , "(assert (not (= (= (apply@@Int@@Int f@prime i) (^ i 3))"
    , "                (= (apply@@Int@@Int f i) (^ i 3)))))"
    , "(assert (not (= (apply@@Int@@Int f@prime i) (apply@@Int@@Int f i))))"
    , "(assert (not (= f@prime f)))"
    , "(check-sat-using (or-else (then qe smt)"
    , "                          (then simplify smt)"
    , "                          (then skip smt)"
    , "                          (then (using-params simplify :expand-power true) smt)))"
    ]

path12 :: String
path12 = "Tests/cubes-t10.tex"

result12 :: String
result12 = unlines 
        [  "error (274,2): type of j is ill-defined: _a"
        ]

case12 :: IO String
case12 = find_errors path12


